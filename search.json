[{"title":"CSS 小技巧紀錄園地","url":"%2F2019%2F08%2F29%2FCSStips%2F","content":"\n![](https://images.unsplash.com/photo-1523540939399-141cbff6a8d7?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=750&q=80)\n\n## 文章目的\n有鑑於在練習前端過程中，會遇到一些好用的 css 程式碼來呈現需要的網頁效果，但因為只是小技巧，不適合寫成一篇文章，因此利用此文章來為這些小技巧做個紀錄。\n<!-- more -->\n\n## input number 隱藏預設加減箭頭方法\n我們在使用 `<input type=\"number>` 時，有時候會因為預設的加減箭頭帶來困擾，且因為這兩個箭頭會導致我們的內容數字無法置中，這邊提供一段程式碼來隱藏這兩個箭頭。\n```css\ninput[type='number']::-webkit-inner-spin-button,\ninput[type='number']::-webkit-outer-spin-button {\n-webkit-appearance: none;\nmargin: 0;\n```\n這樣我們就可以達到隱藏箭頭的效果囉。\n**參考文章** --- [Center text in html number input](https://stackoverflow.com/questions/23715881/center-text-in-html-number-input)","tags":["SCSS"],"categories":["CSS"]},{"title":"利用 CSS 做出 offcanvas 遮罩效果","url":"%2F2019%2F08%2F22%2FCssMenuMask%2F","content":"\n![](https://i.imgur.com/t4j5FN5.jpg)\n\n## 文章目的\n我們在逛一些具有響應式設計的網站時，在較小裝置點開 offcanvas 的 menu 時會有類似遮罩效果出現在畫面上，此文章將用來記錄如何利用 css 做出一樣的效果。\n<!-- more -->\n## 本次示範 Demo\n這邊先附上要呈現的效果圖\n**點擊漢堡選單前**\n![](https://i.imgur.com/tutiujp.png)\n**點擊漢堡選單後**\n![](https://i.imgur.com/qNexvaJ.png)\n\n## 效果分析\n其實遮罩並沒有想像中那麼難達成，基本上只需要設置一個佔滿螢幕大小的 `div` 並利用絕對定位就可以輕鬆達成。\n遮罩的顏色我們可以根據背景色不同來做更換。\n\n## 示範程式碼\n### 遮罩製作\n我先做出一個包覆 menu 的區塊元素，並將其寬高設為裝置的寬高，程式碼如下：\n```html\n<aside class=\"side min-vh-100 min-vw-100\"> \n\n</aside>\n\n<style>\n.side{\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    background-color: rgba($color:#696969, $alpha: 0.7);\n    transition: all .3s;\n    transform: translateX(-100vw);\n    overflow: hidden;\n  }\n</style>\n```\n另外用絕對定位讓它脫離排版，並且利用 `transform` 將其隱藏，**這邊有很重要的一點要注意!!!!** 筆者在一開始打算把 offcanvas 隱藏在畫面右邊，結果發現無法隱藏，後來才驚覺到因為**排版是左至右因此隱藏到右邊行不通，要用 `transform` 的方法隱藏必須隱藏在畫面左邊**。\n步驟進行到這裡我們已經有個覆蓋裝置畫面的遮罩。\n\n### offcanvas menu 設置\n接著將 menu 的 `ul` `li` 寫入我們剛剛創的遮罩中，程式碼如下：\n```html\n<aside class=\"side min-vh-100 min-vw-100\">\n    <ul class=\"liststyleNone p-0 m-0 px-2 offcanvas\">\n        <i class=\"fas fa-times-circle cancel text-primary fa-2x\" @click=\"closeOffcanvas\"></i>\n        <li class=\"mt-5 d-flex justify-content-center p-0 m-0\">\n            <router-link to=\"/login\" class=\"mainNavbarBtn pt-2 h3\"><i class=\"fas fa-user mr-2\"></i>後台登入</router-link>\n        </li>\n        <li class=\"mt-5 d-flex justify-content-center p-0 m-0\">\n            <a href=\"#\" class=\"mainNavbarBtn pt-2 h3\"><i class=\"fas fa-ticket-alt mr-2\"></i>優惠卷<i class=\"fas fa-angle-down ml-2\"></i></a>\n        </li>\n        <li class=\"mt-5 d-flex justify-content-center p-0 m-0\">\n            <a href=\"#\" class=\"mainNavbarBtn pt-2 h3\"><i class=\"fas fa-shopping-cart mr-2\"></i>購物車<i class=\"fas fa-angle-down ml-2\"></i></a>\n        </li>\n        <li class=\"my-5 d-flex justify-content-center p-0 m-0\">\n            <a href=\"#\" class=\"mainNavbarBtn pt-2 h3\"><i class=\"fas fa-shopping-bag mr-2\"></i>全部商品<i class=\"fas fa-angle-down ml-2\"></i></a>\n        </li>\n    </ul>\n</aside>\n\n<style>\n .offcanvas{\n    min-width: 50vw;\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    background-color: rgba($color: #DCDCDC, $alpha: 0.8);\n    overflow: auto  /*加入此屬性才能讓內容改變時跟著自適應*/\n  }\n</style>\n```\n這邊我是設定 menu 的寬度為裝置的一半，同樣的利用絕對定位來決定它在遮罩上的位置。\n最後我們只需要設置點擊漢堡選單與叉叉時為遮罩新增與移除 className 即可， class 的部分只需要修改遮罩 `transform` 的位置就會有出現與隱藏的效果。\n**這裡有一點要注意的是若我們沒有在新增的 className 中寫入 `overflow: auto` 這個屬性會導致 offcanvas 不會出現滾動條在內容過多時，會無法順利觀看。**\n```css\n/*遮罩新增的 className*/\n.offcanvasShow{\n    transform: translateX(0);\n    overflow: auto\n  }\n```\n\n---\n\n## 參考資料\n[JS CSS實現彈出全屏灰黑色透明遮罩效果的方法](https://codertw.com/%E5%89%8D%E7%AB%AF%E9%96%8B%E7%99%BC/281513/)","tags":["SCSS"],"categories":["CSS"]},{"title":"利用 CSS 做出簡單的按鈕 hover 動畫回饋","url":"%2F2019%2F08%2F21%2FCssBtnHoverSmallFeedback%2F","content":"\n![](https://i.imgur.com/DHCpWu1.jpg)\n\n## 文章目的\n因為最近在練習製作電商網站，學到了一個不錯的按鈕 hover 回饋小技巧，想藉此篇文章做個紀錄。\n<!-- more -->\n\n## 使用技巧與介紹\n### transform\n這是一個 css 屬性可以讓使用此屬性的元素，達到被平移、旋轉、縮放和傾斜等操作，那這次我們主要用到的是 translate 這個平移屬性。\ntranslate 的特性是可以根據我們設定的值，**以元素中心點為基準平移**。\n### transition\ntransition 也是一個 css 屬性，我們可以操作此屬性，來決定元素顯示的快慢與時間。\n### css 偽元素\n偽元素是個很方便的技巧，在小地方會發揮想不到的效果，基本上偽元素會根據我們的主要元素來顯示，最常看到的就是 before 與 after，分別代表在主元素之前或是之後顯示的元素。\n\n## 本次效果說明\n我們要讓按鈕在 hover 時，頭上會有由中心點展開的線條，如下圖所示\n**觸發前**\n![](https://i.imgur.com/IIQ4IFd.png)\n**觸發後**\n![](https://i.imgur.com/6cwpx6p.png)\n\n## CSS 撰寫\n這邊我先貼上完成的程式碼，在做一一解釋：\n```scss\n .mainNavbarBtn{\n        position: relative;\n        color: rgba($color: white, $alpha: 0.8);\n        &::before{\n            position: absolute;\n            content: '';\n            top: 0;\n            left: 50%;\n            height: 3px;\n            background: white;\n            width: 0%;\n            transform: translateX(-50%);\n            transition: all .3s\n        }\n        &:hover{\n            color: rgba($color: white, $alpha: 1.0);\n            &::before{\n            position: absolute;\n            content: '';\n            top: 0;\n            left: 50%;\n            height: 3px;\n            background: white;\n            width: 100%;\n            transform: translateX(-50%);\n            transition: all .3s\n        }\n            text-decoration: none;\n        }\n    }\n```\n* 偽元素設置：這邊我們先為主元素設定一個 `position: relative` 來方便定位我們的偽元素，那因為是在上頭顯示因此用 before 或 after 就顯得沒那麼重要，若是左右顯示 before、after 就會有差別，再來是**偽元素的重點屬性 `content`**，`content` 會決定我們偽元素的內容，那因為我們只需要線條，所以可以不用填入內容，但 `content` 這屬性還是必須寫入。\n* transform 應用：因為我們的目的是要讓線條可以從中心點向兩側發散顯示，預設顯示會是從左邊頭顯示到右邊尾。\n因此我們需要利用到絕對定位與 transform 來達到效果。\n我們先用絕對定位將線條位移主元素的 50% 寬度，這時線條的頭會在主元素寬度中間的位置，這時線條顯示時的確會從中心出發，但又會有個問題，線條出發到結束一樣從左到右，且因為我們起始位置改變導致線條長度超出我們的主元素寬度。\n這時我們就需要用到 transform 來修正我們線條位置，我們設定 transform 往 x 軸的負方向偏移 50% 將多出的部分轉移回來，這樣視覺上我們就會以為是從中間向兩側發散。\n* transition 效果：最後我們只需要加入 transition 設定我們線條的顯示時間，就會有漸變的效果出現囉!!\n\n---\n\n## 參考資料\n[卡斯伯老師偽元素介紹](https://wcc723.github.io/css/2013/09/22/css-pseudo-element/)\n[transform各效果應用](https://boohover.pixnet.net/blog/post/35341387-%E6%97%8B%E8%BD%89%E3%80%81%E5%82%BE%E6%96%9C%E3%80%81%E7%B8%AE%E6%94%BE%E7%9A%84%E8%AE%8A%E5%BD%A2%E6%95%88%E6%9E%9C-transform-(css-prope)","tags":["SCSS"],"categories":["CSS"]},{"title":"Vue.js 電商練習技術整理 -- 利用 v-model 技巧建立表單篩選功能","url":"%2F2019%2F08%2F20%2FEcommercePractice9%2F","content":"\n![](https://i.imgur.com/el9rgW2.jpg)\n\n## 文章目的\n當我們在使用電商網站時無論是前後台都會因為資料過多，無法即時找到含有特定條件的資料，本文將示範利用 v-model 簡單建立出後台的訂單篩選功能。\n<!-- more -->\n\n## 搞懂篩選機制(單選)\n我們可以利用 radio 做出單選的篩選表單出來，當我們點選需要的 radio 時透過 value 出來的值來決定要顯示的資料。\n\n## 替 radio 綁定 v-model\n為甚麼要用 v-model 呢？原因是我們可以在每次點選 radio 時將 value 的值透過 v-model 儲存在 Vue 的 Data 裡，再利用 v-for 做資料篩選，以下是 radio 程式碼：\n```html\n<div class=\"dropdown-menu\" aria-labelledby=\"dropdownMenuButton\">\n    <div class=\"form-check m-2\">\n        <input class=\"form-check-input\" type=\"radio\" name=\"paidRadios\" id=\"allRadios\" value='all' checked v-model=\"selectOption\">\n        <label class=\"form-check-label\" for=\"allRadios\">全部</label>\n    </div>\n    <div class=\"form-check m-2\">\n        <input class=\"form-check-input\" type=\"radio\" name=\"paidRadios\" id=\"paidRadios\" value=\"paid\" v-model=\"selectOption\">\n        <label class=\"form-check-label text-success\" for=\"paidRadios\">已付款</label>\n    </div>\n    <div class=\"form-check m-2\">\n        <input class=\"form-check-input\" type=\"radio\" name=\"paidRadios\" id=\"unpaidRadios\" value=\"nopaid\" v-model=\"selectOption\">\n        <label class=\"form-check-label text-muted\" for=\"unpaidRadios\">未付款</label>\n    </div>\n</div>\n```\n這邊可以看到上述程式碼有3組個 radio 選項，每個選項的 value 值都不同，但都綁定相同的 v-model，當我們點選選項時，選項的 value 值就會被存進我們綁定的 v-model 上。\n\n## 撰寫篩選條件\n表單資料部分，利用 computed 做資料的篩選條件，像本次範例就以**已付款**、**未付款**作為篩選條件，以下是 computed 的範例程式碼：\n```js\n  computed: {\n    selectOrders () {\n      const vm = this\n      if (vm.selectOption === 'all') {\n        return vm.orders\n      } else if (vm.selectOption === 'paid') {\n        return vm.orders.filter((item) => {\n          return item.is_paid //已付款\n        })\n      } else if (vm.selectOption === 'nopaid') {\n        return vm.orders.filter((item) => {\n          return !item.is_paid //未付款\n        })\n      }\n    }\n  }\n```\n這邊針對上述程式碼做個解釋，我們先將從後端抓到的所有訂單資料儲存在 `orders` 這個陣列裡，接著透過我們 v-model 綁定的 `selectOption` 來篩選特定條件的資料。\n如果有預設頁面的顯示資料的話可以先在 `selectOption` 填入對應的值，像是如果一開始顯示全部資料我們可以填入`all`。\n**這樣就完成一個簡單的資料篩選功能囉~~~**\n\n## 參考資料\n[Vue.js: data、v-model 與雙向綁定](https://cythilya.github.io/2017/04/14/vue-data-v-model/)","tags":["E-commerce"],"categories":["Vue.js"]},{"title":"Vue 小技術小工具園地","url":"%2F2019%2F08%2F13%2FVueTips%2F","content":"\n![](https://images.unsplash.com/photo-1534398079543-7ae6d016b86a?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=750&q=80)\n\n## 文章目的\n有鑑於現在在練習利用 Vue 開發電商網站，中間會發現一些前端前輩提供的好用程式碼，或是一些好用的套件、工具，想透過此文章記錄下來，方便以後回憶查找。\n若陸續發現好用的工具與程式碼會持續更新，或許會出好幾回XD\n<!--more-->\n## Vue Awesome Swiper 讓 Vue 輕鬆使用輪播功能\nVue Awesome Swiper 是一個提供 Vue 能使用輪播功能的套件，我們只需做簡單的安裝與引用就可以達到效果。\n### 安裝與引用套件\n  1. 在終端機輸入 `npm install vue-awesome-swiper --save` 進行安裝。\n  2. 此套件可以做全域與區域的引用，這邊我們要介紹如何全域引用它，來到進入點(main.js)，在裡面輸入以下程式碼：\n  ```js\n  import VueAwesomeSwiper from 'vue-awesome-swiper'\n  import 'swiper/dist/css/swiper.css'\n  Vue.use(VueAwesomeSwiper)\n  ```\n  進行到這邊我們已完成安裝與引用的動作，接下來就是使用它。\n### Vue Awesome Swiper 使用方法\n  1. 在需要使用的 Vue 元件 html 部分載入以下程式碼：\n  ```html\n  <swiper :options=\"swiperOption\">\n        <swiper-slide><img src=\"...\"></swiper-slide>\n        <swiper-slide><img src=\"...\"></swiper-slide>\n        <swiper-slide><img src=\"...\"></swiper-slide>\n  </swiper>\n  ```\n  每一個 `swiper-slide` 就是一張輪播圖片，裡面不一定要使用 `img` 也可以使用 `background-image` 方式去設定圖片。\n  `swiper` 綁定的 `options` 提供我們對輪播的參數設定。\n  2. 來到 js 部分對輪播做一些簡單設定與介紹，程式碼如下：\n  ```js\n  export default {\n  name: 'carousel',\n  data () {\n    return {\n      swiperOption: {\n        autoplay: {\n          delay: 2500, /*自動輪播間格時間*/\n          disableOnInteraction: false /*使用者拖曳輪播時是否取消自動輪播*/\n        },\n        loop: true, /*是否重複輪播*/\n        effect: 'fade' /*輪播顯示效果(預設為slide)*/\n        }\n      }\n    }\n  }\n  ```\n  這邊只做一些簡單的介紹，若需要其他額外效果或了解其他參數，這邊附上我找到的相關文章，另外基本上**參數部分都與 swiper 這個套件相同**。\n  [參數與效果示範](https://segmentfault.com/a/1190000014609379#autoplay)\n  [swiper官方文件](https://3.swiper.com.cn/)\n  [Vue Awesome Swiper官方文件](https://github.com/surmon-china/vue-awesome-swiper)\n\n## Vue Filter 金錢格式程式碼(currency)\n有時候我們會需要將數字轉換成金錢的格式，像是加入千分號及錢字號，這邊提供一個 js 程式碼，方便套用至 Vue filter 就可以輕鬆轉換格式。\n```js\nexport default function (num) {\n  const n = Number(num)\n  return `$${n.toFixed(0).replace(/./g, (c, i, a) => {\n    const currency = (i && c !== '.' && ((a.length - i) % 3 === 0) ? `, ${c}`.replace(/\\s/g, '') : c)\n    return currency\n  })}`\n}\n```\n\n## Vue filter 日期格式程式碼(date)\n在我們抓取日期時，基本上後端抓來的日期都會是 Timestamp 格式，這邊提供將 Timestamp 轉換成一般時間格式的程式碼，方便使用在 Vue filter 裡。\n```js\nexport default function (time) {\n  const date = new Date(time * 1000)\n  return date.toLocaleDateString()\n}\n```\n","tags":["Vue.js"],"categories":["Vue.js"]},{"title":"Vue.js 電商練習技術整理 -- 使用 VeeValidate 輕鬆建立表單驗證","url":"%2F2019%2F08%2F09%2FEcommercePractice8%2F","content":"\n![](https://i.imgur.com/el9rgW2.jpg)\n\n## 文章目的\n我們應該都有經驗在網路上購買東西，填寫資料時若資料填寫不完整，會導致表單無法送出，無法完成訂單程序，往往使用者在填寫訂單時會需要填入一些必要的資料。\n本文章將用來記錄用 Vue.js 開發時如何使用 VeeValidate 來驗證使用者資料正不正確，若不正確就阻止資料的送出。\n<!--more-->\n## VeeValidate 簡介\nVeeValidate 是 Vue.js 表單驗證的外掛套件，使用它我們只需在需要驗證的表單上加入一些特定語法就可以建立驗證，附上[官方文件](https://baianat.github.io/vee-validate/guide/)。\n\n## VeeValidate 安裝及引用\n### 套件安裝\n一樣打開我們的終端機輸入`npm install vee-validate --save` 安裝至我們的 Vue Cli 裡，那當然也有 cdn 的方式，相關內容可以觀看官方文件。\n### 中文化安裝及引用\n因為 VeeValidate 有支援中文，所以我們接下來要將 VeeValidate 引用至我們的專案，並且將其中文化。\n#### 中文化 \n為了支援中文，我們需要先在終端機輸入`npm install vue-i18n --save`。\n#### 引用與設定\n安裝完成後，來到進入點(main.js) import 以下幾支檔案：\n```js\nimport VeeValidate from 'vee-validate'\nimport zhTW from 'vee-validate/dist/locale/zh_TW'\nimport VueI18n from 'vue-i18n'\n```\n接著我們在下面做以下設定：\n```js\nVue.use(VueI18n)\n\nconst i18n = new VueI18n({\n  locale: 'zhTW'\n})\nVue.use(VeeValidate, {\n  events: 'input|blur', //這是為了讓使用者離開該欄位時觸發驗證\n  i18n,\n  dictionary: {\n    zhTW\n  }\n})\n```\n另外要記得在下面 `new Vue` 中把 `i18n` 載入，如下：\n```js\nnew Vue({\n  i18n,\n  el: '#app',\n  router,\n  components: { App },\n  template: '<App/>'\n})\n```\n進行到這裡我們就完成中文化與引用的步驟了，每個 Vue 元件中可以正常使用 VeeValidate。\n## 表單驗證設定\n### 基本寫法\n我們來到需要驗證的 `html input` 標籤，先來看看程式碼：\n```html\n<div class=\"form-group\">\n      <label for=\"username\">收件人姓名</label>\n      <input type=\"text\" class=\"form-control\" name=\"name\" id=\"username\" :class=\"{'is-invalid':errors.has('name')}\"\n        v-model=\"form.user.name\" placeholder=\"輸入姓名\" v-validate=\"'required'\">\n      <span class=\"text-danger\" v-if=\"errors.has('name')\">姓名必須輸入</span>\n</div>\n```\n上面是一個利用 Bootstrap 4 表單做出來的版型，這裡有幾個重點：\n* `input` 標籤內要設定 `name`這個屬性，屬性值的部分則是根據該欄位性質做設定，例：姓名就是 name，地址就是 address。\n當然屬性值根據當下情況自己命名即可。\n* **必須在 `input` 標籤裡加上 `v-validate=\"'required'\"`**，這是為了讓系統知道這一個欄位是必填的。\n* 接著我們可以寫入提示文字效果，像是上面的「姓名必須輸入」，我們透過 v-if 去控制它若驗證錯誤就顯示文字，至於 `errors.has('name')` 括號填入我們剛剛說的 `name` 屬性值，它就會幫我們判斷 true or false ，當是 **true 時驗證失敗，false 時驗證成功**。\n* VeeValidate 可以與 Bootstrap 4 的驗證效果共用，因此我們一樣可以利用 v-if 的方式來動態新增 `is-invalid` 這個 className 讓提示更加明顯。\n### email寫法\n這邊要額外提到 email 欄位的驗證法，email 會跟其他資料欄位有點不一樣，因此分出來講解。\n一樣的我們先來看看程式碼：\n```html\n<div class=\"form-group\">\n      <label for=\"useremail\">Email</label>\n      <input type=\"email\" class=\"form-control\" name=\"email\" id=\"useremail\" :class=\"{'is-invalid':errors.has('email')}\"\n        v-model=\"form.user.email\" placeholder=\"請輸入 Email\" v-validate=\"'required|email'\">\n      <span class=\"text-danger\" v-if=\"errors.has('email')\">{{errors.first('email')}}</span>\n</div>\n```\n這邊有兩個地方跟基本寫法不太一樣。\n* 在我們設定 `v-validate=\"'required|email'\"` 時，需要在 `required` 後面加入 `email`，這樣在驗證時才會以 email 的格式來驗證。\n* 另外在驗證提示文字用**兩個中括號包覆填入 errors.first\\('email'\\)**，會顯示 VeeValidate 的預設文字，它會根據 email 驗證的各種狀態來顯示不同的提示文字，我們一開始設定的中文化也在這邊派上用場，提示文字會是中文。\n## 驗證方法設定\n進行到這邊我們的表單已經能正常驗證，但是這僅僅是效果，若我們搭配 API 去設計表單的話依然一樣會將資料送出，因此我們需要利用方法來阻止 API 的接取，根據官方提供的寫法，可以這樣寫：\n```js\n this.$validator.validate().then((valid) => {\n        if (valid) {\n           // 當驗證成功時執行 AJAX 的行為\n          })\n        } else {\n           // 驗證失敗產生的行為\n        }\n      })\n```\n上述的方法可以加在 submit 後觸發的事件內。\n\n---\n\n## 參考資料\n[六角學院課程--Vue 出一個電商網站](https://www.hexschool.com/vue/)\n[官方方法使用](https://baianat.github.io/vee-validate/guide/events.html#changing-events-per-field)","tags":["E-commerce"],"categories":["Vue.js"]},{"title":"Vue.js 電商練習技術整理 -- event bus 元件間的溝通橋樑","url":"%2F2019%2F08%2F06%2FEcommercePractice7%2F","content":"\n![](https://i.imgur.com/el9rgW2.jpg)\n\n## 文章目的\n在我們開發 Vue 的專案時，每個元件檔案間都會有內外層的差別，例：一個 Root 下有兩個 side 每個 side 底下又有3個元件，當我們需要利用內層的資料來觸發外層的事件時，會需要一層一層的將資料向上傳遞，這會顯得較為麻煩，因此我們可以利用 event bus 的方式，直接將我們內層的資料傳遞給外層作使用。\n<!--more-->\n## event bus 簡介\nevent bus 的重點在於它可以幫我們把特定事件直接掛載到 Vue 的 原型下(Prototype)，元件間透過 **$on(監聽)**以及 **$emit(觸發)**兩種行為來達到內層觸發外層事件的效果。\n\n## 透過 event bus 將內層資料傳遞至外層觸發 alert 效果\n### 新增 alert 模板\n我們可以在 Vue Cli 的 components 資料夾底下新增一個 AlertMessage 的元件，並在裡面設計我們的 alert 模板。\n### 將 event bus 掛載到原型上\n掛載到原型上的目的是為了讓所有元件皆能使用。\n在 Vue Cli 的 src 資料夾底下新增一個 bus.js 並在裡面輸入以下程式碼以完成掛載：\n```js\nimport Vue from 'vue'\n\nVue.prototype.$bus = new Vue()  //$bus 為自訂義的名稱可以自行命名，建議要加上$\n```\n接著我們在進入點(main.js)下 import 這隻檔案進來。\n```js\nimport './bus'\n```\n### 在 AlertMessage 元件下做監聽\n因為我們要讓底層元件觸發 event bus 時， event bus 會將相關資料傳遞到 AlertMessage 做使用，所以我們在 AlertMessage 中加入 event bus 的監聽，程式碼如下：\n```js\n  created () {\n    const vm = this\n    // 自定義名稱 'messsage:push'\n    // message: 傳入參數\n    // status: 樣式，預設值為 warning\n    vm.$bus.$on('message:push', (message, status = 'warning') => {\n      vm.updateMessage(message, status)\n    })\n  }\n```\n主要監聽時會有幾個屬性與參數可以做設定，自定義的名稱以及監聽的參數，**基本上參數就會是內層傳遞上來的資料**，接著可以將這些資料參數套用到元件內的其他 methods 中。\n像在本次範例中將參數傳遞給 `updateMessage` 做使用，以下附上完整程式碼：\n```js\nexport default {\n  name: 'Navbar',\n  data () {\n    return {\n      messages: []\n    }\n  },\n  methods: {\n    updateMessage (message, status) {\n      const timestamp = Math.floor(new Date() / 1000)\n      this.messages.push({  //以下3個數值會影響到 alert 顯示結果\n        message,  //alert 顯示的訊息\n        status,  //alert 的顏色\n        timestamp  //alert 的 id\n      })\n      this.removeMessageWithTiming(timestamp)\n    },\n    //手動關閉 alert \n    removeMessage (num) {\n      this.messages.splice(num, 1)\n    },\n    //讓訊息顯示後5秒自動消失\n    removeMessageWithTiming (timestamp) {\n      const vm = this\n      setTimeout(() => {\n        vm.messages.forEach((item, i) => {\n          if (item.timestamp === timestamp) {\n            vm.messages.splice(i, 1)\n          }\n        })\n      }, 5000)\n    }\n  },\n  created () {\n    const vm = this\n    vm.$bus.$on('message:push', (message, status = 'warning') => {\n      vm.updateMessage(message, status)\n    })\n  }\n}\n```\n完成 alert 部分的設定後我們可以將此元件 import 進要顯示訊息的 Dashboard 元件下。\n```js\nimport Alert from './AlertMessage'\nexport default {\n  components: {\n    Alert\n  }\n} \n```\n要記得將元件加入 HTML 裡。\n```html\n<template>\n    <div>\n        <Navbar/>\n        <Alert></Alert>\n        <div class=\"container-fluid\">\n            <div class=\"row\">\n                <Sidebar></Sidebar>\n            <main role=\"main\" class=\"col-md-9 ml-sm-auto col-lg-10 px-4\">\n                <router-view></router-view>\n            </main>\n            </div>\n        </div>\n    </div>\n </template>\n```\n### 在內層的 Products 元件上新增 event bus 的觸發事件\n透過 ajax 的失敗，觸發 event bus 將相關參數傳遞給 AlertMessage，以下是程式碼：\n```js\n      this.$http.post(url, formData, {\n        headers: {\n          'Content-Type': 'multipart/form-data'\n        }\n      }).then((response) => {\n        console.log(response.data)\n        if (response.data.success) {\n          vm.status.fileUploading = false\n          vm.$set(vm.tempProduct, 'imageUrl', response.data.imageUrl)\n        } else {\n          this.$bus.$emit('message:push', response.data.message, 'danger')\n        }\n      })\n    }\n```\n我們在之前 formData 上傳圖片的事件中，新增若上傳失敗就觸發 `message:push` 並根據我們當初自訂的格式回傳相關參數。\n當 AlertMessage 收到我們回傳的參數時，就會根據這些參數去渲染 alert 效果。\n## 小技巧補充\n有時候我們在定義 event bus 的事件名稱及相關參數時會忘記是在哪個元件上做定義，因此我們可以利用註解的方式，將我們的定義方法寫在 bus.js 裡以方便了解。\n最後，小提醒 **event bus 在管理上會有些問題，能的話盡量使用在較不複雜的網頁結構上**。\n\n---\n\n## 參考資料\n[六角學院課程--Vue 出一個電商網站](https://www.hexschool.com/vue/)\n","tags":["E-commerce"],"categories":["Vue.js"]},{"title":"Vue.js 電商練習技術整理 -- 製作讀取動畫增加使用者體驗","url":"%2F2019%2F08%2F05%2FEcommercePractice6%2F","content":"\n![](https://i.imgur.com/el9rgW2.jpg)\n\n## 文章目的\n我們時常在逛其他網站時，讀取過程中會看到一些動畫呈現，此文章用來記錄在用 Vue 開發網站時，如何製作同樣的動畫效果。\n<!--more-->\n\n## 方法簡介\n1. 套用 vue-loading-overlay 套件達到效果 --- [vue-loading-overlay官方文件](https://www.npmjs.com/package/vue-loading-overlay)\n2. 利用 FontAwesome 提供的 loading 圖案達到效果 ---[FontAwesome Loading](https://fontawesome.com/how-to-use/on-the-web/styling/animating-icons)\n\n## vue-loading-overlay\n這是一個 vue 的套件，透過安裝此套件我們可以輕易地呈現 loading 效果。\n### vue-loading-overlay 安裝\n這邊我們透過 npm 的方式來安裝此套件\n`npm install vue-loading-overlay --save`\n\n透過此套件的官方文件，我們可以得知它有兩種使用方式：\n1. 透過 Component 方式載入。\n2. 透過 Plugin 方式載入。\n本次範例將以 Component 方式載入做講解。\n\n### vue-loading-overlay 載入\n我們先來到 Vue Cli 的進入點(main.js)，import 以下兩支檔案：\n```js\nimport Loading from 'vue-loading-overlay' //component\nimport 'vue-loading-overlay/dist/vue-loading.css' //style\n```\n利用 component 方法做載入：\n```js\nVue.component('Loading', Loading)\n```\n進行到這裡，我們已完成全域的 loading 設定，接下來就可以在需要 loading 的頁面上做載入。\n\n### 載入 loading 特效\n將此 loading 模板放入元件最外層的 div 底下(**這樣才能將效果套用到整個元件頁面上，若只需要部份做套用可以僅放在需套用的區塊內即可。**)，程式碼如下：\n```html\n<div>\n    <loading :active.sync=\"isLoading\"></loading>\n</div>\n```\n這是最基本的模板，`isLoading`負責控制效果是否出現，**若要自訂效果或是增加一些控制屬性，可參考[這篇文章](https://ithelp.ithome.com.tw/articles/10209705)**\n進行到這裡我們的頁面已會正確的出現效果，那如果要控制出現在效果的時機，我們可以透過 `isLoading` 的操作來控制。\n\n### 控制 loading 出現時機\n以範例來講，我們可以先在 data 的部分宣告我們的變數 `isLoading = false`，讓 loading 效果一開始是隱藏的，當 ajax 執行時觸發 loading 效果，並在 ajax 成功時，結束 loading 效果，程式碼如下：\n```js\nexport default {\n  data () {\n    return {\n      products: [],\n      isLoading: false\n    }\n  },\n  methods: {\n    getProducts () {\n      const api = `你的 api 路徑`\n      const vm = this\n      vm.isLoading = true //正在執行 ajax 時 isLoading = true 觸發效果\n      this.$http.get(api).then(response => {\n        console.log(response.data)\n        vm.isLoading = false //ajax結束時，isLoading = false 結束效果\n        vm.products = response.data.products\n      })\n    },\n```\n## FontAwesome 載入動畫效果\n### 將 FontAwesome 引用置專案中\n有兩種方法可以將FontAwesome引用：\n1. cdn 方式\n2. npm 安裝\ncdn 方式這邊就不多加說明，我們來稍微解釋一下如何透過 npm 載入。\n我們先在終端機上輸入以下指令：\n`npm install --save-dev @fortawesome/fontawesome-free`\n待安裝完畢我們會在 node_modules 資料夾底下看到 **@fortawesome**，這代表安裝完成。\n接著我們要載入它，先來到需要使用的元件下將下列程式碼加入該元件的 `style` 裡。\n```css\n<style>\n  @import url(\"@fortawesome/fontawesome-free/css/all.css\");\n</style>\n```\n### 使用 FontAwesome 動畫 icons\nFontAwesome 官網中的文件有提到一種 Animating icons，只要加入此 icon 就會有動畫載入的效果 --- [Animating icons](https://fontawesome.com/how-to-use/on-the-web/styling/animating-icons)。\n當然我們也可以控制 icons 的出現時機，方法和 vue-loading-overlay 相似，只是這邊我們是用 v-if 的方式來做，以下是程式碼：\n```html\n<i class=\"fas fa-spinner fa-spin\" v-if=\"status.fileUploading\"></i>\n```\n我們在 data 內宣告一個變數負責判斷 icons 的出現。\n```js\nexport default {\n  data () {\n    return {\n      status: {\n        fileUploading: false\n      }\n    }\n  }\n```\n最後一樣的可以根據事件的觸發來改變 `this.status.fileUploading` 的布林數，進而觸發 icons 的顯示與隱藏。\n**最後有一點要補充，還是會建議 FontAwesome 載入效果主要用在局部，若要全局效果還是會建議使用 vue-loading-overlay**\n\n## FontAwesome 打包時注意!!\n**因為 FontAwesome 打包後容量較大，若不修改容量限制會導致 FontAwesome 無法一起被打包。**\n因此我們需要對設定檔做修改。\n來到 build 底下的 webpack.base.conf.js 找到下列程式碼：\n```js\n{\n        test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/,\n        loader: 'url-loader',\n        options: {\n          limit: 800000, //預設是10000，這邊修改成800000\n          name: utils.assetsPath('fonts/[name].[hash:7].[ext]')\n}\n```\n修改完後，再執行 npm run build 打包動作。\n**僅限利用 npm 方式引入 FontAwesome 需做此修改，若為 cdn 方式引用不需這樣做。**\n\n---\n\n## 參考資料\n[六角學院課程--Vue 出一個電商網站](https://www.hexschool.com/vue/)\n[JB大的文章](https://ithelp.ithome.com.tw/articles/10209705)","tags":["E-commerce"],"categories":["Vue.js"]},{"title":"Vue.js 電商練習技術整理 -- 使用 FormData 上傳圖片的眉眉角角","url":"%2F2019%2F08%2F01%2FEcommercePractice5%2F","content":"\n![](https://i.imgur.com/el9rgW2.jpg)\n\n## 文章目的\n有時候我們會需要將圖片上傳至後端做儲存，上傳時可利用 FormData 作為圖片的資料格式。\n本篇將介紹如何操作 Vue Cli 上傳圖片的細節。\n<!--more-->\n\n## FormData 簡單介紹\nFormData 是一個表單格式，我們可以利用它將資料轉成表單的格式，並且以表單的形式回傳給後端。 ---[FormData介紹](https://developer.mozilla.org/zh-TW/docs/Web/API/FormData)\n**至於上傳圖片時需不需要用 FormData 的形式上傳，是由後端來做決定。**\n\n## 將圖片轉換成 FormData \n* 首先，我們會利用 html 的 `<input type=\"file\">` 來上傳我們的圖片，我們可以為 input 新增一個 change 事件，程式碼如下：\n```html\n <input type=\"file\" @change=\"uploadFile\" ref=\"files\"/>\n```\n**這邊請務必加入 `ref='files'` 否則下個步驟我們會找不到檔案。**\n* 接著我們可以透過 `console.log` 的方式來找到我們要上傳的圖片所在位置，程式碼如下：\n```js\n uploadFile () {\n      console.log(this)\n }\n```\n經觀察後會發現圖片是以陣列的形式存在 **$refs.files.files** 下。\n* 先宣告一個變數來儲存我們找到的圖片\n```js\nconst uploadedFile = this.$refs.files.files[0] //這邊可根據需求決定是抓哪一張圖片或是整個陣列\n```\n* 進行到這裡我們就可以把圖片轉換成 FromData，先宣告一個變數是我們的 `new FormData()`，接著我們利用 `append` 的方式將我們的圖片塞入，程式碼如下：\n```js\nconst formData = new FormData()\nformData.append('資料屬性(根據後端決定)', uploadedFile)\n```\n## 接取 API 與渲染上傳的圖片\n* 已成功擁有一個 FormData，接著我們就可以把 FormData 透過 API 傳給後端，那因為是以 FormData的格式傳送，跟之前以物件的形式不同，所以我們需要更改傳遞格式，程式碼如下：\n```js\n const url = `API 路徑`\n      this.$http.post(url, formData, {\n        headers: {\n          'Content-Type': 'multipart/form-data' //更改成 FormData 的格式\n        }\n```\n* \n接著後續就可以針對成功回傳後做操作，像是範例這邊我們為了讓上傳成功的圖片能在畫面上呈現，因此我們需要將圖片的連結存在本地端，程式碼如下：\n```js\n  if (response.data.success) {\n          vm.$set(vm.tempProduct, 'imageUrl', response.data.imageUrl)\n        }\n```\n這邊有一點要注意，**因為用平常的方法`vm.tempProduct.imgUrl = response.data.imgUrl` 無法正確地將路徑儲存**，因此我們**改成用`$set` 的方式強制將路徑加入**。\n另外 html 方面就可以有一個 `img` 標籤 `src` 動態綁定我們上傳的圖片路徑。\n```html\n<img :src=\"tempProduct.imageUrl\">\n```\n最後附上完整的事件程式碼：\n```js\n   uploadFile () {\n      console.log(this)\n      const uploadedFile = this.$refs.files.files[0]\n      const vm = this\n      const formData = new FormData()\n      formData.append('資料屬性(根據後端決定)', uploadedFile)\n      const url = `上傳的 API 路徑`\n      this.$http.post(url, formData, {\n        headers: {\n          'Content-Type': 'multipart/form-data'\n        }\n      }).then((response) => {\n        if (response.data.success) {\n          vm.$set(vm.tempProduct, 'imageUrl', response.data.imageUrl)\n        }\n      })\n    }\n```\n\n---\n\n## 參考資料\n[六角學院課程--Vue 出一個電商網站](https://www.hexschool.com/vue/)","tags":["E-commerce"],"categories":["Vue.js"]},{"title":"Vue.js 電商練習技術整理 -- 導入 Bootstrap 與 jQuery","url":"%2F2019%2F07%2F30%2FEcommercePractice4%2F","content":"\n![](https://i.imgur.com/el9rgW2.jpg)\n\n## 文章目的\n為了讓 Vue Cli 能正常使用 Bootstrap 4 的 jQuery 相關功能，本文用來記錄導入流程。\n<!--more-->\n## 本次示範\n本次要用來導入的是 Bootstrap 4 的 Modal 元件，那因為 Modal 會需要利用到 jQuery 來達到效果，因此我們需要先正確的導入 Bootstrap 4 的 js 檔案與 jQuery。---[Modal元件官方文件](https://bootstrap.hexschool.com/docs/4.2/components/modal/#modalshow)\n\n## 導入 Bootstrap 4 js 檔與 jQuery\n我們先到進入點(main.js)，將 Bootstrap 4 js 檔 `import` 進來，程式碼如下：\n```js\nimport Vue from 'vue'\nimport axios from 'axios'\nimport VueAxios from 'vue-axios'\nimport 'bootstrap'\nimport App from './App'\nimport router from './router'\n```\n**這邊要記得 `import` 的順序自定義檔案都要放在最後。**\n接著我們來到需要引用 Modal 的頁面(Vue檔)，在 `<script>` 標籤上做以下操作：\n```js\nimport $ from 'jquery' //需使用元件導入(區域)\n```\n**此為區域的引入，引入的 jQuery 僅有在該元件能使用**，若想要全域引用可以在 main.js 加入以下程式碼：\n```js\nimport 'jquery' //main.js導入(全域)\n```\n**這邊有一點要注意，若有使用 ESlint 會顯示不建議在全域導入**，因此需額外加入以下程式碼：\n```js\n/* global $ */ //main.js導入(全域)\n```\n最後，我們將 Bootstrap 4 的 Modal 元件程式碼放入需使用的 Vue 元件內即可。\n\n## 透過事件觸發顯示 Modal\n我們這邊要稍微修改一下 Modal 的啟動方式，一般來講僅需要按鈕有對應的 Modal id 就可以啟動它。\n那會要改寫成觸發事件是因為，這樣可以更靈活地顯示 Modal，如遇到需要接取 API 時可以讓 API 資料確定接收後再顯示 Modal。\n這邊我們僅改成利用點擊觸發事件，如需要其他觸發方法可再自行更改。\n* 先在要觸發事件的按鈕上增加點擊事件，程式碼如下：\n```html\n <button class=\"btn btn-primary\" @click.prevent=\"openModal\">建立新的產品</button>\n```\n* 接著建立我們的 `methods`，程式碼如下：\n```js\n methods: {\n    openModal () {\n      $('#productModal').modal('show')\n    }\n  },\n```\n有關程式碼可參考官方文件 ---[Modal show](https://bootstrap.hexschool.com/docs/4.2/components/modal/#modalshow)\n\n---\n\n## 參考資料\n[六角學院課程--Vue 出一個電商網站](https://www.hexschool.com/vue/)","tags":["E-commerce"],"categories":["Vue.js"]},{"title":"Vue.js 電商練習技術整理 -- 登入簡易路徑切換","url":"%2F2019%2F07%2F30%2FEcommercePractice3%2F","content":"\n![](https://i.imgur.com/el9rgW2.jpg)\n\n## 文章目的\n一般電商都會有登入畫面，當登入成功時會有畫面路徑的切換，本文用來記錄 Vue Cli 製作此方法流程。\n<!--more-->\n\n## 基本概念\n* 在登入頁面中透過接取後端驗證 API 來認證使用者的帳號密碼，若驗證成功就變更路徑至其他頁面。\n* 其他頁面具有登出功能，透過後端登出 API 將使用者帳號登出，並使路徑跳轉至登入前畫面。\n* 需登入才能進入的頁面，在尚未登入時不能隨意進入。\n\n## 驗證帳號 API 接取與路徑切換\n* 我們可以在 components 資料夾底下新增一個 pages 資料夾，並在裡面新增一個 Login.vue 檔。\n* 在 Login.vue 檔中切出需要的登入版型，並透過 v-model 方式將使用者輸入的帳號密碼做雙向綁定，程式碼如下：\n```js\n data () {\n    return {\n      user: {\n        username: '',\n        password: ''\n      }\n    }\n  },\n```\n**這邊 data 裡的格式，根據驗證 api 要求的格式來設定。**\n* 我們為登入的版型製作一個 submit 的事件來觸發驗證 API，事件方法如下：\n```js\n methods: {\n    signin: function () {\n      const api = `驗證的 api 網址`\n      const vm = this\n      this.$http.post(api, vm.user).then((response) => {\n        if (response.data.success === true) {\n          vm.$router.push('/')\n        }\n      })\n    }\n  }\n```\n我們利用 `post` 回傳使用者資料(user)給後端，利用判斷式判斷後端回傳成功與否來決定路徑是否切換。\n\n## 登出驗證與路徑切換\n\n現在我們要做一個簡易的登出按鈕，讓我們點擊時可以回到登入前的畫面。\n我們這邊示範就在登入後顯示的頁面上製作此按鈕。\n* 製作一顆按鈕，讓其點擊後觸發一個事件，事件為接取登出 API ，程式碼如下：\n```js\n methods: {\n    signout () {\n      const api = `驗證登出 api 網址`\n      const vm = this\n      this.$http.post(api).then((response) => {\n        console.log(response.data)\n      })\n    }\n  }\n```\n* 接著我們在事件裡新增一個判斷式，若驗證成功即回到登入前頁面，程式碼如下：\n```js\nmethods: {\n    signout () {\n      const api = `驗證登出 api 網址`\n      const vm = this\n      this.$http.post(api).then((response) => {\n        console.log(response.data)\n        if (response.data.success === true) {\n          vm.$router.push('/login')\n        }\n      })\n    }\n  }\n```\n\n## 導入導航守衛\n做到這裡登入前與登入後畫面已可正確切換，但這時會有個問題，即使使用者尚未登入，也可利用變更網址的方式，訪問登入後的頁面。\n我們這裡要介紹**利用導航守衛讓使用者無法不經過認證就訪問特定頁面**。\n**導航守衛的定義在於它會判斷我們要前往的頁面以及正要離開的頁面，如果要前往的頁面是需要認證的，它會等認證完後才開放通行 -- [導航守衛](https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%85%A8%E5%B1%80%E5%89%8D%E7%BD%AE%E5%AE%88%E5%8D%AB)**\n\n現在就來試著把剛剛完成的登入效果導入導航守衛吧。\n1. 決定我們需要認證才能進入的頁面，決定好後到 Vue.router 的配置檔(index.js)，在 routes 中找到該頁面加入`meta: { requiresAuth: true }`，讓系統知道此頁面是需要認證才能訪問(可參考[路由元訊息](https://router.vuejs.org/zh/guide/advanced/meta.html))。示範如下：\n```js\n{\n    path: '/',\n    name: 'HelloWorld',\n    component: HelloWorld,\n    meta: { requiresAuth: true }\n},\n```\n2. 來到我們的進入點(main.js)在裡面做全局的導航守衛部屬(可參考[全局守衛部屬](https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%85%A8%E5%B1%80%E5%89%8D%E7%BD%AE%E5%AE%88%E5%8D%AB))，程式碼如下：\n```js\nrouter.beforeEach((to, from, next) => {\n  if (to.meta.requiresAuth) {\n    const api = `檢視是否為登入狀態 api`\n    axios.post(api).then((response) => {\n      if (response.data.success === true) {\n        next()\n      } else {\n        next({\n            path: '/login'\n        })\n        // next(false)\n      }\n    })\n  } else {\n    next()\n  }\n})\n```\n這裡針對上方程式碼做解釋：\n* 參數解釋：\n    * `to` 代表我們將要前往的頁面\n    * `from` 代表我們將要離開的頁面\n    * `next` 決定是否前往的方法\n* 我們透過判斷式`if (to.meta.requiresAuth)`，判斷出當我們要前往的頁面是需要驗證時就接取 api，不需要則直接切換即可。\n* 這邊會發現接取 api 的程式碼有點不同，之前都是`this.$http.post(api)`，這裡變成`axios.post(api)`，原因是因為這時的環境是在 router 上，並不是像我們以往接取 api 時是在 Vue 的元件上，所以改成 `axios` 才能正常接取。\n* 第二個判斷式，用來判斷若後端 api 驗證為登入狀態就讓頁面切換，否則停留在登入前畫面，那停留畫面部分有兩種寫法，**一種是透過路徑的方式讓其重新導向登入前路徑，另一種是加入 false 中斷當前導覽並回到 from 的頁面**。\n\n## 避免使用者隨意改變網址導致跳轉到空白頁面\n若使用者在網址後面加入一些亂碼，會使頁面跳轉到空白的頁面去，為了避免這情況發生我們可以去配置檔(index.js)的 routes 加入以下程式碼：\n```js\n{\n    path: '*', //當路徑為其它不存在的路徑時\n    redirect: '/login' //重新導向此路徑(可自己定義)\n},\n```\n## 補充\n這邊要提醒一點，有些後端 API 可能會需要我們在接取 API 的同時，將後端的 Cookie 做儲存，並在最後接取 API 的同時，將 Cookie 傳至後端，才能完成 Ajax。\n那如果要儲存 Cookie 我們可以在我們的進入點(main.js)，加入 axios 提供的程式碼 `axios.defaults.withCredentials = true`。\n\n---\n\n## 參考資料\n[六角學院課程--Vue 出一個電商網站](https://www.hexschool.com/vue/)","tags":["E-commerce"],"categories":["Vue.js"]},{"title":"Vue.js 電商練習技術整理 -- 載入Bootsrap 4 套件，且自定義樣式","url":"%2F2019%2F07%2F29%2FEcommercePractice2%2F","content":"\n![](https://i.imgur.com/el9rgW2.jpg)\n\n## 文章目的\n藉由將 Bootstrap 4 套用到 Vue Cli 的專案裡，以方便後續開發 css 使用，並可將 Bootstrap 4 的預設樣式做修改，修改成專案所需樣式。\n<!--more-->\n## 載入 Bootstrap 4\n在我們的終端機或是命令提示字元， cd 到我們的專案路徑，輸入**npm install bootstrap --save**。\n安裝完成後，我們應該可以在 node_modules 資料夾底下看到 bootstrap 的資料夾。\n步驟進行到這邊，還不算完全安裝好，因為**我們並沒有支援 sass 的 loader，因此要再進行相關安裝**。\n這邊輸入**npm install node-sass sass-loader --save**，這樣子我們就完成載入 Bootstrap 囉。\n\n## 將 Bootstrap 4 套用到我們的專案上\n來到 App.vue 的 style，在標籤上加入 `lang=\"scss\"`，並在標籤內輸入 `@import '~bootstrap/scss/bootstrap'`，詳細程式碼如下：\n```scss\n<style lang=\"scss\">\n@import \"~bootstrap/scss/bootstrap\";\n</style>\n```\n\n## 自定義 Bootstrap 樣式\n若我們要自定義樣式，套用方式會跟上面有點差別。\n1. 來到 node_modules 底下的 bootstrap 資料夾，並在 scss 資料夾底下找到 _variables。\n在 assets 下新增一個 helpers 資料夾，將 _variables 另存新檔到 helpers 裡。\n2. 在 assets 資料夾下新增一個 all.scss 的檔案，在裡面載入檔案，程式碼如下：\n```scss\n@import \"~bootstrap/scss/functions\"; /*bootstrap 套用變數的方法，有它我們才能正確套用自定義變數*/\n@import \"./helpers/_variables\"; /*我們的自定義內容*/\n@import \"~bootstrap/scss/bootstrap\"; /*bootstrap 主套件*/\n```\n**這邊要注意一點在載入時3個的順序要如上方所示，此為 bootstrap 官方規定。**-- [規定內容](https://bootstrap.hexschool.com/docs/4.1/getting-started/theming/#importing)\n3. App.vue 的 style 載入方式也要做修改，程式碼如下：\n```scss\n<style lang=\"scss\">\n@import './assets/all' /*改成載入我們新建的all.scss*/\n</style>\n```\n4. 自定義示範\n載入完成後，我們就能來自定義自己要的樣式。\n打開我們另存的 _variables.scss，我們可以為裡面的變數做修改。\n像是 Bootstrap 4 預設 primary 顏色為藍色，這裡透過改變變數將其顏色改變，程式碼如下：\n```scss\n$theme-colors: map-merge(\n  (\n    \"primary\":    $purple, /*預設為$primary*/\n    \"secondary\":  $secondary,\n    \"success\":    $success,\n    \"info\":       $info,\n    \"warning\":    $warning,\n    \"danger\":     $danger,\n    \"light\":      $light,\n    \"dark\":       $dark\n  ),\n  $theme-colors\n); \n```\n我們只要套用相關 bootstrap 元件或是 className 就會發現 primary 變成紫色。\n這就是一個自定義內容的簡單範例。\n\n---\n\n## 參考資料\n[六角學院課程--Vue 出一個電商網站](https://www.hexschool.com/vue/)","tags":["E-commerce"],"categories":["Vue.js"]},{"title":"Vue.js 電商練習技術整理 -- 接取API與設定環境變數","url":"%2F2019%2F07%2F29%2FEcommercePractice1%2F","content":"\n![](https://i.imgur.com/el9rgW2.jpg)\n\n## 文章目的\n最近開始利用 Vue.js 實戰練習電商網站的開發，想藉由一系列的文章，來整理相關的重點技術。\n本篇重點為利用 Vue Cli 接取 API 並且將 API 設定為環境變數。\n<!--more-->\n## 環境檔案介紹\n一般來講，安裝完 Vue Cli 後，打開 config 資料夾，會看到裡面有3個環境設定檔。\n分別是：\n * index.js -- 針對整個環境進行編譯\n * dev.env.js -- 開發中的環境變數\n * prod.env.js -- 正式的環境變數\n\n那為什麼要特別分成開發中與正式版本呢？\n因為往往在**開發時接取的 API 路徑會與 正式版本不同**，因此我們可以透過兩個檔案分開各自定義環境變數，以方便操作。\n\n## Vue axios 安裝\n既然我們本次的重點是要接取 API，這邊提供一個接取 API 的套件 --- [Vue axios](https://www.npmjs.com/package/vue-axios)\n安裝與設置方面這邊就不多加敘述，連結的官方文件上都有說明。\n\n## 接取 API \n有了 Vue axios 後我們就可以開始接取 API。\n我們來到 App.vue，設定 created 時將 API 資料抓進來，程式碼如下：\n```js\n<script>\nexport default {\n  name: 'App',\n  created () {\n    const api = '輸入你的API網址'\n    this.$http.get(api).then((response) => {\n      console.log(response.data)\n    })\n  }\n}\n</script>\n```\n## 將 API 網址設定成環境變數\n用了上述方法接取 API 我們無法靈活的運用它，且無法讓它在開發環境與正式環境做區分。\n因此現在**我們要將 API 網址設定成環境變數，並透過呼叫變數來使用它**(本次範例設定在開發環境)。\n1. 我們來到 config 資料夾底下的 dev.env.js，宣告新的環境變數定義我們的 API 路徑，以下是程式碼：\n```js\nmodule.exports = merge(prodEnv, {\n  NODE_ENV: '\"development\"',\n  APIPATH: '\"你的 API 路徑\"',  //變數名稱可自己定義，一般來說都是用大寫英文命名\n})\n```\n**這邊有一點要注意，宣告的變數在插入路徑時，記得要再用一次引號包覆路徑。**\n2. 定義完環境變數後，我們回到 App.vue，將我們剛剛的路徑改成用環境變數，程式碼如下：\n```js\n<script>\nexport default {\n  name: 'App',\n  created () {\n    const api = `${process.env.APIPATH}`\n    this.$http.get(api).then((response) => {\n      console.log(response.data)\n    })\n  }\n}\n</script>\n```\n呼叫環境變數的方法：`process.env.環境變數`。\n\n---\n\n## 參考資料\n[六角學院課程--Vue 出一個電商網站](https://www.hexschool.com/vue/)","tags":["E-commerce"],"categories":["Vue.js"]},{"title":"The F2E Freecell Part 1","url":"%2F2019%2F07%2F25%2Ffreecell%2F","content":"\n![](https://i.imgur.com/ENE1GPj.png)\n\n## 文章目的\n有鑑於本周 THE F2E 的新接龍有許多邏輯方面的設計，想藉由本篇將開發邏輯記錄下來，另外也想嘗試發布部落格，因此將本篇當作第一篇文章。\n<!--more-->\n## 本次使用技術\n1. Bootsrap 4 \n2. Scss\n3. JavaScript 原生語法\n原本是想用 Vue 開發，後來覺得應該用原生語法也不致於太難，但做到一半就開始後悔怎麼沒有 Vue (因為方便好多XD)。\n這次使用原生語法就當作加強自己的觀念，也很感謝有**懷恩老師的直播開發流程**(文章最後會附上連結)，沒有老師的直播我應該會卡關到懷疑人生。\n\n## 新接龍初步分析\n新接龍規則部分我們這邊就不多加解釋，附上 [遊戲規則](https://zh.wikipedia.org/zh-tw/%E6%96%B0%E6%8E%A5%E9%BE%8D)。\n新接龍總共分為3塊遊戲區，分別是：\n1. 完成區(左上角，共4格)\n  * 只能同花色堆疊\n  * 數字要由小到大按順序堆疊\n  * 堆疊完成的牌不需要再被拖曳\n2. 暫存區(右上角，共4格)\n  * 每個空格只能存放一張卡片\n  * 空格裡的卡片可以再被拖曳至完成區或未整理區\n3. 未整理區(下方，共7排，左4排初始7張，右4排初始6張)\n  * 只能異色堆疊\n  * 數字要由小到大按順序堆疊\n  * 空排要能放牌且不限數字\n  * 此區卡片可以被拖曳至暫存區與完成區\n\n有了這樣初步的了解，我們可以開始來了解 JS 的語法。\n切版部分本文章不會提到，我是利用 Bootstrap 4 和一些 SCSS 來完成切版。\n\n## 變數宣告與各區域陣列分配\n首先，宣告一個變數來決定遊戲是否暫停，後續的一些功能處裡，暫停遊戲都會影響到，以下是程式碼：\n```js\nlet isgamePause = false;\n```\n我們可以將完成區看成一個區域，暫存區看成一個區域，未整理區看成一個區域，因此這裡變數可以這樣設計：\n```js\n    let finishArea = [[], [], [], []]; //完成區域左上角\n    \n    let temporaryArea = [[], [], [], []]; //卡片暫放區(每一格只能放一張)右上角\n    \n    let maingameArea = [ //未整理區共8排\n        [], //7張\n        [], //7張\n        [], //7張\n        [], //7張\n        [], //6張\n        [], //6張\n        [], //6張\n        [] //6張\n    ];\n```\n每個大區域就是一個陣列，每個大區域裡的每一個空格就是一個陣列。\n另外因為我是用 Bootstrap 4 的格線系統做排版，我為了方便設計，將未整理區又分為左右7張與6張兩區，變數宣告如下：\n```js\nlet cardbigGroup = [[], []];\n```\n\n## 隨機發牌\n接下來我們來設計隨機發牌，讓系統可以在遊戲開始時隨機發牌到未整理區的陣列裡，而且按照7張、6張的規則排列。\n* 撲克牌總共有52張，因此我們就用1\\~52的數字當作我們的牌，這裡我們宣告一個陣列將1\\~52的數字儲存進去。\n```js\n//利用 for 迴圈\n let pokerArr = []; \n    for (let i = 0; i < 52; i++) {\n        pokerArr.push(i + 1)\n    }\n\n//利用 Array.from 和 Array.map\nlet pokerArr =Array.from(new Array(52)).map(function(item,index){ \n    return index+1 \n})\n```\n* 接著要**將陣列的52個數字打亂**，這邊我用的方法是 shuffle，有關 shuffle 相關介紹可參考[**這篇**](http://shubo.io/javascript-random-shuffle/)，以下是程式碼。\n```js\n function shuffle(array) {\n        for (let i = array.length - 1; i > 0; i--) {\n            let j = Math.floor(Math.random() * (i + 1));\n            [array[i], array[j]] = [array[j], array[i]];\n        }\n        return array;\n    }\n\nlet pokerRandom = shuffle(pokerArr);\n```\n* 我們已成功打亂數字，接著就是要**將數字按照規則排列**，我們一開始宣告的`maingameArea`就派上用場了，我們可以按照規則將數字一一塞入`maingameArea`的陣列裡，以下是程式碼。\n```js\n function mainpokerArr() {\n        let randomarrNum = Math.floor(Math.random() * 8);\n        if (randomarrNum <= 3) {\n            if (maingameArea[randomarrNum].length >= 7) {\n                return mainpokerArr()\n            }\n        } else {\n            if (maingameArea[randomarrNum].length >= 6) {\n                return mainpokerArr()\n            }\n        }\n        return randomarrNum;\n    }\n```\n這段程式碼的想法是因為`maingameArea`總共有8個陣列，從左到右的索引號是0\\~7，因此我們利用`randomarrNum`來隨機選出一個索引號。\n透過判斷式讓索引號為0\\~3時陣列長度維持為7張，索引號為4\\~7時長度維持為6張。\n現在我們有了符合規則的發牌方法，接下來就要將牌一一放進陣列裡，以下是程式碼。\n```js\n pokerRandom.map(function (item) {\n        let runmainpokerArr = mainpokerArr();\n        maingameArea[runmainpokerArr].push(item);\n    });\n```\n這裡讓未整理區`maingameArea`透過我們剛剛設計的發牌函式`mainpokerArr()`將我們剛打亂的陣列`pokerRandom`裡的數字放入未整理區的8個陣列裡。\n這邊因為我自己的設計關係，我再把`maingameArea`裡的8個陣列，分為4個一組放入更大的陣列`cardbigGroup`，以下是程式碼。\n```js\n maingameArea.forEach(function (item, index) {\n        if (index <= 3) {\n            cardbigGroup[0].push(item);\n        } else {\n            cardbigGroup[1].push(item)\n        };\n    });\n```\n\n* 隨機發牌的資料都按照規則整理完畢了，我們接下來要做的就是**讓牌可以渲染到畫面上**。\n首先，因為我們的數字是1\\~52，但系統並不知道花色，因此我們要先來定義花色，以下是程式碼。\n```js\n function judgeColor(cardNum) {\n        if (cardNum >= 1 && cardNum <= 13) {  //1~13是黑桃\n            return 'spade'\n        } else if (cardNum >= 14 && cardNum <= 26) { //14~26是紅心\n            return 'heart'\n        } else if (cardNum >= 27 && cardNum <= 39) { //27~39是方塊\n            return 'diamond'\n        } else if (cardNum >= 40 && cardNum <= 52) { //40~52是梅花\n            return 'club'\n        }\n    };\n```\n花色也定義完成後，我們就要正式選渲染畫面，因為是原生語法關係，我們利用 `createElement` 和 `appendChild` 來做渲染，因為程式碼較多，先來看看完整程式碼，我再根據每個部份做解釋。\n```js\n    let gamingArea = document.getElementById('gamingArea');\n   function putCard() {\n        cardbigGroup.forEach(function (section, sectionNum) {\n            let cardbiggroupPart = document.createElement('div');\n            cardbiggroupPart.className = 'col-6 d-flex w-100';\n            gamingArea.appendChild(cardbiggroupPart);\n            section.forEach(function (item, index) {\n                let cardGroup = document.createElement('div');\n                cardGroup.className = 'relative w-100';\n                cardGroup.style.height = '600px'\n                cardGroup.group = index;\n                cardGroup.section = sectionNum;\n                cardbiggroupPart.appendChild(cardGroup)\n                item.forEach(function (el, num) {\n                    let oneCard = document.createElement('div');\n                    oneCard.className = 'cardArea absolute';\n                    if (!isRefresh) {\n                        oneCard.style.transition = 'all .3s'\n                        oneCard.style.top = '-1000px';\n                        oneCard.style.left = '-2000px';\n                        setTimeout(function () {\n                            oneCard.style.top = num * 30 + 'px';\n                            oneCard.style.left = '0px'\n                        }, index * num * 30)\n                    } else {\n                        oneCard.style.top = num * 30 + 'px';\n                        oneCard.style.left = '0px'\n                    }\n                    let cardImg = document.createElement('img');\n                    cardImg.draggable = false\n                    cardImg.card = el;\n                    cardImg.section = sectionNum;\n                    cardImg.group = index;\n                    cardImg.color = judgeColor(el)\n                    cardImg.src = `pokerimg/card-${judgeColor(el)}-${el % 13}.svg`;\n                    if (!isgamePause && num + 1 == item.length) {\n                        oneCard.draggable = true;\n                        cardImg.draggable = true\n                    }\n                    oneCard.appendChild(cardImg)\n                    cardGroup.appendChild(oneCard);\n                })\n               \n            })\n        });\n\n    };\n```\n```js\n let gamingArea = document.getElementById('gamingArea');\n   function putCard() {\n        cardbigGroup.forEach(function (section, sectionNum) {\n            let cardbiggroupPart = document.createElement('div');\n            cardbiggroupPart.className = 'col-6 d-flex w-100';\n            gamingArea.appendChild(cardbiggroupPart);\n```\n我利用 `getElementById`選取要做為未整理區最外層的 HTML 元素。\n宣告一個函式負責執行隨機發牌，接著我要一層一層的剝開我們的陣列往內進逼針對陣列裡的元素做設定。\n第一個陣列就是分為左右兩大區塊的`cardbigGroup`，讓兩塊區域都`createElement`區塊元素(`div`)出來，那因為我有使用格線來排版，所以為他們加了一些排版相關的`className`。\n接著就可以利用`appendChild`將我們創造出來的兩個區塊元素加入到`gamingArea`下方。\n```js\n  section.forEach(function (item, index) {\n                let cardGroup = document.createElement('div');\n                cardGroup.className = 'relative w-100';\n                cardGroup.style.height = '600px'\n                cardGroup.group = index;\n                cardGroup.section = sectionNum;\n                cardbiggroupPart.appendChild(cardGroup)\n```\n第二個碰到的陣列是各區底下的4塊小區域(7張牌與6張牌)，原理一樣我們為每塊區域創造區塊元素，並將入一些自定義的`className`和`style`。\n這邊比較重要的一點是**為每個區塊元素增加一些屬性來記錄它所在的位置(`group`,`section`)**，這些屬性將會在後面我們要製作拖曳效果時會用到。\n```js\n item.forEach(function (el, num) {\n                    let oneCard = document.createElement('div');\n                    oneCard.className = 'cardArea absolute';\n                    if (!isRefresh) {\n                        oneCard.style.transition = 'all .3s'\n                        oneCard.style.top = '-1000px';\n                        oneCard.style.left = '-2000px';\n                        setTimeout(function () {\n                            oneCard.style.top = num * 30 + 'px';\n                            oneCard.style.left = '0px'\n                        }, index * num * 30)\n                    } else {\n                        oneCard.style.top = num * 30 + 'px';\n                        oneCard.style.left = '0px'\n                    }\n```\n最後我們碰到的就是我們的主角--**撲克牌**，這邊一樣是為每張牌創建區塊元素，那因為我採用的設計稿是 **吳俊儀設計師的設計稿**，俊儀設計師很佛心的把每張牌做成svg，所以我待會只要把每張svg `appendChild`到每張牌的`div`底下就好。\n至於判斷式的部分，是設計遊戲開始時的卡片出現動畫，這邊我就不多加敘述，卡片排版方式是利用絕對定位，那`position:relative`的部分我是設定給上一層的8個小區塊。\n```js\n  let cardImg = document.createElement('img');\n                    cardImg.draggable = false\n                    cardImg.card = el;\n                    cardImg.section = sectionNum;\n                    cardImg.group = index;\n                    cardImg.color = judgeColor(el)\n                    cardImg.src = `pokerimg/card-${judgeColor(el)}-${el % 13}.svg`;\n                    if (!isgamePause && num + 1 == item.length) {\n                        oneCard.draggable = true;\n                        cardImg.draggable = true\n                    }\n                    oneCard.appendChild(cardImg)\n                    cardGroup.appendChild(oneCard);\n                })\n```\n這邊我們就來處理圖片的部分，為每個數字創造`img`標籤，`src`的部分我們可以透過命名與判斷顏色的函式(`judgeColor`)，來取得符合該數字的圖片。\n一樣的，我們玩遊戲時都會拖曳這些卡片，因此也在這為它新增一些屬性(**`card`,`section`,`group`,`color`**)，分別是**數字、所在的大區塊、所在的小區塊、花色**。\n另外一樣重要的就是**`draggable`，設定它`true`or`false`會決定該元素是否能拖曳**，那因為**遊戲規則只有最後一張牌可以拖曳**，因此額外增加判斷式來判斷該張卡片是否為最後一張牌。\n最後一樣`appendChild`至上一層元素中。\n\n## 結語\n恭喜你!! 做到這裡，你的新接龍已經可以隨機發牌並且渲染到畫面上了。\n也謝謝你，看完我的文章!! 這是我第一次用 hexo 建立部落格與寫文章，排版可能還有點拙劣，傷眼抱歉。\n有關後續的完成區、暫存區與拖曳效果，我會再利用時間補上。\n\n附上我的 [DEMO](https://hao1229.github.io/THE-F2E-Freecell/) 與 [程式碼](https://github.com/Hao1229/THE-F2E-Freecell)\n\n---\n\n## 參考資料\n[懷恩老師的開發直播](https://www.facebook.com/groups/173311386703334/permalink/364591804241957/)\n\n[shuffle 文章](http://shubo.io/javascript-random-shuffle/)\n\n[Ray大的新接龍文章](https://hsiangfeng.github.io/javascript/20190712/1140639545/?fbclid=IwAR37Iq2qAZjR5wMVfSOT_jMIidxlTGRElm3ATu0zm8Hmp9iwWd61uGRz_z)\n\n[吳俊儀設計師的設計稿](https://xd.adobe.com/spec/f01f6d09-be4f-4bf3-601d-7c817fe225ab-862e/grid)\n\n","tags":["THE F2E"],"categories":["JavaScript"]}]