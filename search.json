[{"title":"The F2E Freecell Part 1","url":"%2F2019%2F07%2F25%2Ffreecell%2F","content":"\n![](https://i.imgur.com/ENE1GPj.png)\n\n## 文章目的\n有鑑於本周 THE F2E 的新接龍有許多邏輯方面的設計，想藉由本篇將開發邏輯記錄下來，另外也想嘗試發布部落格，因此將本篇當作第一篇文章。\n<!--more-->\n## 本次使用技術\n1. Bootsrap 4 \n2. Scss\n3. JavaScript 原生語法\n原本是想用 Vue 開發，後來覺得應該用原生語法也不致於太難，但做到一半就開始後悔怎麼沒有 Vue (因為方便好多XD)。\n這次使用原生語法就當作加強自己的觀念，也很感謝有**懷恩老師的直播開發流程**(文章最後會附上連結)，沒有老師的直播我應該會卡關到懷疑人生。\n\n## 新接龍初步分析\n新接龍規則部分我們這邊就不多加解釋，附上 [遊戲規則](https://zh.wikipedia.org/zh-tw/%E6%96%B0%E6%8E%A5%E9%BE%8D)。\n新接龍總共分為3塊遊戲區，分別是：\n1. 完成區(左上角，共4格)\n  * 只能同花色堆疊\n  * 數字要由小到大按順序堆疊\n  * 堆疊完成的牌不需要再被拖曳\n2. 暫存區(右上角，共4格)\n  * 每個空格只能存放一張卡片\n  * 空格裡的卡片可以再被拖曳至完成區或未整理區\n3. 未整理區(下方，共7排，左4排初始7張，右4排初始6張)\n  * 只能異色堆疊\n  * 數字要由小到大按順序堆疊\n  * 空排要能放牌且不限數字\n  * 此區卡片可以被拖曳至暫存區與完成區\n\n有了這樣初步的了解，我們可以開始來了解 JS 的語法。\n切版部分本文章不會提到，我是利用 Bootstrap 4 和一些 SCSS 來完成切版。\n\n## 變數宣告與各區域陣列分配\n首先，宣告一個變數來決定遊戲是否暫停，後續的一些功能處裡，暫停遊戲都會影響到，以下是程式碼：\n```js\nlet isgamePause = false;\n```\n我們可以將完成區看成一個區域，暫存區看成一個區域，未整理區看成一個區域，因此這裡變數可以這樣設計：\n```js\n    let finishArea = [[], [], [], []]; //完成區域左上角\n    \n    let temporaryArea = [[], [], [], []]; //卡片暫放區(每一格只能放一張)右上角\n    \n    let maingameArea = [ //未整理區共8排\n        [], //7張\n        [], //7張\n        [], //7張\n        [], //7張\n        [], //6張\n        [], //6張\n        [], //6張\n        [] //6張\n    ];\n```\n每個大區域就是一個陣列，每個大區域裡的每一個空格就是一個陣列。\n另外因為我是用 Bootstrap 4 的格線系統做排版，我為了方便設計，將未整理區又分為左右7張與6張兩區，變數宣告如下：\n```js\nlet cardbigGroup = [[], []];\n```\n\n## 隨機發牌\n接下來我們來設計隨機發牌，讓系統可以在遊戲開始時隨機發牌到未整理區的陣列裡，而且按照7張、6張的規則排列。\n* 撲克牌總共有52張，因此我們就用1\\~52的數字當作我們的牌，這裡我們宣告一個陣列將1\\~52的數字儲存進去。\n```js\n//利用 for 迴圈\n let pokerArr = []; \n    for (let i = 0; i < 52; i++) {\n        pokerArr.push(i + 1)\n    }\n\n//利用 Array.from 和 Array.map\nlet pokerArr =Array.from(new Array(52)).map(function(item,index){ \n    return index+1 \n})\n```\n* 接著要**將陣列的52個數字打亂**，這邊我用的方法是 shuffle，有關 shuffle 相關介紹可參考[**這篇**](http://shubo.io/javascript-random-shuffle/)，以下是程式碼。\n```js\n function shuffle(array) {\n        for (let i = array.length - 1; i > 0; i--) {\n            let j = Math.floor(Math.random() * (i + 1));\n            [array[i], array[j]] = [array[j], array[i]];\n        }\n        return array;\n    }\n\nlet pokerRandom = shuffle(pokerArr);\n```\n* 我們已成功打亂數字，接著就是要**將數字按照規則排列**，我們一開始宣告的`maingameArea`就派上用場了，我們可以按照規則將數字一一塞入`maingameArea`的陣列裡，以下是程式碼。\n```js\n function mainpokerArr() {\n        let randomarrNum = Math.floor(Math.random() * 8);\n        if (randomarrNum <= 3) {\n            if (maingameArea[randomarrNum].length >= 7) {\n                return mainpokerArr()\n            }\n        } else {\n            if (maingameArea[randomarrNum].length >= 6) {\n                return mainpokerArr()\n            }\n        }\n        return randomarrNum;\n    }\n```\n這段程式碼的想法是因為`maingameArea`總共有8個陣列，從左到右的索引號是0\\~7，因此我們利用`randomarrNum`來隨機選出一個索引號。\n透過判斷式讓索引號為0\\~3時陣列長度維持為7張，索引號為4\\~7時長度維持為6張。\n現在我們有了符合規則的發牌方法，接下來就要將牌一一放進陣列裡，以下是程式碼。\n```js\n pokerRandom.map(function (item) {\n        let runmainpokerArr = mainpokerArr();\n        maingameArea[runmainpokerArr].push(item);\n    });\n```\n這裡讓未整理區`maingameArea`透過我們剛剛設計的發牌函式`mainpokerArr()`將我們剛打亂的陣列`pokerRandom`裡的數字放入未整理區的8個陣列裡。\n這邊因為我自己的設計關係，我再把`maingameArea`裡的8個陣列，分為4個一組放入更大的陣列`cardbigGroup`，以下是程式碼。\n```js\n maingameArea.forEach(function (item, index) {\n        if (index <= 3) {\n            cardbigGroup[0].push(item);\n        } else {\n            cardbigGroup[1].push(item)\n        };\n    });\n```\n\n* 隨機發牌的資料都按照規則整理完畢了，我們接下來要做的就是**讓牌可以渲染到畫面上**。\n首先，因為我們的數字是1\\~52，但系統並不知道花色，因此我們要先來定義花色，以下是程式碼。\n```js\n function judgeColor(cardNum) {\n        if (cardNum >= 1 && cardNum <= 13) {  //1~13是黑桃\n            return 'spade'\n        } else if (cardNum >= 14 && cardNum <= 26) { //14~26是紅心\n            return 'heart'\n        } else if (cardNum >= 27 && cardNum <= 39) { //27~39是方塊\n            return 'diamond'\n        } else if (cardNum >= 40 && cardNum <= 52) { //40~52是梅花\n            return 'club'\n        }\n    };\n```\n花色也定義完成後，我們就要正式選渲染畫面，因為是原生語法關係，我們利用 `createElement` 和 `appendChild` 來做渲染，因為程式碼較多，先來看看完整程式碼，我再根據每個部份做解釋。\n```js\n    let gamingArea = document.getElementById('gamingArea');\n   function putCard() {\n        cardbigGroup.forEach(function (section, sectionNum) {\n            let cardbiggroupPart = document.createElement('div');\n            cardbiggroupPart.className = 'col-6 d-flex w-100';\n            gamingArea.appendChild(cardbiggroupPart);\n            section.forEach(function (item, index) {\n                let cardGroup = document.createElement('div');\n                cardGroup.className = 'relative w-100';\n                cardGroup.style.height = '600px'\n                cardGroup.group = index;\n                cardGroup.section = sectionNum;\n                cardbiggroupPart.appendChild(cardGroup)\n                item.forEach(function (el, num) {\n                    let oneCard = document.createElement('div');\n                    oneCard.className = 'cardArea absolute';\n                    if (!isRefresh) {\n                        oneCard.style.transition = 'all .3s'\n                        oneCard.style.top = '-1000px';\n                        oneCard.style.left = '-2000px';\n                        setTimeout(function () {\n                            oneCard.style.top = num * 30 + 'px';\n                            oneCard.style.left = '0px'\n                        }, index * num * 30)\n                    } else {\n                        oneCard.style.top = num * 30 + 'px';\n                        oneCard.style.left = '0px'\n                    }\n                    let cardImg = document.createElement('img');\n                    cardImg.draggable = false\n                    cardImg.card = el;\n                    cardImg.section = sectionNum;\n                    cardImg.group = index;\n                    cardImg.color = judgeColor(el)\n                    cardImg.src = `pokerimg/card-${judgeColor(el)}-${el % 13}.svg`;\n                    if (!isgamePause && num + 1 == item.length) {\n                        oneCard.draggable = true;\n                        cardImg.draggable = true\n                    }\n                    oneCard.appendChild(cardImg)\n                    cardGroup.appendChild(oneCard);\n                })\n               \n            })\n        });\n\n    };\n```\n```js\n let gamingArea = document.getElementById('gamingArea');\n   function putCard() {\n        cardbigGroup.forEach(function (section, sectionNum) {\n            let cardbiggroupPart = document.createElement('div');\n            cardbiggroupPart.className = 'col-6 d-flex w-100';\n            gamingArea.appendChild(cardbiggroupPart);\n```\n我利用 `getElementById`選取要做為未整理區最外層的 HTML 元素。\n宣告一個函式負責執行隨機發牌，接著我要一層一層的剝開我們的陣列往內進逼針對陣列裡的元素做設定。\n第一個陣列就是分為左右兩大區塊的`cardbigGroup`，讓兩塊區域都`createElement`區塊元素(`div`)出來，那因為我有使用格線來排版，所以為他們加了一些排版相關的`className`。\n接著就可以利用`appendChild`將我們創造出來的兩個區塊元素加入到`gamingArea`下方。\n```js\n  section.forEach(function (item, index) {\n                let cardGroup = document.createElement('div');\n                cardGroup.className = 'relative w-100';\n                cardGroup.style.height = '600px'\n                cardGroup.group = index;\n                cardGroup.section = sectionNum;\n                cardbiggroupPart.appendChild(cardGroup)\n```\n第二個碰到的陣列是各區底下的4塊小區域(7張牌與6張牌)，原理一樣我們為每塊區域創造區塊元素，並將入一些自定義的`className`和`style`。\n這邊比較重要的一點是**為每個區塊元素增加一些屬性來記錄它所在的位置(`group`,`section`)**，這些屬性將會在後面我們要製作拖曳效果時會用到。\n```js\n item.forEach(function (el, num) {\n                    let oneCard = document.createElement('div');\n                    oneCard.className = 'cardArea absolute';\n                    if (!isRefresh) {\n                        oneCard.style.transition = 'all .3s'\n                        oneCard.style.top = '-1000px';\n                        oneCard.style.left = '-2000px';\n                        setTimeout(function () {\n                            oneCard.style.top = num * 30 + 'px';\n                            oneCard.style.left = '0px'\n                        }, index * num * 30)\n                    } else {\n                        oneCard.style.top = num * 30 + 'px';\n                        oneCard.style.left = '0px'\n                    }\n```\n最後我們碰到的就是我們的主角--**撲克牌**，這邊一樣是為每張牌創建區塊元素，那因為我採用的設計稿是 **吳俊儀設計師的設計稿**，俊儀設計師很佛心的把每張牌做成svg，所以我待會只要把每張svg `appendChild`到每張牌的`div`底下就好。\n至於判斷式的部分，是設計遊戲開始時的卡片出現動畫，這邊我就不多加敘述，卡片排版方式是利用絕對定位，那`position:relative`的部分我是設定給上一層的8個小區塊。\n```js\n  let cardImg = document.createElement('img');\n                    cardImg.draggable = false\n                    cardImg.card = el;\n                    cardImg.section = sectionNum;\n                    cardImg.group = index;\n                    cardImg.color = judgeColor(el)\n                    cardImg.src = `pokerimg/card-${judgeColor(el)}-${el % 13}.svg`;\n                    if (!isgamePause && num + 1 == item.length) {\n                        oneCard.draggable = true;\n                        cardImg.draggable = true\n                    }\n                    oneCard.appendChild(cardImg)\n                    cardGroup.appendChild(oneCard);\n                })\n```\n這邊我們就來處理圖片的部分，為每個數字創造`img`標籤，`src`的部分我們可以透過命名與判斷顏色的函式(`judgeColor`)，來取得符合該數字的圖片。\n一樣的，我們玩遊戲時都會拖曳這些卡片，因此也在這為它新增一些屬性(**`card`,`section`,`group`,`color`**)，分別是**數字、所在的大區塊、所在的小區塊、花色**。\n另外一樣重要的就是**`draggable`，設定它`true`or`false`會決定該元素是否能拖曳**，那因為**遊戲規則只有最後一張牌可以拖曳**，因此額外增加判斷式來判斷該張卡片是否為最後一張牌。\n最後一樣`appendChild`至上一層元素中。\n\n## 結語\n恭喜你!! 做到這裡，你的新接龍已經可以隨機發牌並且渲染到畫面上了。\n也謝謝你，看完我的文章!! 這是我第一次用 hexo 建立部落格與寫文章，排版可能還有點拙劣，傷眼抱歉。\n有關後續的完成區、暫存區與拖曳效果，我會再利用時間補上。\n\n附上我的 [DEMO](https://hao1229.github.io/THE-F2E-Freecell/) 與 [程式碼](https://github.com/Hao1229/THE-F2E-Freecell)\n\n---\n\n## 資料參考\n[懷恩老師的開發直播](https://www.facebook.com/groups/173311386703334/permalink/364591804241957/)\n\n[shuffle 文章](http://shubo.io/javascript-random-shuffle/)\n\n[Ray大的新接龍文章](https://hsiangfeng.github.io/javascript/20190712/1140639545/?fbclid=IwAR37Iq2qAZjR5wMVfSOT_jMIidxlTGRElm3ATu0zm8Hmp9iwWd61uGRz_z)\n\n[吳俊儀設計師的設計稿](https://xd.adobe.com/spec/f01f6d09-be4f-4bf3-601d-7c817fe225ab-862e/grid)\n\n","tags":["THE F2E"],"categories":["JavaScript"]}]