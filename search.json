[{"title":"如何自訂義 scrollbar -- Overlay Scrollbars 介紹","url":"%2F2019%2F09%2F26%2FOverlayScrollbars%2F","content":"\n![](https://images.unsplash.com/photo-1558464660-547f0c1f118e?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1049&q=80)\n\n## 文章目的\n有時候我們在製作網頁的時候都會遇到需要自訂義 scrollbar 的時候，筆者最近在這方面遇到一些困難，因此想用此篇文章記錄如何解決這方面問題。\n<!-- more -->\n\n## ScrollBar 特性\n首先我們要知道的是 ScrollBar 的兼容性問題，基本上我們在 css 中就可以改變我們 ScrollBar 的樣式，但這僅僅只適用於 webkit 的瀏覽器，若要兼容其他瀏覽器，我們就會需要使用到 js 來幫助我們，若僅僅只是想達到 webkit 效果且樣式簡單可以推薦你們看這篇文章--[**Webkit 自定義Scroll Bar外觀**](https://wcc723.github.io/css/2014/12/03/css-scrollbar/)\n\n## ScrollBar Thumb 問題\n了解了兼容性問題之後，我們再來了解一下 ScrollBar Thumb，ScrollBar Thumb 顧名思義就是滾軸中我們可以拖曳的區塊，它會根據我們滾軸的長短改變 size，好讓我們視覺上看起來都是從頭滾到底而不會中斷。\n但這時候問題來了，若我們今天要自訂義 ScrollBar Thumb 呢？我的自訂義圖案就那麼一丁點，可是 ScrollBar Thumb 那麼長我該怎麼讓我的圖案可以像是 ScrollBar Thumb 一樣從頭滾到尾呢？\n這就是筆者這次遇到最頭痛的情況，以下我將分享我是如何解決這問題。\n\n## Overlay Scrollbars\n這是筆者找到的一個自訂義 ScrollBar 的套件，它的特色在於只要利用 jquery 或 js 加入一些特定參數就可以控制我們指定範圍或指定 Class 的 ScrollBar，另外它裡面提供了多種樣式 Demo 供我們參考，其中有一種模板就是利用自訂義 ScrollBar Thumb 來取代預設 ScrollBar Thumb，於是筆者先將套件引入專案中，並將其提供的 Demo 程式碼做修改，主要是修改 css 部分，圖片方面用 `background-image` 引用，這樣就可以達到我們要的效果囉 !!\n另外這個套件也兼顧了各瀏覽器的兼容性問題，本人認為是自訂義 ScrollBar 時不錯的選擇。\n相關文件我會放在參考資料。\n\n## 參考資料\n[Overlay Scrollbars](https://kingsora.github.io/OverlayScrollbars/#!overview)\n[Overlay Scrollbars Demo](https://kingsora.github.io/OverlayScrollbars/#!demos/basic)\n[Overlay Scrollbars：jQuery 自定義捲軸、可單純使用 JS，半透明且可自動隱藏](https://mnya.tw/cc/word/1279.html)","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"淺談搜尋引擎最佳化(SEO)","url":"%2F2019%2F09%2F16%2FSEO%2F","content":"\n![](https://images.unsplash.com/photo-1501250987900-211872d97eaa?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80)\n\n## 文章目的\n相信接觸前端的人，對於 SEO 這個名詞應該不陌生，但 SEO 到底是什麼？ 我將透過此文章紀錄我對 SEO 的理解，並盡量以前端的觀點來敘述 SEO。\n<!-- more -->\n\n## SEO 目的\n搜尋引擎優化(search engine optimization) 又稱作 SEO，SEO 的目的在於讓搜尋引擎能更容易搜尋到網站，並讓網站處於較前面的排序，以增加網站流量。\n\n## SEO 三大重點\n1. 關鍵字：了解使用者在搜尋相關內容時會使用什麼關鍵字，例如：使用者想要了解 SEO 可能就會在搜尋引擎打上 「SEO」 這樣的關鍵字。\n2. 網站內容：當有了關鍵字後，網站提供的內容是否符合該關鍵字也是很重要，例如：使用者搜尋「SEO」大部分是為了瞭解甚麼是 SEO 而非想知道 SEO 的歷史。\n3. 網站體驗：使用者來到網站後，若使用體驗不佳，也會對 SEO 的排名造成影響，因為 google 都知道使用者在網站上停留的時間。\n\n## 前端 SEO\n這邊我記錄一下，我所知道前端對於 SEO 優化的方法。\n### h 標籤使用\n大家應該都知道 `<h1>`、`<h2>` 這類的標籤，妥善運用這些標籤可以優化網站的 SEO。\n### 圖片取代文字\n我們都知道 `<h1>` 是一個網站裡最重要的標題，但如果今天我想把它替換成網頁 logo 讓它變成 `<h1>` 呢？我們可以利用圖片取代文字的方法來實行。\n概念是利用背景圖片來取代我們的 `<h1>` 文字，範例程式碼如下：\n```css\nh1{\n    background-image: url(背景圖片路徑);\n    width: 自訂;\n    height: 自訂;\n    overflow: hidden;\n    white-space: nowrap;\n    text-indent: 101%;\n}\n```\n這邊概念是我們將文字縮排到原區域外，並讓它不會斷行，最後利用 `overflow: hidden` 把文字隱藏起來，這樣就完成效果囉!\n\n### 將網頁標籤結構化\n我們可以利用 HTML 5 的結構化標籤讓網頁結構化，使搜尋引擎能更快速了解網頁資訊。\n\n### 充分利用標題與敘述\n我們都知道 header 裡的 `<title>` 可以用來決定網頁標題，創造一個與內容有關聯的標題(但不要太過冗長)對 SEO 有很大的幫助。\n`<meta name=\"description\" content=\"網站敘述\">` 利用網站敘述也可以有效的幫助 SEO，最好是能為網站中的每一個網頁作與內容相關的敘述。\n\n### 簡單易懂的網址\n可以嘗試讓網頁網址中含有文字，且該文字與網頁內容有關。\n\n## 參考資料\n[SEO的初學者教學](https://www.newscan.com.tw/all-seo/seo-guide.htm)\n[網頁SEO優化入門](https://transbiz.com.tw/seo-guide/)\n[SEO 初學者教學，3分鐘搞懂搜尋引擎優化](https://www.youtube.com/watch?v=H8aEWX-llSc)\n[從前端設計的角度來實踐SEO！](https://www.astralweb.com.tw/the-best-seo-practices-for-front-end-coding/)","tags":["others"],"categories":["others"]},{"title":"淺談 Prototype 原型鍊與建構式概念","url":"%2F2019%2F09%2F13%2FPrototype%2F","content":"\n![](https://images.unsplash.com/photo-1526378787940-576a539ba69d?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1049&q=80)\n\n## 文章目的\n撰寫建構式原型的好處是我們將可以重複使用的方法寫在原型內，以減少記憶體的負擔，藉此篇文章紀錄 JavaScript 原型鍊與建構式介紹增加自己的開發邏輯思維。\n<!-- more -->\n\n## 何謂原型\n我們在使用一些物件或是陣列方法時，有時候很多屬性我們都能使用但卻沒看到它存在陣列或物件內，原因就是這些屬性都存在原型內，像是陣列的 `filter`、`forEach` 等。\n原型會預設存在一些屬性方法供我們在操作時調用。\n**原型有個特點是它會向上尋找**，也就是說系統在我們定義的方法中找不到相關方法時會向上尋找原型內是否有符合的方法。\n陣列原型向上就是物件原型。\n在 console 中我們看到的原型就會如下圖所示\n![](https://i.imgur.com/CbpkizB.png)\n\n## 類陣列\n有時候我們在觀察時會發現明明長得很像陣列，但原型卻不是顯示 Array，這就是所謂的類陣列，類陣列無法使用陣列的方法，當我們需要使用時，可以利用 ES6 的展開將它轉換成陣列，方法如下：\n```js\n[...類陣列]\n```\n\n## 原型共用概念\n這邊有一個重要的概念是所有原型是共有的，也就是說每一個物件或陣列它的原型都相同。\n例如我們自訂一個物件或陣列原型的屬性，這個屬性就會存在所有的物件或陣列原型內，至於如何自訂，可以參考以下方法：\n```js\n某一個物件或陣列.__proto__.test = '測試' // 所有的物件原型都會有這屬性，但不建議這樣寫，可以改用下面的寫法\n某一個物件或陣列.prototype.test = '測試' // 此方法僅限使用在建構式\n```\n\n## 何謂建構式\n我們在複製物件時，會遇到一個問題也就是**傳參考**，因為物件的這個特性，當我們修改複製過來物件內的屬性值時，原物件也會被修改到，為了避免這情形，建構式就是一個方法。\n建構式的概念是我們建立一個模板，接著我們透過 new 的方式將特定參數傳入模板中，使這個模板變成客製化的物件，這邊看一下範例程式碼會比較好理解：\n\n```js\nfunction PhoneTemplate (brand, withCamera) {  // 模板，一般來講建構式第一個字母會是大寫\n  this.brand = brand;\n  this.withCamera = withCamera;\n}\n\nvar iPhone = new PhoneTemplate('Apple', true)\nconsole.log(iPhone) // PhoneTemplate {brand: \"Apple\", withCamera: true}\n```\n## 將原型與建構式搭配\n當我們要在建構式自訂義方法時，就可以使用到原型，原因是因為原型繼承的概念，以下是範例程式碼：\n```js\nPhoneTemplate.prototype.callSomeone = function (someone) { //儲存在物件原型內的方法\n  console.log(this.brand + ' 打通電話給 ' + someone)\n}\nvar iPhone = new PhoneTemplate('Apple', true)\niPhone.callSomeone('小明') // Apple 打通電話給小明\n```\n**這邊有一點要注意，使用 prototype 來自訂原型時一定是建立在我們的模板上，以此範例來說就是 PhoneTemplate。**\n補充：當我們想要利用 console.log 觀察原型時，觀察不到的情況下可以改寫成 console.dir。\n\n## 參考資料\n[JavaScript 建構式與原型](https://wcc723.github.io/javascript/2017/12/19/javascript-constructor-and-prototype/)\n[JavaScript 原型鍊與建構式](https://www.youtube.com/watch?v=wdlbWhlftAY&t=47s)\n","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"使用 Vuex 管理專案資料傳遞","url":"%2F2019%2F09%2F08%2FVuex%2F","content":"\n![](https://images.unsplash.com/photo-1461360228754-6e81c478b882?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1053&q=80)\n\n## 文章目的\n之前在學習 vue 的資料傳遞時，是使用 Event Bus 的方式來做傳遞，但當專案較大時，Event Bus 會較難管理資料，這時我們就可以利用 Vuex 來達成資料管理與傳遞的目的，本文將介紹 Vuex 與說明使用方法。\n<!-- more -->\n\n## Vuex 介紹\nVuex 和 Event Bus 不一樣的地方是它是一個儲存庫的概念，儲存庫中將會為每一個步驟做分類與分工並讓所有的元件做使用，簡單來講就是**先將資料做個統整再做傳遞**。\n### Vuex 方法\n* state：如同元件中的 data，負責管理資料。\n* actions：如同元件中的 methods，負責處裡非同步事件，或是取得遠端資料等。\n* getter：如同元件中的 computed，在資料呈現之前做過濾的動作。\n* mutations：這是 Vuex 新增的方法，改變資料內容的方法，在以前我們要改變資料狀態時都會直接在 methods 做變更，但在 Vuex 不同，actions 並不會做資料的變更，而是在 mutations 才會做資料狀態的變更。\n\n### Vuex 運作方法\n在 Vue 的元件中，我們透過 dispatch 來觸發 actions，actions 就會去取得遠端資料，並透過 commit 的方式呼叫 mutations，最後透過 mutations 來改變 state 中的資料狀態並反映給元件。\n**這邊有一點要注意，當要使用一些非同步的行為時(AJAX、Settimeout 等)，請在 actions 中就完成它。**\n\n## Vuex 簡單範例，透過 Vuex 改變資料狀態\n現在我們就來看看 Vuex 各方法的寫法吧。\n### 範例狀況\n現在我們的專案中有讀取的動畫功能，因為很多元件在取得資料時都會需要使用這功能，因此我們打算利用 Vuex 統一管理動畫功能。\n我們利用 `isLoading = true or false` 來控制動畫的出現與消失。\n\n### 創造我們的 Vuex 儲存庫\n我們先在 `src` 資料夾中創造一個名為 `store` 的資料夾，並在此資料夾中創造一個名為 `index.js` 的檔案，這個檔案將為我們管理 Vuex。\n* 在檔案中我們先將 `vue` 和 `vuex` import 進來，程式碼如下：\n```js\nimport Vue from 'vue'\nimport Vuex from 'vuex'\n\nVue.use(Vuex)\n```\n另外在 main.js(進入點) 也要做 import 的動作，並把 store 也 import 進來，程式碼如下：\n```js\nimport Vuex from 'vuex'\nimport store from './store'\n\nVue.use(Vuex)\n\nnew Vue({\n  router,\n  store, //記得這裡也要補上 store 喔\n  render: h => h(App)\n}).$mount('#app')\n```\n\n* 接著我們在 `export default` 中輸入我們的方法：\n```js\nexport default new Vuex.Store({\n  state: {\n    isLoading: false\n  },\n  actions: {\n    updateLoading (context, status) {\n      context.commit('LOADING', status)\n    }\n  },\n  mutations: {\n    LOADING (state, status) {\n      state.isLoading = status\n    }\n  }\n})\n```\n這邊將為 actions 和 mutations 做解釋\n\nactions：創建一個 function，function 中擁有兩個參數，分別是 `context` 和 `payload(載核)`， `context` 是必要的參數， `payload` 則是我們自定義的參數(名稱也可自訂，以此範例來說就是 `status`)，接著使用 `context.commit` 觸發 mutations 並把載核傳遞給它。\n\nmutations：一樣創建一個 function，當此 function 被觸發時就會對 state 中的資料做變更。\n\n統整：在元件中因為某個事件透過 `dispatch` 觸發了 `updateLoading` 這個 action，觸發的同時將 status 的資料傳遞進來，接著 `updateLoading` 透過 `context.commit` 觸發名為 `LOADING` 的 mutations 並將 status 資料傳遞給它，最後在名為 `LOADING` 的 mutations 中將 state 中的資料狀態變更，資料變更的同時會反應回元件上。\n\n### 元件 Vuex 設定\n因為是整個專案都會用到此動畫效果，因此我們將動畫程式碼放在我們的 App.vue 中就可以反映在每個元件上。\n那因為資料的變更也是反應在 App.vue(根元件)，因此我們可以利用 `computed` 來監控 Vuex 中的這個資料，程式碼如下：\n```js\n computed: {\n    isLoading () {\n      return this.$store.state.isLoading\n  }\n```\n接著我們需要改寫的就是 methods 中觸發效果的寫法，程式碼如下：\n```js\nvm.$store.dispatch('updateLoading', true)\nvm.$store.dispatch('updateLoading', false)\n```\n透過 `dispatch` 觸發 `updateLoading` 這個 actions，並將 payload(true or false) 傳入，接著系統就會執行我們剛剛說的 Vuex 內部流程。\n\n### 為 Vuex 加入嚴謹模式來檢視錯誤\n我們另外可以在 Vuex 中加入嚴謹模式，讓我們的程式碼撰寫都在規範中，加入方式只需在 state 之前寫入以下程式碼即可：\n```js\nstrict: true,\n```\n\n## 使用 actions 取得遠端資料\n剛剛有說過若要在 Vuex 中執行非同步行為我們就需要在 actions 中執行完這個動作。\n現在將要介紹如何在 actions 中執行 AJAX 的行為。\n在 Vuex 中執行 AJAX 的好處是我們可以統一管理這個行為，且較大型網站若有很多元件都需要用到此 AJAX，也可以隨時調用，不需要在元件內重複撰寫。\n\n### 範例狀況\n現在我們要接取一支可以取得商品資料的 api， 抓取到的 api 資料皆儲存在 `products` 這個陣列裡，以下是程式碼：\n```js\nexport default new Vuex.Store({\n  strict: true,\n  state: {\n    isLoading: false,\n    products: []\n  },\n  actions: {\n    updateLoading (context, status) { //前一步驟的 loading 效果\n      context.commit('LOADING', status)\n    },\n    getProducts (context) {\n      const url = `api 路徑`\n      context.commit('LOADING', true) //觸發loading效果\n      axios.get(url).then((response) => {\n        context.commit('PRODUCTS', response.data.products)\n        context.commit('LOADING', false) //取消loading效果\n      })\n    }\n  },\n  mutations: {\n    LOADING (state, status) {\n      state.isLoading = status\n    },\n    PRODUCTS (state, payload) {\n      state.products = payload\n    }\n  }\n})\n```\n我們的目的是要把 AJAX 的資料儲存到 state 的 products 裡，因此我們先在 actions 利用 `getProducts` 這個 function 去接取 api 並把抓取到的資料透過 commit 傳遞給 `PRODUCTS`，`PRODUCTS` 收到資料後，再將資料儲存進 state 的 products 裡。\n### axios 解釋\n這邊使用的接取 api 方法是 Vue axios，但你會發現我們上列的程式碼，接取 api 時不是這樣寫 `this.$http.get(url)`，原因是現在 AJAX 的行為是在 Vuex 中進行，this 是代表元件，但現在並非在元件內，因此才會改寫，那改寫步驟如以下：\n* 將 `axios import from 'axios'` 寫入 Vuex 裡。\n* 把 `this.$http` 改寫成 `axios`。\n\n我們是直接透過掛載 axios 的方法並呼叫它，而非像一開始用 Vue 呼叫。\n\n### 元件改寫\n我們元件中一樣要有事件觸發 AJAX 的行為，一樣是使用 `dispatch` 做觸發，寫法如下：\n```js\ngetProducts () {\n  const vm = this;\n  vm.$store.dispatch('getProducts')\n},\n```\n\n一樣的我們要將 products 這個陣列內容反應在元件中，我們透過 computed 來調用，寫法如下：\n```js\nproducts () { //寫在 computed 中\n  return this.$store.state.products\n}\n```\n\n## 利用 actions 傳遞參數\n這邊要說明的是，actions 方法中只能傳遞一個參數，當我們今天要傳遞複數個參數時，就得利用物件的方法做傳遞，程式碼如下：\n```js\nthis.$store.dispatch('actions 方法', { 參數1, 參數2 })\n```\n另外若我們在執行某個 actions 方法時，需要執行另外一個 actions 方法可以利用 `commit.dispatch('actions 方法名', 參數)`，利用這種方法調用其他 actions。\n\n## getters 寫法\n前面有提到 getters 相當於 computed 我們也可以將部分寫法改成用 getters 替代，這邊示範將前幾個範例改寫。\n我們在 Vuex 中新增一個名為 `getters` 的物件，並將要 computed 回傳的資料寫入，程式碼如下：\n```js\ngetters: {\n  categories (state) {\n    return state.categories\n  },\n  products (state) {\n    return state.products\n  }\n}\n```\n這邊回傳前面範例的 products 和 categories。\n接著我們回到元件中改寫程式碼，我們先將 getters import 進元件內 `import { mapGetters } from 'vuex'`，接著在 computed 做改寫，改寫成 `...mapGetters (['products', 'categories'])`，陣列中是我們 Vuex 中 getters 的方法。\n另外，我們也可以將 actions 做改寫，只要在 import 中把 actions import 進來 `import { mapGetters, mapActions } from 'vuex'`，並在 methods 將方法改寫成 `...mapActions (['getProducts'])`，一樣的陣列中是我們的 actions 方法名。\n**這邊有一點要注意的是用這方法取用 actions 時不適用在需要傳遞參數的 actions。**\n\n## Vuex 模組化\n你可以發現到在前面的範例中我們已經在 Vuex 中寫入了很多程式碼，但這只是一個小小的範例而已，若遇到更大型專案時，模組化的概念就會顯得相當重要。\n我們可以把 Vuex 中管理的行為再做進一步的拆分，使我們更加方便管理。\n這邊將示範將範例中取得商品的方法做拆分。\n* 我們先在 store 資料夾中再新增一個叫做 `products.js` 的檔案，並把 getProducts 的 actions 和相關參數從 `index.js` 中拆出來並寫進 `products.js` 中。\n* 接著我們利用 import 將 `products.js` 的內容載入至 `index.js`： `import productsModule from './products'`，然後在 index 中新增一個名為 `modules` 的物件，並把 `productsModule` 加入。\n```js\nmodules: {\n  productsModule\n}\n```\n### 加強觀念\n在 Vuex 中 **state 是屬於模組區域變數**，裡頭的資料只會在該模組中才能做使用，但是 **actions, mutations 和 getters 屬於全域變數**。\n全域變數好處是在小型專案時可以節省開發時間，但在大型專案中就會建議使用區域變數，避免衝突(當有相同方法名的時候就會產生衝突)。\n\n### 如何取得拆分模組中的 state 區域變數(元件中)\n這方法很簡單，只需要將程式碼這樣改寫即可：\n`this.$store.state.productModule.products`\n### 將模組內全域變數改成區域變數\n若我們要避免衝突，將全域變數變成區域變數，可以在該模組的 export default 底下寫入這行程式碼：`namespaced: true`。\n變成區域變數之後我們要如何調用它呢？延續前面的調用方法我們可以這樣寫：\n```js\n...mapActions('productModule', ['getProducts']) // 第一種方法，在第一個參數中寫入要調用的模組名\n/*****/\ngetProducts () {\n  this.$store.dispatch('productsModule/getProducts') // 第二種方法，利用 dispatch 做調用 模組名/actions名\n}\n```\n### 讓特定行為變為全域調用\n若我們要某方法可以全域調用，像是範例的讀取動畫效果，因為變數是存在 index 裡，若我們要在 products 中調用可以這樣寫：\n```js\ncontext.commit('LOADING', true, { root: true })\ncontext.commit('LOADING', false, { root: true })\n```\n\n---\n\n## 參考資料\n[六角學院課程--Vue 出一個電商網站](https://www.hexschool.com/vue/)\n[官方文件](https://vuex.vuejs.org/zh/)","tags":["Vue.js"],"categories":["Vue.js"]},{"title":"如何快速開發建立原型","url":"%2F2019%2F09%2F08%2FVueInstantPrototyping%2F","content":"\n![](https://images.unsplash.com/photo-1425082661705-1834bfd09dca?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1055&q=80)\n\n## 文章目的\n有時候我們在開發小型專案時，檔案量不多僅僅只是想要使用 vue serve 和 vue build 的功能，不需要特地使用 Vue Cli 的情況下，就可以利用快速開發原型達到目的，此文章將紀錄如何快速建立原型。\n<!-- more -->\n\n## 建立全域相關安裝\n想要建立原型開發，需要先在 command line 中輸入 `npm install -g @vue/cli-service-global`，做全域安裝。\n**記得此方法僅適用於快速原型開發**。\n\n## 利用 vue 檔開發專案\n我們將開發程式碼寫寫在我們的 vue 檔內，例如創造一個 `index.vue` 並將程式碼寫入，記得 js 部分要用 `export default` 載入。\n接著我們就可以在 command line 輸入 `vue serve index.vue` 來觀看我們的專案網頁(開發中)。\n輸入 `vue build index.vue` 就可以將其打包成 dist 檔。\n\n---\n\n## 參考資料\n[六角學院課程--Vue 出一個電商網站](https://www.hexschool.com/vue/)\n[官方文件](https://cli.vuejs.org/zh/guide/prototyping.html)","tags":["Vue.js"],"categories":["Vue.js"]},{"title":"如何將 Vue Cli 2 專案轉移成 Vue Cli 3","url":"%2F2019%2F09%2F07%2FVueCli2toVueCli3%2F","content":"\n![](https://images.unsplash.com/photo-1500479694472-551d1fb6258d?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80)\n\n## 文章目的\n有時候可能會需要將 Vue Cli 2 的專案轉移成 Vue Cli 3，畢竟現在 Vue Cli 已經進化到 3 了，會讓我們管理專案時更加方便，因此利用此文章做紀錄。\n<!-- more -->\n\n## 建立新專案\n要轉移專案的話，得先建立好一個新專案，並在新專案中套用 Vue Cli 3。\n我們可以利用 Vue GUI 快速建立好我們需要的專案。\n\n## 安裝舊專案的相關套件\n* 我們有了新專案後，需要先為它安裝舊專案所擁有的套件。\n我們可以打開舊專案的 package.json，裡頭 dependencies 會寫出有安裝的套件，根據這個我們為新專案重新安裝套件。\n安裝方式有兩種，一種是利用 Vue GUI 的插件去做安裝，另一種則是在專案下利用指令碼的方式做安裝。\n利用指令碼的好處是我們只需要輸入 `npm install --save` 後面加上需要安裝的套件(可以有多個)，這樣子我們就可以一口氣安裝所需套件。\n* 接著我們參考舊專案的 main.js(進入點)，將相關套件 import 進來，這邊有一點要注意的是 **Vue Cli 3 裡的 vue 檔，在 import 時一定要加上 .vue 的副檔名**。\n\n## 將專案檔案複製( vue 檔)\n接著我們將相關的元件 vue 檔複製過來新專案，這邊說明下 Vue Cli 3 除了 components 這個資料夾外，多了一個 views 的資料夾，**views 資料夾是專門給我們放分頁用，假如說是不同 router 的檔案可以放在這**。\n在轉移檔案時，要注意環境變數問題，因為 3 和 2 的環境變數設定不太一樣，來到 3 我們需要重新設定，有關環境變數設定可以參考這篇 --- [Vue Cli 3 環境變數設定](/2019/09/04/VueCli3EnvVar/)\n這樣子我們就可以將我們的舊專案轉變成新的 Vue Cli 3 專案囉!!\n\n## 補充-- Vue Cli 3 Router 小技巧\n在以前我們使用 router 時需先將元件 import 進來再去做使用，但現在有新的方法不需要麼麻煩，只需要在路徑的 component 利用箭頭函式的方式將元件載入即可。\n```js\n{\n    path: '/about',\n    name: 'about',\n    component: () => import('./views/About.vue') //直接載入路徑即可\n}\n```\n\n---\n\n## 參考資料\n[六角學院課程--Vue 出一個電商網站](https://www.hexschool.com/vue/)","tags":["Vue Cli 3"],"categories":["Vue.js"]},{"title":"Vue Cli 3 安裝與創建專案","url":"%2F2019%2F09%2F07%2FVueCli3Insatll%2F","content":"\n![](https://images.unsplash.com/photo-1475809913362-28a064062ccd?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80)\n\n## 文章目的\n因為之前是使用 Vue Cli 2 做開發，現在在學習 Vue Cli 3 因此用此文章做個紀錄，此文章將介紹如何安裝 Vue Cli 3 及快速創建一個專案。\n本文操作皆在 command line 中執行。\n<!-- more -->\n\n## Vue Cli 2 卸載與 Vue Cli 3 安裝\n### Vue Cli 2 卸載\n在安裝之前，可以先確認 Node.js 是否有安裝，且版本是否為 8.9 以上的版本。\n確認完畢後，若電腦目前是有 Vue Cli 2 的話，在安裝 3 之前需要先卸載，卸載指令碼為 `npm uninstall vue-cli -g`，成功卸載後我們就能安裝 3 囉!!\n### Vue Cli 3 安裝\n我們在 command line 中輸入 `npm install -g @vue/cli` 即可安裝 3，安裝完成輸入 `vue --version` 檢查版本，若為 3 以上代表安裝成功。\n\n## 創建專案\n輸入 `vue create 你的專案名` 即可建立專案，在建立過程中，會有一些設定檔的安裝問題，以下做一一解釋。\n### 自訂你要安裝的設定檔\n基本上系統一開始會提供你一個預設的安裝，裡面有部分的設定檔，那如果你想在專案上安裝自己想要的設定檔，可以選擇 `Manually select features` 來自訂。\n選完要安裝的設定檔後，系統會詢問你一些關於你的設定檔的細節，只要選擇符合你的需求即可。\n再來會詢問你是否把這次的設定儲存，方便以後創立專案時直接套用，這邊就看個人需求。\n最後系統會詢問你這些設定檔要獨立出來管理，或是全部寫在 package.json 中。\n\n### 執行專案\n建立完畢專案後，command line 會提供兩個指令來開啟專案，照著指令輸入，會出現網址，在瀏覽器上輸入網址就可以確認專案是否正確運行囉!!\n\n## 簡單的資料夾介紹\n這邊我要介紹兩個 Vue Cli 3 專案裡的資料夾，分別是**src** 和 **public**。\n這兩者的差別簡單來講，放在 src 中的檔案都會被編譯，public 資料夾底下的檔案不會被編譯。\npublic 資料夾底下，僅有 index.html 這隻檔案會被編譯。\n\n---\n\n## 參考資料\n[六角學院課程--Vue 出一個電商網站](https://www.hexschool.com/vue/)\n[官方文件](https://cli.vuejs.org/zh/guide/installation.html)\n","tags":["Vue Cli 3"],"categories":["Vue.js"]},{"title":"Vue.js 電商練習技術整理 -- 使用 FormData 上傳圖片的眉眉角角","url":"%2F2019%2F09%2F07%2FEcommercePractice5%2F","content":"\n![](https://i.imgur.com/el9rgW2.jpg)\n\n## 文章目的\n有時候我們會需要將圖片上傳至後端做儲存，上傳時可利用 FormData 作為圖片的資料格式。\n本篇將介紹如何操作 Vue Cli 上傳圖片的細節。\n<!--more-->\n\n## FormData 簡單介紹\nFormData 是一個表單格式，我們可以利用它將資料轉成表單的格式，並且以表單的形式回傳給後端。 ---[FormData介紹](https://developer.mozilla.org/zh-TW/docs/Web/API/FormData)\n**至於上傳圖片時需不需要用 FormData 的形式上傳，是由後端來做決定。**\n\n## 將圖片轉換成 FormData \n* 首先，我們會利用 html 的 `<input type=\"file\">` 來上傳我們的圖片，我們可以為 input 新增一個 change 事件，程式碼如下：\n```html\n <input type=\"file\" @change=\"uploadFile\" ref=\"files\"/>\n```\n**這邊請務必加入 `ref='files'` 否則下個步驟我們會找不到檔案。**\n* 接著我們可以透過 `console.log` 的方式來找到我們要上傳的圖片所在位置，程式碼如下：\n```js\n uploadFile () {\n      console.log(this)\n }\n```\n經觀察後會發現圖片是以陣列的形式存在 **$refs.files.files** 下。\n* 先宣告一個變數來儲存我們找到的圖片\n```js\nconst uploadedFile = this.$refs.files.files[0] //這邊可根據需求決定是抓哪一張圖片或是整個陣列\n```\n* 進行到這裡我們就可以把圖片轉換成 FromData，先宣告一個變數是我們的 `new FormData()`，接著我們利用 `append` 的方式將我們的圖片塞入，程式碼如下：\n```js\nconst formData = new FormData()\nformData.append('資料屬性(根據後端決定)', uploadedFile)\n```\n## 接取 API 與渲染上傳的圖片\n* 已成功擁有一個 FormData，接著我們就可以把 FormData 透過 API 傳給後端，那因為是以 FormData的格式傳送，跟之前以物件的形式不同，所以我們需要更改傳遞格式，程式碼如下：\n```js\n const url = `API 路徑`\n      this.$http.post(url, formData, {\n        headers: {\n          'Content-Type': 'multipart/form-data' //更改成 FormData 的格式\n        }\n```\n* \n接著後續就可以針對成功回傳後做操作，像是範例這邊我們為了讓上傳成功的圖片能在畫面上呈現，因此我們需要將圖片的連結存在本地端，程式碼如下：\n```js\n  if (response.data.success) {\n          vm.$set(vm.tempProduct, 'imageUrl', response.data.imageUrl)\n        }\n```\n這邊有一點要注意，**因為用平常的方法`vm.tempProduct.imgUrl = response.data.imgUrl` 無法正確地將路徑儲存**，因此我們**改成用`$set` 的方式強制將路徑加入**。\n另外 html 方面就可以有一個 `img` 標籤 `src` 動態綁定我們上傳的圖片路徑。\n```html\n<img :src=\"tempProduct.imageUrl\">\n```\n最後附上完整的事件程式碼：\n```js\n   uploadFile () {\n      console.log(this)\n      const uploadedFile = this.$refs.files.files[0]\n      const vm = this\n      const formData = new FormData()\n      formData.append('資料屬性(根據後端決定)', uploadedFile)\n      const url = `上傳的 API 路徑`\n      this.$http.post(url, formData, {\n        headers: {\n          'Content-Type': 'multipart/form-data'\n        }\n      }).then((response) => {\n        if (response.data.success) {\n          vm.$set(vm.tempProduct, 'imageUrl', response.data.imageUrl)\n        }\n      })\n    }\n```\n\n---\n\n## 參考資料\n[六角學院課程--Vue 出一個電商網站](https://www.hexschool.com/vue/)","tags":["E-commerce"],"categories":["Vue.js"]},{"title":"如何做出會隨時間變化的同心圓？","url":"%2F2019%2F09%2F06%2FconcentricCircle%2F","content":"\n![](https://images.unsplash.com/photo-1507576566681-1932a6a38099?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=667&q=80)\n\n## 文章目的\n在做今年的 THE F2E 第一週番茄鐘時，遇到最大難題就是要做一個隨時間逐漸填滿的同心圓，想藉由此文章為製作流程做個紀錄。\n<!-- more -->\n\n## 開發思維\n同心圓內圓與外圓之間是有間隔的，隨時間倒數間隔會逐漸填滿，示意圖如下：\n![](https://i.imgur.com/TEazPyu.png)\n\n![](https://i.imgur.com/NpZ7gaR.png)\n\n我的想法是用3個圓去達成效果：\n* 第一個圓在最外圍負責最外圍的 border 顯示。\n* 第二個圓就是兩圓之間的間隔，它會隨時間變色進而達到效果。\n* 第三個圓就是內圓，與第一個圓有大小差距，進而產生間隔效果。\n\n## SVG 與 Stroke 介紹\n在這次效果製作中，這兩者扮演了很重要的角色，因此先來為它們做個簡單介紹。\n* SVG 是向量標籤，我們可以在向量標籤裡透過座標的方式畫出不同的圖案。\n* Stroke 是 SVG 的一種屬性，它代表邊框的意思，它總共有5種屬性：\n  * stroke：邊框顏色\n  * stroke-width：邊框寬度\n  * stroke-dasharray：虛線\n  * stroke-linecap：邊框端點的屬性 ( butt ( 預設 )、square、round )  ---本次開發不會用到\n  * strkoe-linejoin：邊框接合尖角的屬性 ( miter ( 預設 )、round、bevel ) ---本次開發不會用到\n \n\n## 開發流程\n### 畫出前兩個同心圓\n我們先創造一個 SVG 標籤並且在裡面畫出一個圓，SVG 就是我們的第一個圓，SVG 裡的圓就是我們的第二個圓。\n```html\n<svg style=\"transform:rotate(-90deg);width:540px;height:540px;\" class=\"rounded-circle\">\n    circle cx='270' cy='270' r='135' fill='none'>\n</svg>\n```\n這邊我定義了外圓 SVG 的長寬(540px)，並令它呈現圓形(`rounded-circle`)，內部 `circle` 方面則是畫出大小是外圓的一半的圓，至於外圓的 SVG 再記得給它畫 border線即可。\n先為 `circle` 裡的屬性做個解釋：\n* cx：圓心的 x 座標\n* cy：圓心的 y 座標\n* r：圓的半徑\n* fill：填色\n\n**因為我是要做出同心圓所以 cx 和 cy 的座標就是外圓的圓心位置。**\n### 利用 stroke 做出填色效果\n我們將 stroke 屬性下在 `circle` 裡，因為要做效果的是第二個圓\n前面有提到 stroke-width 可以控制邊框的寬度，在這邊我們就設定成 270px 讓它可以填滿第二個圓，並利用 stroke 設定邊框顏色。\n做到這裡重點來了，我們將利用 stroke-dasharray 和 stroke-dashoffset 來做出效果。\n* stroke-dasharray 是我們的虛線，假設我們設定 `stroke-dasharray=\"60\"`，呈現出的效果會是 60px 的虛線跟 60px 的空格一組一組呈現。\n* stroke-dashoffset 則會推移我們的虛線，假設我們設定 `stroke-dashoffset=\"40\"`，第一個虛線就會僅剩 20px 後面的循環則是正常進行。\n利用這兩個性質，將 stroke-dasharray 動態綁定到 Vue.js 裡的一個函數，綁定的函數負責幫我們算出圓周長並回傳給我們，因此 stroke-dasharray 就會是我們的圓周長。\n第一個虛線就是整個圓周代表一開始虛線就會填滿整個圓，所以我們就要控制 stroke-dashoffset 讓它來決定虛線出現的大小。\n我們一樣將 stroke-dashoffset 動態綁定到 Vue.js 的另一個函數，這個函數會幫我們算出符合的 stroke-dashoffset 回傳給我們。\n講到這裡是不是茫了，沒關係我們來看看程式碼就會知道是怎麼回事。\n```html\n<svg style=\"transform:rotate(-90deg);width:540px;height:540px;\" class=\"rounded-circle\">\n    <circle cx='270' cy='270' r='135' stroke-width=\"270\" :stroke-dasharray='strokeDasharray(135)' \n    :stroke-dashoffset='strokeDashoffset(135,Math.min(1,startTime/setTime))' fill='none'>\n</svg>\n```\n`Math.min(1,startTime/setTime)` ，startTime 和 setTime 是我自定義的變數，分別代表進行中的時間(startTime)與設定的時間(setTime)，Math.min 會回傳數列中的最小值。\n```js\n// 透過傳遞半徑給此函數，算出圓周長後回傳\nstrokeDasharray:function(r){\n    return r * 2 * Math.PI;\n},\n// 傳遞半徑和 Math.min() 參數後，算出現在剩餘的時間屬於圓周長的幾分之幾並回傳\nstrokeDashoffset:function(r,el){\n    return (this.strokeDasharray(r) * el );\n},\n```\n看完程式碼之後有沒有比較清楚了，startTime 一直在減少，所以我們會一直將它與 setTime 的比值傳給我們的函數，函數會算出剩餘時間是圓周長的幾分之幾，並將其回傳，這就會是我們的 stroke-dashoffset 。\n簡單來講，這個方法就是透過 stroke-dashoffset 的推移來控制 stroke-dasharray 的出現。\n\n### 製作第三個圓\n至於，第三個圓就是為了讓它幫助我們擋住第二個圓多餘的部分，因為我們的 stroke 會填滿整個圓，如果不加上第三個圓就無法呈現出只有部分填滿的視覺效果。\n第三個圓做法我就不多敘述，簡單來說，第三個圓圓心位置要跟前兩個圓一樣，在開發時我是用絕對定位做到這一點，再把它的長寬設定相較前兩個圓小即可。\n\n\n---\n\n## 參考資料\n[SVG 研究之路 (6) - stroke 邊框](https://www.oxxostudio.tw/articles/201406/svg-06-stroke.html)\n[CSS + SVG stroke 動態描繪](https://wcc723.github.io/svg/2014/06/15/svg-css-stroke-animation/)","tags":["scss"],"categories":["THE F2E"]},{"title":"Vue Cli 3 環境變數設定","url":"%2F2019%2F09%2F04%2FVueCli3EnvVar%2F","content":"\n![](https://images.unsplash.com/photo-1472313420546-a46e561861d8?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=667&q=80)\n\n## 文章目的\n之前是用 VueCli 2 做開發，那 VueCli 3 一樣有環境變數的設定，但設定方式會與 2 不太一樣，因此透過此文章來做紀錄。\n<!-- more -->\n\n## 環境變數使用時機\n基本上，在開發時，測試環境下的 API 路徑會與正式環境的路徑不太一樣，因此我們可以利用環境變數來定義這些路徑，以方便我們使用。\n\n## VueCli 2 和 VueCli 3 環境變數差異\n在 2 中我們會透過 config 資料夾底下的 **dev.env.js** 和 **prod.env.js** 兩隻檔案來定義不同環境下的環境變數。\n但 3 很不一樣，沒有 config 資料夾了，我們只需要自己命名環境檔，並做一些簡單設定，就可以讓系統自己去判斷該使用哪個檔案中的環境變數，以下我將要做一一介紹。\n\n## 環境檔命名差別\n剛剛有提到，系統會根據我們的環境檔名稱來判斷使用時機，因此我們先來看看有甚麼命名吧。\n* .env -- 這個檔名的環境檔會在所有環境中被載入。\n* .env.local -- 這個檔名的環境檔會在所有環境中被載入，但在 git 時會被忽略。\n* .env.\\[mode\\] -- 只會在指定的環境中被載入，mode 的部分就是填入指定環境 Ex：production。\n* .env.\\[mode\\].local -- 同上，但在 git 時會被忽略。\n檔案部分只需要新增在專案資料夾底下即可，不用新增在 src 底下。\n\n## 變數命名\n接下來是環境檔中的環境變數命名，這邊跟 2 差別在於命名變數時，需要在自定義名稱前面加上 **VUE_APP_** ，後面再加上自定義名稱。\n**要記得新增一個新的環境變數時，環境要重啟，變數才能做使用。**\n\n## 切換環境檔\n前面有提到環境檔也可以在特定環境下才被啟用，這邊要說明如何啟用我們命名的環境檔。\n假設我們今天新增一個環境檔，檔名叫做 `.env.testing`，並且我們希望它只在測試環境下運行。\n這時我們需要來到 `package.json` 資料夾中，裏頭的 `scripts` 部分，有分為三個類型：\n* `'serve': 'vue-cli-service serve'`\n* `'build': 'vue-cli-service build'`\n* `'lint': 'vue-cli-service lint'`\n我們只需要這樣改寫即可，\n`'vue-cli-service serve --mode testing'`\n至於官方，有提供正式的命名方式，只需要照著命名就可以不用再去變更 `package.json`。\n開發環境下的環境檔命名為：`.env.development`\n正式環環下的環境檔命名為：`.env.production`\n\n**最後一點提醒，當我們的指定環境檔中(`.env.\\[mode\\]`)存在與全域環境檔(`.env`)相同的環境變數時，指定環境檔的權重會比較高。**\n\n---\n\n## 參考資料\n[Vue官方文件--環境變量和模式](https://cli.vuejs.org/zh/guide/mode-and-env.html#%E6%A8%A1%E5%BC%8F)","tags":["Vue Cli 3"],"categories":["Vue.js"]},{"title":"CSS 小技巧紀錄園地","url":"%2F2019%2F08%2F29%2FCSStips%2F","content":"\n![](https://images.unsplash.com/photo-1523540939399-141cbff6a8d7?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=750&q=80)\n\n## 文章目的\n有鑑於在練習前端過程中，會遇到一些好用的 css 程式碼來呈現需要的網頁效果，但因為只是小技巧，不適合寫成一篇文章，因此利用此文章來為這些小技巧做個紀錄。\n<!-- more -->\n\n## input number 隱藏預設加減箭頭方法\n我們在使用 `<input type=\"number>` 時，有時候會因為預設的加減箭頭帶來困擾，且因為這兩個箭頭會導致我們的內容數字無法置中，這邊提供一段程式碼來隱藏這兩個箭頭。\n```css\ninput[type='number']::-webkit-inner-spin-button,\ninput[type='number']::-webkit-outer-spin-button {\n-webkit-appearance: none;\nmargin: 0;\n```\n這樣我們就可以達到隱藏箭頭的效果囉。\n**參考文章** --- [Center text in html number input](https://stackoverflow.com/questions/23715881/center-text-in-html-number-input)","tags":["SCSS"],"categories":["CSS"]},{"title":"利用 CSS 做出 offcanvas 遮罩效果","url":"%2F2019%2F08%2F22%2FCssMenuMask%2F","content":"\n![](https://i.imgur.com/t4j5FN5.jpg)\n\n## 文章目的\n我們在逛一些具有響應式設計的網站時，在較小裝置點開 offcanvas 的 menu 時會有類似遮罩效果出現在畫面上，此文章將用來記錄如何利用 css 做出一樣的效果。\n<!-- more -->\n## 本次示範 Demo\n這邊先附上要呈現的效果圖\n**點擊漢堡選單前**\n![](https://i.imgur.com/tutiujp.png)\n**點擊漢堡選單後**\n![](https://i.imgur.com/qNexvaJ.png)\n\n## 效果分析\n其實遮罩並沒有想像中那麼難達成，基本上只需要設置一個佔滿螢幕大小的 `div` 並利用絕對定位就可以輕鬆達成。\n遮罩的顏色我們可以根據背景色不同來做更換。\n\n## 示範程式碼\n### 遮罩製作\n我先做出一個包覆 menu 的區塊元素，並將其寬高設為裝置的寬高，程式碼如下：\n```html\n<aside class=\"side min-vh-100 min-vw-100\"> \n\n</aside>\n\n<style>\n.side{\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    background-color: rgba($color:#696969, $alpha: 0.7);\n    transition: all .3s;\n    transform: translateX(100vw);\n    overflow: hidden;\n  }\n</style>\n```\n另外用絕對定位讓它脫離排版，並且利用 `transform` 將其隱藏。\n步驟進行到這裡我們已經有個覆蓋裝置畫面的遮罩。\n\n### offcanvas menu 設置\n接著將 menu 的 `ul` `li` 寫入我們剛剛創的遮罩中，程式碼如下：\n```html\n<aside class=\"side min-vh-100 min-vw-100\">\n    <ul class=\"liststyleNone p-0 m-0 px-2 offcanvas\">\n        <i class=\"fas fa-times-circle cancel text-primary fa-2x\" @click=\"closeOffcanvas\"></i>\n        <li class=\"mt-5 d-flex justify-content-center p-0 m-0\">\n            <router-link to=\"/login\" class=\"mainNavbarBtn pt-2 h3\"><i class=\"fas fa-user mr-2\"></i>後台登入</router-link>\n        </li>\n        <li class=\"mt-5 d-flex justify-content-center p-0 m-0\">\n            <a href=\"#\" class=\"mainNavbarBtn pt-2 h3\"><i class=\"fas fa-ticket-alt mr-2\"></i>優惠卷<i class=\"fas fa-angle-down ml-2\"></i></a>\n        </li>\n        <li class=\"mt-5 d-flex justify-content-center p-0 m-0\">\n            <a href=\"#\" class=\"mainNavbarBtn pt-2 h3\"><i class=\"fas fa-shopping-cart mr-2\"></i>購物車<i class=\"fas fa-angle-down ml-2\"></i></a>\n        </li>\n        <li class=\"my-5 d-flex justify-content-center p-0 m-0\">\n            <a href=\"#\" class=\"mainNavbarBtn pt-2 h3\"><i class=\"fas fa-shopping-bag mr-2\"></i>全部商品<i class=\"fas fa-angle-down ml-2\"></i></a>\n        </li>\n    </ul>\n</aside>\n\n<style>\n .offcanvas{\n    min-width: 50vw;\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    background-color: rgba($color: #DCDCDC, $alpha: 0.8);\n    overflow: auto  /*加入此屬性才能讓內容改變時跟著自適應*/\n  }\n</style>\n```\n這邊我是設定 menu 的寬度為裝置的一半，同樣的利用絕對定位來決定它在遮罩上的位置。\n最後我們只需要設置點擊漢堡選單與叉叉時為遮罩新增與移除 className 即可， class 的部分只需要修改遮罩 `transform` 的位置就會有出現與隱藏的效果。\n**這裡有一點要注意的是若我們沒有在新增的 className 中寫入 `overflow: auto` 這個屬性會導致 offcanvas 不會出現滾動條在內容過多時，會無法順利觀看。**\n```css\n/*遮罩新增的 className*/\n.offcanvasShow{\n    transform: translateX(0);\n    overflow: auto\n  }\n```\n\n---\n\n## 參考資料\n[JS CSS實現彈出全屏灰黑色透明遮罩效果的方法](https://codertw.com/%E5%89%8D%E7%AB%AF%E9%96%8B%E7%99%BC/281513/)","tags":["SCSS"],"categories":["CSS"]},{"title":"利用 CSS 做出簡單的按鈕 hover 動畫回饋","url":"%2F2019%2F08%2F21%2FCssBtnHoverSmallFeedback%2F","content":"\n![](https://i.imgur.com/DHCpWu1.jpg)\n\n## 文章目的\n因為最近在練習製作電商網站，學到了一個不錯的按鈕 hover 回饋小技巧，想藉此篇文章做個紀錄。\n<!-- more -->\n\n## 使用技巧與介紹\n### transform\n這是一個 css 屬性可以讓使用此屬性的元素，達到被平移、旋轉、縮放和傾斜等操作，那這次我們主要用到的是 translate 這個平移屬性。\ntranslate 的特性是可以根據我們設定的值，**以元素中心點為基準平移**。\n### transition\ntransition 也是一個 css 屬性，我們可以操作此屬性，來決定元素顯示的快慢與時間。\n### css 偽元素\n偽元素是個很方便的技巧，在小地方會發揮想不到的效果，基本上偽元素會根據我們的主要元素來顯示，最常看到的就是 before 與 after，分別代表在主元素之前或是之後顯示的元素。\n\n## 本次效果說明\n我們要讓按鈕在 hover 時，頭上會有由中心點展開的線條，如下圖所示\n**觸發前**\n![](https://i.imgur.com/IIQ4IFd.png)\n**觸發後**\n![](https://i.imgur.com/6cwpx6p.png)\n\n## CSS 撰寫\n這邊我先貼上完成的程式碼，在做一一解釋：\n```scss\n .mainNavbarBtn{\n        position: relative;\n        color: rgba($color: white, $alpha: 0.8);\n        &::before{\n            position: absolute;\n            content: '';\n            top: 0;\n            left: 50%;\n            height: 3px;\n            background: white;\n            width: 0%;\n            transform: translateX(-50%);\n            transition: all .3s\n        }\n        &:hover{\n            color: rgba($color: white, $alpha: 1.0);\n            &::before{\n            position: absolute;\n            content: '';\n            top: 0;\n            left: 50%;\n            height: 3px;\n            background: white;\n            width: 100%;\n            transform: translateX(-50%);\n            transition: all .3s\n        }\n            text-decoration: none;\n        }\n    }\n```\n* 偽元素設置：這邊我們先為主元素設定一個 `position: relative` 來方便定位我們的偽元素，那因為是在上頭顯示因此用 before 或 after 就顯得沒那麼重要，若是左右顯示 before、after 就會有差別，再來是**偽元素的重點屬性 `content`**，`content` 會決定我們偽元素的內容，那因為我們只需要線條，所以可以不用填入內容，但 `content` 這屬性還是必須寫入。\n* transform 應用：因為我們的目的是要讓線條可以從中心點向兩側發散顯示，預設顯示會是從左邊頭顯示到右邊尾。\n因此我們需要利用到絕對定位與 transform 來達到效果。\n我們先用絕對定位將線條位移主元素的 50% 寬度，這時線條的頭會在主元素寬度中間的位置，這時線條顯示時的確會從中心出發，但又會有個問題，線條出發到結束一樣從左到右，且因為我們起始位置改變導致線條長度超出我們的主元素寬度。\n這時我們就需要用到 transform 來修正我們線條位置，我們設定 transform 往 x 軸的負方向偏移 50% 將多出的部分轉移回來，這樣視覺上我們就會以為是從中間向兩側發散。\n* transition 效果：最後我們只需要加入 transition 設定我們線條的顯示時間，就會有漸變的效果出現囉!!\n\n---\n\n## 參考資料\n[卡斯伯老師偽元素介紹](https://wcc723.github.io/css/2013/09/22/css-pseudo-element/)\n[transform各效果應用](https://boohover.pixnet.net/blog/post/35341387-%E6%97%8B%E8%BD%89%E3%80%81%E5%82%BE%E6%96%9C%E3%80%81%E7%B8%AE%E6%94%BE%E7%9A%84%E8%AE%8A%E5%BD%A2%E6%95%88%E6%9E%9C-transform-(css-prope)","tags":["SCSS"],"categories":["CSS"]},{"title":"Vue.js 電商練習技術整理 -- 利用 v-model 技巧建立表單篩選功能","url":"%2F2019%2F08%2F20%2FEcommercePractice9%2F","content":"\n![](https://i.imgur.com/el9rgW2.jpg)\n\n## 文章目的\n當我們在使用電商網站時無論是前後台都會因為資料過多，無法即時找到含有特定條件的資料，本文將示範利用 v-model 簡單建立出後台的訂單篩選功能。\n<!-- more -->\n\n## 搞懂篩選機制(單選)\n我們可以利用 radio 做出單選的篩選表單出來，當我們點選需要的 radio 時透過 value 出來的值來決定要顯示的資料。\n\n## 替 radio 綁定 v-model\n為甚麼要用 v-model 呢？原因是我們可以在每次點選 radio 時將 value 的值透過 v-model 儲存在 Vue 的 Data 裡，再利用 v-for 做資料篩選，以下是 radio 程式碼：\n```html\n<div class=\"dropdown-menu\" aria-labelledby=\"dropdownMenuButton\">\n    <div class=\"form-check m-2\">\n        <input class=\"form-check-input\" type=\"radio\" name=\"paidRadios\" id=\"allRadios\" value='all' checked v-model=\"selectOption\">\n        <label class=\"form-check-label\" for=\"allRadios\">全部</label>\n    </div>\n    <div class=\"form-check m-2\">\n        <input class=\"form-check-input\" type=\"radio\" name=\"paidRadios\" id=\"paidRadios\" value=\"paid\" v-model=\"selectOption\">\n        <label class=\"form-check-label text-success\" for=\"paidRadios\">已付款</label>\n    </div>\n    <div class=\"form-check m-2\">\n        <input class=\"form-check-input\" type=\"radio\" name=\"paidRadios\" id=\"unpaidRadios\" value=\"nopaid\" v-model=\"selectOption\">\n        <label class=\"form-check-label text-muted\" for=\"unpaidRadios\">未付款</label>\n    </div>\n</div>\n```\n這邊可以看到上述程式碼有3組個 radio 選項，每個選項的 value 值都不同，但都綁定相同的 v-model，當我們點選選項時，選項的 value 值就會被存進我們綁定的 v-model 上。\n\n## 撰寫篩選條件\n表單資料部分，利用 computed 做資料的篩選條件，像本次範例就以**已付款**、**未付款**作為篩選條件，以下是 computed 的範例程式碼：\n```js\n  computed: {\n    selectOrders () {\n      const vm = this\n      if (vm.selectOption === 'all') {\n        return vm.orders\n      } else if (vm.selectOption === 'paid') {\n        return vm.orders.filter((item) => {\n          return item.is_paid //已付款\n        })\n      } else if (vm.selectOption === 'nopaid') {\n        return vm.orders.filter((item) => {\n          return !item.is_paid //未付款\n        })\n      }\n    }\n  }\n```\n這邊針對上述程式碼做個解釋，我們先將從後端抓到的所有訂單資料儲存在 `orders` 這個陣列裡，接著透過我們 v-model 綁定的 `selectOption` 來篩選特定條件的資料。\n如果有預設頁面的顯示資料的話可以先在 `selectOption` 填入對應的值，像是如果一開始顯示全部資料我們可以填入`all`。\n**這樣就完成一個簡單的資料篩選功能囉~~~**\n\n## 參考資料\n[Vue.js: data、v-model 與雙向綁定](https://cythilya.github.io/2017/04/14/vue-data-v-model/)","tags":["E-commerce"],"categories":["Vue.js"]},{"title":"Vue 小技術小工具園地","url":"%2F2019%2F08%2F13%2FVueTips%2F","content":"\n![](https://images.unsplash.com/photo-1534398079543-7ae6d016b86a?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=750&q=80)\n\n## 文章目的\n有鑑於現在在練習利用 Vue 開發電商網站，中間會發現一些前端前輩提供的好用程式碼，或是一些好用的套件、工具，想透過此文章記錄下來，方便以後回憶查找。\n若陸續發現好用的工具與程式碼會持續更新，或許會出好幾回XD\n<!--more-->\n## Vue Awesome Swiper 讓 Vue 輕鬆使用輪播功能\nVue Awesome Swiper 是一個提供 Vue 能使用輪播功能的套件，我們只需做簡單的安裝與引用就可以達到效果。\n### 安裝與引用套件\n  1. 在終端機輸入 `npm install vue-awesome-swiper --save` 進行安裝。\n  2. 此套件可以做全域與區域的引用，這邊我們要介紹如何全域引用它，來到進入點(main.js)，在裡面輸入以下程式碼：\n  ```js\n  import VueAwesomeSwiper from 'vue-awesome-swiper'\n  import 'swiper/dist/css/swiper.css'\n  Vue.use(VueAwesomeSwiper)\n  ```\n  進行到這邊我們已完成安裝與引用的動作，接下來就是使用它。\n### Vue Awesome Swiper 使用方法\n  1. 在需要使用的 Vue 元件 html 部分載入以下程式碼：\n  ```html\n  <swiper :options=\"swiperOption\">\n        <swiper-slide><img src=\"...\"></swiper-slide>\n        <swiper-slide><img src=\"...\"></swiper-slide>\n        <swiper-slide><img src=\"...\"></swiper-slide>\n  </swiper>\n  ```\n  每一個 `swiper-slide` 就是一張輪播圖片，裡面不一定要使用 `img` 也可以使用 `background-image` 方式去設定圖片。\n  `swiper` 綁定的 `options` 提供我們對輪播的參數設定。\n  2. 來到 js 部分對輪播做一些簡單設定與介紹，程式碼如下：\n  ```js\n  export default {\n  name: 'carousel',\n  data () {\n    return {\n      swiperOption: {\n        autoplay: {\n          delay: 2500, /*自動輪播間格時間*/\n          disableOnInteraction: false /*使用者拖曳輪播時是否取消自動輪播*/\n        },\n        loop: true, /*是否重複輪播*/\n        effect: 'fade' /*輪播顯示效果(預設為slide)*/\n        }\n      }\n    }\n  }\n  ```\n  這邊只做一些簡單的介紹，若需要其他額外效果或了解其他參數，這邊附上我找到的相關文章，另外基本上**參數部分都與 swiper 這個套件相同**。\n  [參數與效果示範](https://segmentfault.com/a/1190000014609379#autoplay)\n  [swiper官方文件](https://3.swiper.com.cn/)\n  [Vue Awesome Swiper官方文件](https://github.com/surmon-china/vue-awesome-swiper)\n\n## Vue Filter 金錢格式程式碼(currency)\n有時候我們會需要將數字轉換成金錢的格式，像是加入千分號及錢字號，這邊提供一個 js 程式碼，方便套用至 Vue filter 就可以輕鬆轉換格式。\n```js\nexport default function (num) {\n  const n = Number(num)\n  return `$${n.toFixed(0).replace(/./g, (c, i, a) => {\n    const currency = (i && c !== '.' && ((a.length - i) % 3 === 0) ? `, ${c}`.replace(/\\s/g, '') : c)\n    return currency\n  })}`\n}\n```\n\n## Vue filter 日期格式程式碼(date)\n在我們抓取日期時，基本上後端抓來的日期都會是 Timestamp 格式，這邊提供將 Timestamp 轉換成一般時間格式的程式碼，方便使用在 Vue filter 裡。\n```js\nexport default function (time) {\n  const date = new Date(time * 1000)\n  return date.toLocaleDateString()\n}\n```\n\n## Vue 簡單搭配 localStorage 寫法\n有時候我們在寫網頁的時候，會需要用到 localStorage 來幫助我們儲存一些資料，這邊將介紹簡單的 Vue localStorage 寫法。\n* 一樣的我們先為需要儲存的資料變數下以下語法，來抓取 localStorage 的資料：\n```js\n data () {\n    return {\n      變數名稱: JSON.parse(localStorage.getItem('localStorage名稱')) || [],\n    }\n  }\n```\n**這邊有很重要的一點是 `JSON.parse` 與空陣列的順序不能對調，不然抓取資料時會有錯誤!!!**\n* 接著我們可以下 `watch` 語法來監聽這個變數的資料變化，當資料一產生變化就儲存到 localStorage 裡，程式碼如下：\n```js\n watch: {\n    上一步驟的變數名: {\n      handler () {\n        let storageName = 'localStorage名稱'\n        localStorage.setItem(storageName, JSON.stringify(this.上一步驟的變數名))\n      },\n      deep: true\n    }\n  }\n```\n進行到這裡，我們就可以順利的儲存我們監聽的資料到 localStorage 中囉。\n\n## 當動態路由改變時該如何讓畫面重新渲染？\n什麼時候會發生這情況呢？目前筆者遇到這情況是已經在某一個動態路徑底下，在這路徑下我想切換到另一個動態路徑，但因為元件模組是相同的，因此我們沒做監視的話，畫面是不會重新渲染的。\n這時候需要用到我們 Vue 的 watch 功能，用 watch 來監視我們動態路由，當路由改變就執行一些指令讓畫面重新渲染。\n程式碼如下：\n```js\nwatch: {\n  $route: {\n    handler () {\n      this.productId = this.$route.params.Id\n      this.getDetail()\n    }\n  }\n}\n```\n此段程式碼中我們監視 `$route` ，當它發生變化時我們就重新抓取它改變後的路徑名，並儲存起來，方便後面的函數執行重新抓取資料，進而重新渲染畫面。\n\n[**參考資料**](https://github.com/stuxt/stuxt.github.io/issues/29)","tags":["Vue.js"],"categories":["Vue.js"]},{"title":"Vue.js 電商練習技術整理 -- 使用 VeeValidate 輕鬆建立表單驗證","url":"%2F2019%2F08%2F09%2FEcommercePractice8%2F","content":"\n![](https://i.imgur.com/el9rgW2.jpg)\n\n## 文章目的\n我們應該都有經驗在網路上購買東西，填寫資料時若資料填寫不完整，會導致表單無法送出，無法完成訂單程序，往往使用者在填寫訂單時會需要填入一些必要的資料。\n本文章將用來記錄用 Vue.js 開發時如何使用 VeeValidate 來驗證使用者資料正不正確，若不正確就阻止資料的送出。\n<!--more-->\n## VeeValidate 簡介\nVeeValidate 是 Vue.js 表單驗證的外掛套件，使用它我們只需在需要驗證的表單上加入一些特定語法就可以建立驗證，附上[官方文件](https://baianat.github.io/vee-validate/guide/)。\n\n## VeeValidate 安裝及引用\n### 套件安裝\n一樣打開我們的終端機輸入`npm install vee-validate --save` 安裝至我們的 Vue Cli 裡，那當然也有 cdn 的方式，相關內容可以觀看官方文件。\n**這邊有一點要注意，因為此套件官方還有持續在更新，寫這篇文章時筆者是使用2.2.14版本，後來因為更新到3.x版本時，筆者使用起來會有些問題，因此還是建議先以2.x版本為主。**\n**若要改安裝2.x版本的話，可以輸入`npm install vee-validate@2.2.15 --save` 即可，在這之前若已經安裝此套件的話，要先輸入`npm uninstall vee-validate --save` 將套件移除。**\n### 中文化安裝及引用\n因為 VeeValidate 有支援中文，所以我們接下來要將 VeeValidate 引用至我們的專案，並且將其中文化。\n#### 中文化 \n為了支援中文，我們需要先在終端機輸入`npm install vue-i18n --save`。\n#### 引用與設定\n安裝完成後，來到進入點(main.js) import 以下幾支檔案：\n```js\nimport VeeValidate from 'vee-validate'\nimport zhTW from 'vee-validate/dist/locale/zh_TW'\nimport VueI18n from 'vue-i18n'\n```\n接著我們在下面做以下設定：\n```js\nVue.use(VueI18n)\n\nconst i18n = new VueI18n({\n  locale: 'zhTW'\n})\nVue.use(VeeValidate, {\n  events: 'input|blur', //這是為了讓使用者離開該欄位時觸發驗證\n  i18n,\n  dictionary: {\n    zhTW\n  }\n})\n```\n另外要記得在下面 `new Vue` 中把 `i18n` 載入，如下：\n```js\nnew Vue({\n  i18n,\n  el: '#app',\n  router,\n  components: { App },\n  template: '<App/>'\n})\n```\n進行到這裡我們就完成中文化與引用的步驟了，每個 Vue 元件中可以正常使用 VeeValidate。\n## 表單驗證設定\n### 基本寫法\n我們來到需要驗證的 `html input` 標籤，先來看看程式碼：\n```html\n<div class=\"form-group\">\n      <label for=\"username\">收件人姓名</label>\n      <input type=\"text\" class=\"form-control\" name=\"name\" id=\"username\" :class=\"{'is-invalid':errors.has('name')}\"\n        v-model=\"form.user.name\" placeholder=\"輸入姓名\" v-validate=\"'required'\">\n      <span class=\"text-danger\" v-if=\"errors.has('name')\">姓名必須輸入</span>\n</div>\n```\n上面是一個利用 Bootstrap 4 表單做出來的版型，這裡有幾個重點：\n* `input` 標籤內要設定 `name`這個屬性，屬性值的部分則是根據該欄位性質做設定，例：姓名就是 name，地址就是 address。\n當然屬性值根據當下情況自己命名即可。\n* **必須在 `input` 標籤裡加上 `v-validate=\"'required'\"`**，這是為了讓系統知道這一個欄位是必填的。\n* 接著我們可以寫入提示文字效果，像是上面的「姓名必須輸入」，我們透過 v-if 去控制它若驗證錯誤就顯示文字，至於 `errors.has('name')` 括號填入我們剛剛說的 `name` 屬性值，它就會幫我們判斷 true or false ，當是 **true 時驗證失敗，false 時驗證成功**。\n* VeeValidate 可以與 Bootstrap 4 的驗證效果共用，因此我們一樣可以利用 v-if 的方式來動態新增 `is-invalid` 這個 className 讓提示更加明顯。\n### email寫法\n這邊要額外提到 email 欄位的驗證法，email 會跟其他資料欄位有點不一樣，因此分出來講解。\n一樣的我們先來看看程式碼：\n```html\n<div class=\"form-group\">\n      <label for=\"useremail\">Email</label>\n      <input type=\"email\" class=\"form-control\" name=\"email\" id=\"useremail\" :class=\"{'is-invalid':errors.has('email')}\"\n        v-model=\"form.user.email\" placeholder=\"請輸入 Email\" v-validate=\"'required|email'\">\n      <span class=\"text-danger\" v-if=\"errors.has('email')\">{{errors.first('email')}}</span>\n</div>\n```\n這邊有兩個地方跟基本寫法不太一樣。\n* 在我們設定 `v-validate=\"'required|email'\"` 時，需要在 `required` 後面加入 `email`，這樣在驗證時才會以 email 的格式來驗證。\n* 另外在驗證提示文字用**兩個中括號包覆填入 errors.first\\('email'\\)**，會顯示 VeeValidate 的預設文字，它會根據 email 驗證的各種狀態來顯示不同的提示文字，我們一開始設定的中文化也在這邊派上用場，提示文字會是中文。\n## 驗證方法設定\n進行到這邊我們的表單已經能正常驗證，但是這僅僅是效果，若我們搭配 API 去設計表單的話依然一樣會將資料送出，因此我們需要利用方法來阻止 API 的接取，根據官方提供的寫法，可以這樣寫：\n```js\n this.$validator.validate().then((valid) => {\n        if (valid) {\n           // 當驗證成功時執行 AJAX 的行為\n          })\n        } else {\n           // 驗證失敗產生的行為\n        }\n      })\n```\n上述的方法可以加在 submit 後觸發的事件內。\n\n---\n\n## 參考資料\n[六角學院課程--Vue 出一個電商網站](https://www.hexschool.com/vue/)\n[官方方法使用](https://baianat.github.io/vee-validate/guide/events.html#changing-events-per-field)","tags":["E-commerce"],"categories":["Vue.js"]},{"title":"Vue.js 電商練習技術整理 -- event bus 元件間的溝通橋樑","url":"%2F2019%2F08%2F06%2FEcommercePractice7%2F","content":"\n![](https://i.imgur.com/el9rgW2.jpg)\n\n## 文章目的\n在我們開發 Vue 的專案時，每個元件檔案間都會有內外層的差別，例：一個 Root 下有兩個 side 每個 side 底下又有3個元件，當我們需要利用內層的資料來觸發外層的事件時，會需要一層一層的將資料向上傳遞，這會顯得較為麻煩，因此我們可以利用 event bus 的方式，直接將我們內層的資料傳遞給外層作使用。\n<!--more-->\n## event bus 簡介\nevent bus 的重點在於它可以幫我們把特定事件直接掛載到 Vue 的 原型下(Prototype)，元件間透過 **$on(監聽)**以及 **$emit(觸發)**兩種行為來達到內層觸發外層事件的效果。\n\n## 透過 event bus 將內層資料傳遞至外層觸發 alert 效果\n### 新增 alert 模板\n我們可以在 Vue Cli 的 components 資料夾底下新增一個 AlertMessage 的元件，並在裡面設計我們的 alert 模板。\n### 將 event bus 掛載到原型上\n掛載到原型上的目的是為了讓所有元件皆能使用。\n在 Vue Cli 的 src 資料夾底下新增一個 bus.js 並在裡面輸入以下程式碼以完成掛載：\n```js\nimport Vue from 'vue'\n\nVue.prototype.$bus = new Vue()  //$bus 為自訂義的名稱可以自行命名，建議要加上$\n```\n接著我們在進入點(main.js)下 import 這隻檔案進來。\n```js\nimport './bus'\n```\n### 在 AlertMessage 元件下做監聽\n因為我們要讓底層元件觸發 event bus 時， event bus 會將相關資料傳遞到 AlertMessage 做使用，所以我們在 AlertMessage 中加入 event bus 的監聽，程式碼如下：\n```js\n  created () {\n    const vm = this\n    // 自定義名稱 'messsage:push'\n    // message: 傳入參數\n    // status: 樣式，預設值為 warning\n    vm.$bus.$on('message:push', (message, status = 'warning') => {\n      vm.updateMessage(message, status)\n    })\n  }\n```\n主要監聽時會有幾個屬性與參數可以做設定，自定義的名稱以及監聽的參數，**基本上參數就會是內層傳遞上來的資料**，接著可以將這些資料參數套用到元件內的其他 methods 中。\n像在本次範例中將參數傳遞給 `updateMessage` 做使用，以下附上完整程式碼：\n```js\nexport default {\n  name: 'Navbar',\n  data () {\n    return {\n      messages: []\n    }\n  },\n  methods: {\n    updateMessage (message, status) {\n      const timestamp = Math.floor(new Date() / 1000)\n      this.messages.push({  //以下3個數值會影響到 alert 顯示結果\n        message,  //alert 顯示的訊息\n        status,  //alert 的顏色\n        timestamp  //alert 的 id\n      })\n      this.removeMessageWithTiming(timestamp)\n    },\n    //手動關閉 alert \n    removeMessage (num) {\n      this.messages.splice(num, 1)\n    },\n    //讓訊息顯示後5秒自動消失\n    removeMessageWithTiming (timestamp) {\n      const vm = this\n      setTimeout(() => {\n        vm.messages.forEach((item, i) => {\n          if (item.timestamp === timestamp) {\n            vm.messages.splice(i, 1)\n          }\n        })\n      }, 5000)\n    }\n  },\n  created () {\n    const vm = this\n    vm.$bus.$on('message:push', (message, status = 'warning') => {\n      vm.updateMessage(message, status)\n    })\n  }\n}\n```\n完成 alert 部分的設定後我們可以將此元件 import 進要顯示訊息的 Dashboard 元件下。\n```js\nimport Alert from './AlertMessage'\nexport default {\n  components: {\n    Alert\n  }\n} \n```\n要記得將元件加入 HTML 裡。\n```html\n<template>\n    <div>\n        <Navbar/>\n        <Alert></Alert>\n        <div class=\"container-fluid\">\n            <div class=\"row\">\n                <Sidebar></Sidebar>\n            <main role=\"main\" class=\"col-md-9 ml-sm-auto col-lg-10 px-4\">\n                <router-view></router-view>\n            </main>\n            </div>\n        </div>\n    </div>\n </template>\n```\n### 在內層的 Products 元件上新增 event bus 的觸發事件\n透過 ajax 的失敗，觸發 event bus 將相關參數傳遞給 AlertMessage，以下是程式碼：\n```js\n      this.$http.post(url, formData, {\n        headers: {\n          'Content-Type': 'multipart/form-data'\n        }\n      }).then((response) => {\n        console.log(response.data)\n        if (response.data.success) {\n          vm.status.fileUploading = false\n          vm.$set(vm.tempProduct, 'imageUrl', response.data.imageUrl)\n        } else {\n          this.$bus.$emit('message:push', response.data.message, 'danger')\n        }\n      })\n    }\n```\n我們在之前 formData 上傳圖片的事件中，新增若上傳失敗就觸發 `message:push` 並根據我們當初自訂的格式回傳相關參數。\n當 AlertMessage 收到我們回傳的參數時，就會根據這些參數去渲染 alert 效果。\n## 小技巧補充\n有時候我們在定義 event bus 的事件名稱及相關參數時會忘記是在哪個元件上做定義，因此我們可以利用註解的方式，將我們的定義方法寫在 bus.js 裡以方便了解。\n最後，小提醒 **event bus 在管理上會有些問題，能的話盡量使用在較不複雜的網頁結構上**。\n\n---\n\n## 參考資料\n[六角學院課程--Vue 出一個電商網站](https://www.hexschool.com/vue/)\n","tags":["E-commerce"],"categories":["Vue.js"]},{"title":"Vue.js 電商練習技術整理 -- 製作讀取動畫增加使用者體驗","url":"%2F2019%2F08%2F05%2FEcommercePractice6%2F","content":"\n![](https://i.imgur.com/el9rgW2.jpg)\n\n## 文章目的\n我們時常在逛其他網站時，讀取過程中會看到一些動畫呈現，此文章用來記錄在用 Vue 開發網站時，如何製作同樣的動畫效果。\n<!--more-->\n\n## 方法簡介\n1. 套用 vue-loading-overlay 套件達到效果 --- [vue-loading-overlay官方文件](https://www.npmjs.com/package/vue-loading-overlay)\n2. 利用 FontAwesome 提供的 loading 圖案達到效果 ---[FontAwesome Loading](https://fontawesome.com/how-to-use/on-the-web/styling/animating-icons)\n\n## vue-loading-overlay\n這是一個 vue 的套件，透過安裝此套件我們可以輕易地呈現 loading 效果。\n### vue-loading-overlay 安裝\n這邊我們透過 npm 的方式來安裝此套件\n`npm install vue-loading-overlay --save`\n\n透過此套件的官方文件，我們可以得知它有兩種使用方式：\n1. 透過 Component 方式載入。\n2. 透過 Plugin 方式載入。\n本次範例將以 Component 方式載入做講解。\n\n### vue-loading-overlay 載入\n我們先來到 Vue Cli 的進入點(main.js)，import 以下兩支檔案：\n```js\nimport Loading from 'vue-loading-overlay' //component\nimport 'vue-loading-overlay/dist/vue-loading.css' //style\n```\n利用 component 方法做載入：\n```js\nVue.component('Loading', Loading)\n```\n進行到這裡，我們已完成全域的 loading 設定，接下來就可以在需要 loading 的頁面上做載入。\n\n### 載入 loading 特效\n將此 loading 模板放入元件最外層的 div 底下(**這樣才能將效果套用到整個元件頁面上，若只需要部份做套用可以僅放在需套用的區塊內即可。**)，程式碼如下：\n```html\n<div>\n    <loading :active.sync=\"isLoading\"></loading>\n</div>\n```\n這是最基本的模板，`isLoading`負責控制效果是否出現，**若要自訂效果或是增加一些控制屬性，可參考[這篇文章](https://ithelp.ithome.com.tw/articles/10209705)**\n進行到這裡我們的頁面已會正確的出現效果，那如果要控制出現在效果的時機，我們可以透過 `isLoading` 的操作來控制。\n\n### 控制 loading 出現時機\n以範例來講，我們可以先在 data 的部分宣告我們的變數 `isLoading = false`，讓 loading 效果一開始是隱藏的，當 ajax 執行時觸發 loading 效果，並在 ajax 成功時，結束 loading 效果，程式碼如下：\n```js\nexport default {\n  data () {\n    return {\n      products: [],\n      isLoading: false\n    }\n  },\n  methods: {\n    getProducts () {\n      const api = `你的 api 路徑`\n      const vm = this\n      vm.isLoading = true //正在執行 ajax 時 isLoading = true 觸發效果\n      this.$http.get(api).then(response => {\n        console.log(response.data)\n        vm.isLoading = false //ajax結束時，isLoading = false 結束效果\n        vm.products = response.data.products\n      })\n    },\n```\n## FontAwesome 載入動畫效果\n### 將 FontAwesome 引用置專案中\n有兩種方法可以將FontAwesome引用：\n1. cdn 方式\n2. npm 安裝\ncdn 方式這邊就不多加說明，我們來稍微解釋一下如何透過 npm 載入。\n我們先在終端機上輸入以下指令：\n`npm install --save-dev @fortawesome/fontawesome-free`\n待安裝完畢我們會在 node_modules 資料夾底下看到 **@fortawesome**，這代表安裝完成。\n接著我們要載入它，先來到需要使用的元件下將下列程式碼加入該元件的 `style` 裡。\n```css\n<style>\n  @import url(\"@fortawesome/fontawesome-free/css/all.css\");\n</style>\n```\n亦或是在 main.js 輸入以下程式碼做全局載入：\n```js\nimport '@fortawesome/fontawesome-free/css/all.css'\nimport '@fortawesome/fontawesome-free/js/all.js'\n```\n\n### 使用 FontAwesome 動畫 icons\nFontAwesome 官網中的文件有提到一種 Animating icons，只要加入此 icon 就會有動畫載入的效果 --- [Animating icons](https://fontawesome.com/how-to-use/on-the-web/styling/animating-icons)。\n當然我們也可以控制 icons 的出現時機，方法和 vue-loading-overlay 相似，只是這邊我們是用 v-if 的方式來做，以下是程式碼：\n```html\n<i class=\"fas fa-spinner fa-spin\" v-if=\"status.fileUploading\"></i>\n```\n我們在 data 內宣告一個變數負責判斷 icons 的出現。\n```js\nexport default {\n  data () {\n    return {\n      status: {\n        fileUploading: false\n      }\n    }\n  }\n```\n最後一樣的可以根據事件的觸發來改變 `this.status.fileUploading` 的布林數，進而觸發 icons 的顯示與隱藏。\n**最後有一點要補充，還是會建議 FontAwesome 載入效果主要用在局部，若要全局效果還是會建議使用 vue-loading-overlay**\n\n## FontAwesome 打包時注意!!\n**因為 FontAwesome 打包後容量較大，若不修改容量限制會導致 FontAwesome 無法一起被打包。**\n因此我們需要對設定檔做修改。\n來到 build 底下的 webpack.base.conf.js 找到下列程式碼：\n```js\n{\n        test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/,\n        loader: 'url-loader',\n        options: {\n          limit: 800000, //預設是10000，這邊修改成800000\n          name: utils.assetsPath('fonts/[name].[hash:7].[ext]')\n}\n```\n修改完後，再執行 npm run build 打包動作。\n**僅限利用 npm 方式引入 FontAwesome 需做此修改，若為 cdn 方式引用不需這樣做。**\n\n---\n\n## 參考資料\n[六角學院課程--Vue 出一個電商網站](https://www.hexschool.com/vue/)\n[JB大的文章](https://ithelp.ithome.com.tw/articles/10209705)","tags":["E-commerce"],"categories":["Vue.js"]},{"title":"Vue.js 電商練習技術整理 -- 導入 Bootstrap 與 jQuery","url":"%2F2019%2F07%2F30%2FEcommercePractice4%2F","content":"\n![](https://i.imgur.com/el9rgW2.jpg)\n\n## 文章目的\n為了讓 Vue Cli 能正常使用 Bootstrap 4 的 jQuery 相關功能，本文用來記錄導入流程。\n<!--more-->\n## 本次示範\n本次要用來導入的是 Bootstrap 4 的 Modal 元件，那因為 Modal 會需要利用到 jQuery 來達到效果，因此我們需要先正確的導入 Bootstrap 4 的 js 檔案與 jQuery。---[Modal元件官方文件](https://bootstrap.hexschool.com/docs/4.2/components/modal/#modalshow)\n\n## 導入 Bootstrap 4 js 檔與 jQuery\n我們先到進入點(main.js)，將 Bootstrap 4 js 檔 `import` 進來，程式碼如下：\n```js\nimport Vue from 'vue'\nimport axios from 'axios'\nimport VueAxios from 'vue-axios'\nimport 'bootstrap'\nimport App from './App'\nimport router from './router'\n```\n**這邊要記得 `import` 的順序自定義檔案都要放在最後。**\n接著我們來到需要引用 Modal 的頁面(Vue檔)，在 `<script>` 標籤上做以下操作：\n```js\nimport $ from 'jquery' //需使用元件導入(區域)\n```\n**此為區域的引入，引入的 jQuery 僅有在該元件能使用**，若想要全域引用可以在 main.js 加入以下程式碼：\n```js\nimport 'jquery' //main.js導入(全域)\n```\n**這邊有一點要注意，若有使用 ESlint 會顯示不建議在全域導入**，因此需額外加入以下程式碼：\n```js\n/* global $ */ //main.js導入(全域)\n```\n最後，我們將 Bootstrap 4 的 Modal 元件程式碼放入需使用的 Vue 元件內即可。\n\n## 透過事件觸發顯示 Modal\n我們這邊要稍微修改一下 Modal 的啟動方式，一般來講僅需要按鈕有對應的 Modal id 就可以啟動它。\n那會要改寫成觸發事件是因為，這樣可以更靈活地顯示 Modal，如遇到需要接取 API 時可以讓 API 資料確定接收後再顯示 Modal。\n這邊我們僅改成利用點擊觸發事件，如需要其他觸發方法可再自行更改。\n* 先在要觸發事件的按鈕上增加點擊事件，程式碼如下：\n```html\n <button class=\"btn btn-primary\" @click.prevent=\"openModal\">建立新的產品</button>\n```\n* 接著建立我們的 `methods`，程式碼如下：\n```js\n methods: {\n    openModal () {\n      $('#productModal').modal('show')\n    }\n  },\n```\n有關程式碼可參考官方文件 ---[Modal show](https://bootstrap.hexschool.com/docs/4.2/components/modal/#modalshow)\n\n---\n\n## 參考資料\n[六角學院課程--Vue 出一個電商網站](https://www.hexschool.com/vue/)","tags":["E-commerce"],"categories":["Vue.js"]},{"title":"Vue.js 電商練習技術整理 -- 登入簡易路徑切換","url":"%2F2019%2F07%2F30%2FEcommercePractice3%2F","content":"\n![](https://i.imgur.com/el9rgW2.jpg)\n\n## 文章目的\n一般電商都會有登入畫面，當登入成功時會有畫面路徑的切換，本文用來記錄 Vue Cli 製作此方法流程。\n<!--more-->\n\n## 基本概念\n* 在登入頁面中透過接取後端驗證 API 來認證使用者的帳號密碼，若驗證成功就變更路徑至其他頁面。\n* 其他頁面具有登出功能，透過後端登出 API 將使用者帳號登出，並使路徑跳轉至登入前畫面。\n* 需登入才能進入的頁面，在尚未登入時不能隨意進入。\n\n## 驗證帳號 API 接取與路徑切換\n* 我們可以在 components 資料夾底下新增一個 pages 資料夾，並在裡面新增一個 Login.vue 檔。\n* 在 Login.vue 檔中切出需要的登入版型，並透過 v-model 方式將使用者輸入的帳號密碼做雙向綁定，程式碼如下：\n```js\n data () {\n    return {\n      user: {\n        username: '',\n        password: ''\n      }\n    }\n  },\n```\n**這邊 data 裡的格式，根據驗證 api 要求的格式來設定。**\n* 我們為登入的版型製作一個 submit 的事件來觸發驗證 API，事件方法如下：\n```js\n methods: {\n    signin: function () {\n      const api = `驗證的 api 網址`\n      const vm = this\n      this.$http.post(api, vm.user).then((response) => {\n        if (response.data.success === true) {\n          vm.$router.push('/')\n        }\n      })\n    }\n  }\n```\n我們利用 `post` 回傳使用者資料(user)給後端，利用判斷式判斷後端回傳成功與否來決定路徑是否切換。\n\n## 登出驗證與路徑切換\n\n現在我們要做一個簡易的登出按鈕，讓我們點擊時可以回到登入前的畫面。\n我們這邊示範就在登入後顯示的頁面上製作此按鈕。\n* 製作一顆按鈕，讓其點擊後觸發一個事件，事件為接取登出 API ，程式碼如下：\n```js\n methods: {\n    signout () {\n      const api = `驗證登出 api 網址`\n      const vm = this\n      this.$http.post(api).then((response) => {\n        console.log(response.data)\n      })\n    }\n  }\n```\n* 接著我們在事件裡新增一個判斷式，若驗證成功即回到登入前頁面，程式碼如下：\n```js\nmethods: {\n    signout () {\n      const api = `驗證登出 api 網址`\n      const vm = this\n      this.$http.post(api).then((response) => {\n        console.log(response.data)\n        if (response.data.success === true) {\n          vm.$router.push('/login')\n        }\n      })\n    }\n  }\n```\n\n## 導入導航守衛\n做到這裡登入前與登入後畫面已可正確切換，但這時會有個問題，即使使用者尚未登入，也可利用變更網址的方式，訪問登入後的頁面。\n我們這裡要介紹**利用導航守衛讓使用者無法不經過認證就訪問特定頁面**。\n**導航守衛的定義在於它會判斷我們要前往的頁面以及正要離開的頁面，如果要前往的頁面是需要認證的，它會等認證完後才開放通行 -- [導航守衛](https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%85%A8%E5%B1%80%E5%89%8D%E7%BD%AE%E5%AE%88%E5%8D%AB)**\n\n現在就來試著把剛剛完成的登入效果導入導航守衛吧。\n1. 決定我們需要認證才能進入的頁面，決定好後到 Vue.router 的配置檔(index.js)，在 routes 中找到該頁面加入`meta: { requiresAuth: true }`，讓系統知道此頁面是需要認證才能訪問(可參考[路由元訊息](https://router.vuejs.org/zh/guide/advanced/meta.html))。示範如下：\n```js\n{\n    path: '/',\n    name: 'HelloWorld',\n    component: HelloWorld,\n    meta: { requiresAuth: true }\n},\n```\n2. 來到我們的進入點(main.js)在裡面做全局的導航守衛部屬(可參考[全局守衛部屬](https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%85%A8%E5%B1%80%E5%89%8D%E7%BD%AE%E5%AE%88%E5%8D%AB))，程式碼如下：\n```js\nrouter.beforeEach((to, from, next) => {\n  if (to.meta.requiresAuth) {\n    const api = `檢視是否為登入狀態 api`\n    axios.post(api).then((response) => {\n      if (response.data.success === true) {\n        next()\n      } else {\n        next({\n            path: '/login'\n        })\n        // next(false)\n      }\n    })\n  } else {\n    next()\n  }\n})\n```\n這裡針對上方程式碼做解釋：\n* 參數解釋：\n    * `to` 代表我們將要前往的頁面\n    * `from` 代表我們將要離開的頁面\n    * `next` 決定是否前往的方法\n* 我們透過判斷式`if (to.meta.requiresAuth)`，判斷出當我們要前往的頁面是需要驗證時就接取 api，不需要則直接切換即可。\n* 這邊會發現接取 api 的程式碼有點不同，之前都是`this.$http.post(api)`，這裡變成`axios.post(api)`，原因是因為這時的環境是在 router 上，並不是像我們以往接取 api 時是在 Vue 的元件上，所以改成 `axios` 才能正常接取。\n* 第二個判斷式，用來判斷若後端 api 驗證為登入狀態就讓頁面切換，否則停留在登入前畫面，那停留畫面部分有兩種寫法，**一種是透過路徑的方式讓其重新導向登入前路徑，另一種是加入 false 中斷當前導覽並回到 from 的頁面**。\n\n## 避免使用者隨意改變網址導致跳轉到空白頁面\n若使用者在網址後面加入一些亂碼，會使頁面跳轉到空白的頁面去，為了避免這情況發生我們可以去配置檔(index.js)的 routes 加入以下程式碼：\n```js\n{\n    path: '*', //當路徑為其它不存在的路徑時\n    redirect: '/login' //重新導向此路徑(可自己定義)\n},\n```\n## 補充\n這邊要提醒一點，有些後端 API 可能會需要我們在接取 API 的同時，將後端的 Cookie 做儲存，並在最後接取 API 的同時，將 Cookie 傳至後端，才能完成 Ajax。\n那如果要儲存 Cookie 我們可以在我們的進入點(main.js)，加入 axios 提供的程式碼 `axios.defaults.withCredentials = true`。\n\n---\n\n## 參考資料\n[六角學院課程--Vue 出一個電商網站](https://www.hexschool.com/vue/)","tags":["E-commerce"],"categories":["Vue.js"]},{"title":"Vue.js 電商練習技術整理 -- 載入Bootsrap 4 套件，且自定義樣式","url":"%2F2019%2F07%2F29%2FEcommercePractice2%2F","content":"\n![](https://i.imgur.com/el9rgW2.jpg)\n\n## 文章目的\n藉由將 Bootstrap 4 套用到 Vue Cli 的專案裡，以方便後續開發 css 使用，並可將 Bootstrap 4 的預設樣式做修改，修改成專案所需樣式。\n<!--more-->\n## 載入 Bootstrap 4\n在我們的終端機或是命令提示字元， cd 到我們的專案路徑，輸入**npm install bootstrap --save**。\n安裝完成後，我們應該可以在 node_modules 資料夾底下看到 bootstrap 的資料夾。\n步驟進行到這邊，還不算完全安裝好，因為**我們並沒有支援 sass 的 loader，因此要再進行相關安裝**。\n這邊輸入**npm install node-sass sass-loader --save**，這樣子我們就完成載入 Bootstrap 囉。\n\n## 將 Bootstrap 4 套用到我們的專案上\n來到 App.vue 的 style，在標籤上加入 `lang=\"scss\"`，並在標籤內輸入 `@import '~bootstrap/scss/bootstrap'`，詳細程式碼如下：\n```scss\n<style lang=\"scss\">\n@import \"~bootstrap/scss/bootstrap\";\n</style>\n```\n\n## 自定義 Bootstrap 樣式\n若我們要自定義樣式，套用方式會跟上面有點差別。\n1. 來到 node_modules 底下的 bootstrap 資料夾，並在 scss 資料夾底下找到 _variables。\n在 assets 下新增一個 helpers 資料夾，將 _variables 另存新檔到 helpers 裡。\n2. 在 assets 資料夾下新增一個 all.scss 的檔案，在裡面載入檔案，程式碼如下：\n```scss\n@import \"~bootstrap/scss/functions\"; /*bootstrap 套用變數的方法，有它我們才能正確套用自定義變數*/\n@import \"./helpers/_variables\"; /*我們的自定義內容*/\n@import \"~bootstrap/scss/bootstrap\"; /*bootstrap 主套件*/\n```\n**這邊要注意一點在載入時3個的順序要如上方所示，此為 bootstrap 官方規定。**-- [規定內容](https://bootstrap.hexschool.com/docs/4.1/getting-started/theming/#importing)\n3. App.vue 的 style 載入方式也要做修改，程式碼如下：\n```scss\n<style lang=\"scss\">\n@import './assets/all' /*改成載入我們新建的all.scss*/\n</style>\n```\n4. 自定義示範\n載入完成後，我們就能來自定義自己要的樣式。\n打開我們另存的 _variables.scss，我們可以為裡面的變數做修改。\n像是 Bootstrap 4 預設 primary 顏色為藍色，這裡透過改變變數將其顏色改變，程式碼如下：\n```scss\n$theme-colors: map-merge(\n  (\n    \"primary\":    $purple, /*預設為$primary*/\n    \"secondary\":  $secondary,\n    \"success\":    $success,\n    \"info\":       $info,\n    \"warning\":    $warning,\n    \"danger\":     $danger,\n    \"light\":      $light,\n    \"dark\":       $dark\n  ),\n  $theme-colors\n); \n```\n我們只要套用相關 bootstrap 元件或是 className 就會發現 primary 變成紫色。\n這就是一個自定義內容的簡單範例。\n\n---\n\n## 參考資料\n[六角學院課程--Vue 出一個電商網站](https://www.hexschool.com/vue/)","tags":["E-commerce"],"categories":["Vue.js"]},{"title":"Vue.js 電商練習技術整理 -- 接取API與設定環境變數","url":"%2F2019%2F07%2F29%2FEcommercePractice1%2F","content":"\n![](https://i.imgur.com/el9rgW2.jpg)\n\n## 文章目的\n最近開始利用 Vue.js 實戰練習電商網站的開發，想藉由一系列的文章，來整理相關的重點技術。\n本篇重點為利用 Vue Cli 接取 API 並且將 API 設定為環境變數。\n<!--more-->\n## 環境檔案介紹\n一般來講，安裝完 Vue Cli 後，打開 config 資料夾，會看到裡面有3個環境設定檔。\n分別是：\n * index.js -- 針對整個環境進行編譯\n * dev.env.js -- 開發中的環境變數\n * prod.env.js -- 正式的環境變數\n\n那為什麼要特別分成開發中與正式版本呢？\n因為往往在**開發時接取的 API 路徑會與 正式版本不同**，因此我們可以透過兩個檔案分開各自定義環境變數，以方便操作。\n\n## Vue axios 安裝\n既然我們本次的重點是要接取 API，這邊提供一個接取 API 的套件 --- [Vue axios](https://www.npmjs.com/package/vue-axios)\n安裝與設置方面這邊就不多加敘述，連結的官方文件上都有說明。\n\n## 接取 API \n有了 Vue axios 後我們就可以開始接取 API。\n我們來到 App.vue，設定 created 時將 API 資料抓進來，程式碼如下：\n```js\n<script>\nexport default {\n  name: 'App',\n  created () {\n    const api = '輸入你的API網址'\n    this.$http.get(api).then((response) => {\n      console.log(response.data)\n    })\n  }\n}\n</script>\n```\n## 將 API 網址設定成環境變數\n用了上述方法接取 API 我們無法靈活的運用它，且無法讓它在開發環境與正式環境做區分。\n因此現在**我們要將 API 網址設定成環境變數，並透過呼叫變數來使用它**(本次範例設定在開發環境)。\n1. 我們來到 config 資料夾底下的 dev.env.js，宣告新的環境變數定義我們的 API 路徑，以下是程式碼：\n```js\nmodule.exports = merge(prodEnv, {\n  NODE_ENV: '\"development\"',\n  APIPATH: '\"你的 API 路徑\"',  //變數名稱可自己定義，一般來說都是用大寫英文命名\n})\n```\n**這邊有一點要注意，宣告的變數在插入路徑時，記得要再用一次引號包覆路徑。**\n2. 定義完環境變數後，我們回到 App.vue，將我們剛剛的路徑改成用環境變數，程式碼如下：\n```js\n<script>\nexport default {\n  name: 'App',\n  created () {\n    const api = `${process.env.APIPATH}`\n    this.$http.get(api).then((response) => {\n      console.log(response.data)\n    })\n  }\n}\n</script>\n```\n呼叫環境變數的方法：`process.env.環境變數`。\n\n---\n\n## 參考資料\n[六角學院課程--Vue 出一個電商網站](https://www.hexschool.com/vue/)","tags":["E-commerce"],"categories":["Vue.js"]},{"title":"The F2E Freecell Part 1","url":"%2F2019%2F07%2F25%2Ffreecell%2F","content":"\n![](https://i.imgur.com/ENE1GPj.png)\n\n## 文章目的\n有鑑於本周 THE F2E 的新接龍有許多邏輯方面的設計，想藉由本篇將開發邏輯記錄下來，另外也想嘗試發布部落格，因此將本篇當作第一篇文章。\n<!--more-->\n## 本次使用技術\n1. Bootsrap 4 \n2. Scss\n3. JavaScript 原生語法\n原本是想用 Vue 開發，後來覺得應該用原生語法也不致於太難，但做到一半就開始後悔怎麼沒有 Vue (因為方便好多XD)。\n這次使用原生語法就當作加強自己的觀念，也很感謝有**懷恩老師的直播開發流程**(文章最後會附上連結)，沒有老師的直播我應該會卡關到懷疑人生。\n\n## 新接龍初步分析\n新接龍規則部分我們這邊就不多加解釋，附上 [遊戲規則](https://zh.wikipedia.org/zh-tw/%E6%96%B0%E6%8E%A5%E9%BE%8D)。\n新接龍總共分為3塊遊戲區，分別是：\n1. 完成區(左上角，共4格)\n  * 只能同花色堆疊\n  * 數字要由小到大按順序堆疊\n  * 堆疊完成的牌不需要再被拖曳\n2. 暫存區(右上角，共4格)\n  * 每個空格只能存放一張卡片\n  * 空格裡的卡片可以再被拖曳至完成區或未整理區\n3. 未整理區(下方，共7排，左4排初始7張，右4排初始6張)\n  * 只能異色堆疊\n  * 數字要由小到大按順序堆疊\n  * 空排要能放牌且不限數字\n  * 此區卡片可以被拖曳至暫存區與完成區\n\n有了這樣初步的了解，我們可以開始來了解 JS 的語法。\n切版部分本文章不會提到，我是利用 Bootstrap 4 和一些 SCSS 來完成切版。\n\n## 變數宣告與各區域陣列分配\n首先，宣告一個變數來決定遊戲是否暫停，後續的一些功能處裡，暫停遊戲都會影響到，以下是程式碼：\n```js\nlet isgamePause = false;\n```\n我們可以將完成區看成一個區域，暫存區看成一個區域，未整理區看成一個區域，因此這裡變數可以這樣設計：\n```js\n    let finishArea = [[], [], [], []]; //完成區域左上角\n    \n    let temporaryArea = [[], [], [], []]; //卡片暫放區(每一格只能放一張)右上角\n    \n    let maingameArea = [ //未整理區共8排\n        [], //7張\n        [], //7張\n        [], //7張\n        [], //7張\n        [], //6張\n        [], //6張\n        [], //6張\n        [] //6張\n    ];\n```\n每個大區域就是一個陣列，每個大區域裡的每一個空格就是一個陣列。\n另外因為我是用 Bootstrap 4 的格線系統做排版，我為了方便設計，將未整理區又分為左右7張與6張兩區，變數宣告如下：\n```js\nlet cardbigGroup = [[], []];\n```\n\n## 隨機發牌\n接下來我們來設計隨機發牌，讓系統可以在遊戲開始時隨機發牌到未整理區的陣列裡，而且按照7張、6張的規則排列。\n* 撲克牌總共有52張，因此我們就用1\\~52的數字當作我們的牌，這裡我們宣告一個陣列將1\\~52的數字儲存進去。\n```js\n//利用 for 迴圈\n let pokerArr = []; \n    for (let i = 0; i < 52; i++) {\n        pokerArr.push(i + 1)\n    }\n\n//利用 Array.from 和 Array.map\nlet pokerArr =Array.from(new Array(52)).map(function(item,index){ \n    return index+1 \n})\n```\n* 接著要**將陣列的52個數字打亂**，這邊我用的方法是 shuffle，有關 shuffle 相關介紹可參考[**這篇**](http://shubo.io/javascript-random-shuffle/)，以下是程式碼。\n```js\n function shuffle(array) {\n        for (let i = array.length - 1; i > 0; i--) {\n            let j = Math.floor(Math.random() * (i + 1));\n            [array[i], array[j]] = [array[j], array[i]];\n        }\n        return array;\n    }\n\nlet pokerRandom = shuffle(pokerArr);\n```\n* 我們已成功打亂數字，接著就是要**將數字按照規則排列**，我們一開始宣告的`maingameArea`就派上用場了，我們可以按照規則將數字一一塞入`maingameArea`的陣列裡，以下是程式碼。\n```js\n function mainpokerArr() {\n        let randomarrNum = Math.floor(Math.random() * 8);\n        if (randomarrNum <= 3) {\n            if (maingameArea[randomarrNum].length >= 7) {\n                return mainpokerArr()\n            }\n        } else {\n            if (maingameArea[randomarrNum].length >= 6) {\n                return mainpokerArr()\n            }\n        }\n        return randomarrNum;\n    }\n```\n這段程式碼的想法是因為`maingameArea`總共有8個陣列，從左到右的索引號是0\\~7，因此我們利用`randomarrNum`來隨機選出一個索引號。\n透過判斷式讓索引號為0\\~3時陣列長度維持為7張，索引號為4\\~7時長度維持為6張。\n現在我們有了符合規則的發牌方法，接下來就要將牌一一放進陣列裡，以下是程式碼。\n```js\n pokerRandom.map(function (item) {\n        let runmainpokerArr = mainpokerArr();\n        maingameArea[runmainpokerArr].push(item);\n    });\n```\n這裡讓未整理區`maingameArea`透過我們剛剛設計的發牌函式`mainpokerArr()`將我們剛打亂的陣列`pokerRandom`裡的數字放入未整理區的8個陣列裡。\n這邊因為我自己的設計關係，我再把`maingameArea`裡的8個陣列，分為4個一組放入更大的陣列`cardbigGroup`，以下是程式碼。\n```js\n maingameArea.forEach(function (item, index) {\n        if (index <= 3) {\n            cardbigGroup[0].push(item);\n        } else {\n            cardbigGroup[1].push(item)\n        };\n    });\n```\n\n* 隨機發牌的資料都按照規則整理完畢了，我們接下來要做的就是**讓牌可以渲染到畫面上**。\n首先，因為我們的數字是1\\~52，但系統並不知道花色，因此我們要先來定義花色，以下是程式碼。\n```js\n function judgeColor(cardNum) {\n        if (cardNum >= 1 && cardNum <= 13) {  //1~13是黑桃\n            return 'spade'\n        } else if (cardNum >= 14 && cardNum <= 26) { //14~26是紅心\n            return 'heart'\n        } else if (cardNum >= 27 && cardNum <= 39) { //27~39是方塊\n            return 'diamond'\n        } else if (cardNum >= 40 && cardNum <= 52) { //40~52是梅花\n            return 'club'\n        }\n    };\n```\n花色也定義完成後，我們就要正式選渲染畫面，因為是原生語法關係，我們利用 `createElement` 和 `appendChild` 來做渲染，因為程式碼較多，先來看看完整程式碼，我再根據每個部份做解釋。\n```js\n    let gamingArea = document.getElementById('gamingArea');\n   function putCard() {\n        cardbigGroup.forEach(function (section, sectionNum) {\n            let cardbiggroupPart = document.createElement('div');\n            cardbiggroupPart.className = 'col-6 d-flex w-100';\n            gamingArea.appendChild(cardbiggroupPart);\n            section.forEach(function (item, index) {\n                let cardGroup = document.createElement('div');\n                cardGroup.className = 'relative w-100';\n                cardGroup.style.height = '600px'\n                cardGroup.group = index;\n                cardGroup.section = sectionNum;\n                cardbiggroupPart.appendChild(cardGroup)\n                item.forEach(function (el, num) {\n                    let oneCard = document.createElement('div');\n                    oneCard.className = 'cardArea absolute';\n                    if (!isRefresh) {\n                        oneCard.style.transition = 'all .3s'\n                        oneCard.style.top = '-1000px';\n                        oneCard.style.left = '-2000px';\n                        setTimeout(function () {\n                            oneCard.style.top = num * 30 + 'px';\n                            oneCard.style.left = '0px'\n                        }, index * num * 30)\n                    } else {\n                        oneCard.style.top = num * 30 + 'px';\n                        oneCard.style.left = '0px'\n                    }\n                    let cardImg = document.createElement('img');\n                    cardImg.draggable = false\n                    cardImg.card = el;\n                    cardImg.section = sectionNum;\n                    cardImg.group = index;\n                    cardImg.color = judgeColor(el)\n                    cardImg.src = `pokerimg/card-${judgeColor(el)}-${el % 13}.svg`;\n                    if (!isgamePause && num + 1 == item.length) {\n                        oneCard.draggable = true;\n                        cardImg.draggable = true\n                    }\n                    oneCard.appendChild(cardImg)\n                    cardGroup.appendChild(oneCard);\n                })\n               \n            })\n        });\n\n    };\n```\n```js\n let gamingArea = document.getElementById('gamingArea');\n   function putCard() {\n        cardbigGroup.forEach(function (section, sectionNum) {\n            let cardbiggroupPart = document.createElement('div');\n            cardbiggroupPart.className = 'col-6 d-flex w-100';\n            gamingArea.appendChild(cardbiggroupPart);\n```\n我利用 `getElementById`選取要做為未整理區最外層的 HTML 元素。\n宣告一個函式負責執行隨機發牌，接著我要一層一層的剝開我們的陣列往內進逼針對陣列裡的元素做設定。\n第一個陣列就是分為左右兩大區塊的`cardbigGroup`，讓兩塊區域都`createElement`區塊元素(`div`)出來，那因為我有使用格線來排版，所以為他們加了一些排版相關的`className`。\n接著就可以利用`appendChild`將我們創造出來的兩個區塊元素加入到`gamingArea`下方。\n```js\n  section.forEach(function (item, index) {\n                let cardGroup = document.createElement('div');\n                cardGroup.className = 'relative w-100';\n                cardGroup.style.height = '600px'\n                cardGroup.group = index;\n                cardGroup.section = sectionNum;\n                cardbiggroupPart.appendChild(cardGroup)\n```\n第二個碰到的陣列是各區底下的4塊小區域(7張牌與6張牌)，原理一樣我們為每塊區域創造區塊元素，並將入一些自定義的`className`和`style`。\n這邊比較重要的一點是**為每個區塊元素增加一些屬性來記錄它所在的位置(`group`,`section`)**，這些屬性將會在後面我們要製作拖曳效果時會用到。\n```js\n item.forEach(function (el, num) {\n                    let oneCard = document.createElement('div');\n                    oneCard.className = 'cardArea absolute';\n                    if (!isRefresh) {\n                        oneCard.style.transition = 'all .3s'\n                        oneCard.style.top = '-1000px';\n                        oneCard.style.left = '-2000px';\n                        setTimeout(function () {\n                            oneCard.style.top = num * 30 + 'px';\n                            oneCard.style.left = '0px'\n                        }, index * num * 30)\n                    } else {\n                        oneCard.style.top = num * 30 + 'px';\n                        oneCard.style.left = '0px'\n                    }\n```\n最後我們碰到的就是我們的主角--**撲克牌**，這邊一樣是為每張牌創建區塊元素，那因為我採用的設計稿是 **吳俊儀設計師的設計稿**，俊儀設計師很佛心的把每張牌做成svg，所以我待會只要把每張svg `appendChild`到每張牌的`div`底下就好。\n至於判斷式的部分，是設計遊戲開始時的卡片出現動畫，這邊我就不多加敘述，卡片排版方式是利用絕對定位，那`position:relative`的部分我是設定給上一層的8個小區塊。\n```js\n  let cardImg = document.createElement('img');\n                    cardImg.draggable = false\n                    cardImg.card = el;\n                    cardImg.section = sectionNum;\n                    cardImg.group = index;\n                    cardImg.color = judgeColor(el)\n                    cardImg.src = `pokerimg/card-${judgeColor(el)}-${el % 13}.svg`;\n                    if (!isgamePause && num + 1 == item.length) {\n                        oneCard.draggable = true;\n                        cardImg.draggable = true\n                    }\n                    oneCard.appendChild(cardImg)\n                    cardGroup.appendChild(oneCard);\n                })\n```\n這邊我們就來處理圖片的部分，為每個數字創造`img`標籤，`src`的部分我們可以透過命名與判斷顏色的函式(`judgeColor`)，來取得符合該數字的圖片。\n一樣的，我們玩遊戲時都會拖曳這些卡片，因此也在這為它新增一些屬性(**`card`,`section`,`group`,`color`**)，分別是**數字、所在的大區塊、所在的小區塊、花色**。\n另外一樣重要的就是**`draggable`，設定它`true`or`false`會決定該元素是否能拖曳**，那因為**遊戲規則只有最後一張牌可以拖曳**，因此額外增加判斷式來判斷該張卡片是否為最後一張牌。\n最後一樣`appendChild`至上一層元素中。\n\n## 結語\n恭喜你!! 做到這裡，你的新接龍已經可以隨機發牌並且渲染到畫面上了。\n也謝謝你，看完我的文章!! 這是我第一次用 hexo 建立部落格與寫文章，排版可能還有點拙劣，傷眼抱歉。\n有關後續的完成區、暫存區與拖曳效果，我會再利用時間補上。\n\n附上我的 [DEMO](https://hao1229.github.io/THE-F2E-Freecell/) 與 [程式碼](https://github.com/Hao1229/THE-F2E-Freecell)\n\n---\n\n## 參考資料\n[懷恩老師的開發直播](https://www.facebook.com/groups/173311386703334/permalink/364591804241957/)\n\n[shuffle 文章](http://shubo.io/javascript-random-shuffle/)\n\n[Ray大的新接龍文章](https://hsiangfeng.github.io/javascript/20190712/1140639545/?fbclid=IwAR37Iq2qAZjR5wMVfSOT_jMIidxlTGRElm3ATu0zm8Hmp9iwWd61uGRz_z)\n\n[吳俊儀設計師的設計稿](https://xd.adobe.com/spec/f01f6d09-be4f-4bf3-601d-7c817fe225ab-862e/grid)\n\n","tags":["THE F2E"],"categories":["THE F2E"]}]