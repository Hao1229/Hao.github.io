[{"title":"Vue.js 電商練習技術整理 -- event bus 元件間的溝通橋樑","url":"%2F2019%2F08%2F06%2FEcommercePractice7%2F","content":"\n![](https://i.imgur.com/el9rgW2.jpg)\n\n## 文章目的\n在我們開發 Vue 的專案時，每個元件檔案間都會有內外層的差別，例：一個 Root 下有兩個 side 每個 side 底下又有3個元件，當我們需要利用內層的資料來觸發外層的事件時，會需要一層一層的將資料向上傳遞，這會顯得較為麻煩，因此我們可以利用 event bus 的方式，直接將我們內層的資料傳遞給外層作使用。\n<!--more-->\n## event bus 簡介\nevent bus 的重點在於它可以幫我們把特定事件直接掛載到 Vue 的 原型下(Prototype)，元件間透過 **$on(監聽)**以及 **$emit(觸發)**兩種行為來達到內層觸發外層事件的效果。\n\n## 透過 event bus 將內層資料傳遞至外層觸發 alert 效果\n### 新增 alert 模板\n我們可以在 Vue Cli 的 components 資料夾底下新增一個 AlertMessage 的元件，並在裡面設計我們的 alert 模板。\n### 將 event bus 掛載到原型上\n掛載到原型上的目的是為了讓所有元件皆能使用。\n在 Vue Cli 的 src 資料夾底下新增一個 bus.js 並在裡面輸入以下程式碼以完成掛載：\n```js\nimport Vue from 'vue'\n\nVue.prototype.$bus = new Vue()  //$bus 為自訂義的名稱可以自行命名，建議要加上$\n```\n接著我們在進入點(main.js)下 import 這隻檔案進來。\n```js\nimport './bus'\n```\n### 在 AlertMessage 元件下做監聽\n因為我們要讓底層元件觸發 event bus 時， event bus 會將相關資料傳遞到 AlertMessage 做使用，所以我們在 AlertMessage 中加入 event bus 的監聽，程式碼如下：\n```js\n  created () {\n    const vm = this\n    // 自定義名稱 'messsage:push'\n    // message: 傳入參數\n    // status: 樣式，預設值為 warning\n    vm.$bus.$on('message:push', (message, status = 'warning') => {\n      vm.updateMessage(message, status)\n    }\n  }\n}\n```\n主要監聽時會有幾個屬性與參數可以做設定，自定義的名稱以及監聽的參數，**基本上參數就會是內層傳遞上來的資料**，接著可以將這些資料參數套用到元件內的其他 methods 中。\n像在本次範例中將參數傳遞給 `updateMessage` 做使用，以下附上完整程式碼：\n```js\nexport default {\n  name: 'Navbar',\n  data () {\n    return {\n      messages: []\n    }\n  },\n  methods: {\n    updateMessage (message, status) {\n      const timestamp = Math.floor(new Date() / 1000)\n      this.messages.push({  //以下3個數值會影響到 alert 顯示結果\n        message,  //alert 顯示的訊息\n        status,  //alert 的顏色\n        timestamp  //alert 的 id\n      })\n      this.removeMessageWithTiming(timestamp)\n    },\n    //手動關閉 alert \n    removeMessage (num) {\n      this.messages.splice(num, 1)\n    },\n    //讓訊息顯示後5秒自動消失\n    removeMessageWithTiming (timestamp) {\n      const vm = this\n      setTimeout(() => {\n        vm.messages.forEach((item, i) => {\n          if (item.timestamp === timestamp) {\n            vm.messages.splice(i, 1)\n          }\n        })\n      }, 5000)\n    }\n  },\n  created () {\n    const vm = this\n    vm.$bus.$on('message:push', (message, status = 'warning') => {\n      vm.updateMessage(message, status)\n    })\n  }\n}\n```\n完成 alert 部分的設定後我們可以將此元件 import 進要顯示訊息的 Dashboard 元件下。\n```js\nimport Alert from './AlertMessage'\nexport default {\n  components: {\n    Alert\n  }\n} \n```\n要記得將元件加入 HTML 裡。\n```html\n<template>\n    <div>\n        <Navbar/>\n        <Alert></Alert>\n        <div class=\"container-fluid\">\n            <div class=\"row\">\n                <Sidebar></Sidebar>\n            <main role=\"main\" class=\"col-md-9 ml-sm-auto col-lg-10 px-4\">\n                <router-view></router-view>\n            </main>\n            </div>\n        </div>\n    </div>\n </template>\n```\n### 在內層的 Products 元件上新增 event bus 的觸發事件\n透過 ajax 的失敗，觸發 event bus 將相關參數傳遞給 AlertMessage，以下是程式碼：\n```js\n      this.$http.post(url, formData, {\n        headers: {\n          'Content-Type': 'multipart/form-data'\n        }\n      }).then((response) => {\n        console.log(response.data)\n        if (response.data.success) {\n          vm.status.fileUploading = false\n          vm.$set(vm.tempProduct, 'imageUrl', response.data.imageUrl)\n        } else {\n          this.$bus.$emit('message:push', response.data.message, 'danger')\n        }\n      })\n    }\n```\n我們在之前 formData 上傳圖片的事件中，新增若上傳失敗就觸發 `message:push` 並根據我們當初自訂的格式回傳相關參數。\n當 AlertMessage 收到我們回傳的參數時，就會根據這些參數去渲染 alert 效果。\n## 小技巧補充\n有時候我們在定義 event bus 的事件名稱及相關參數時會忘記是在哪個元件上做定義，因此我們可以利用註解的方式，將我們的定義方法寫在 bus.js 裡以方便了解。\n最後，小提醒 **event bus 在管理上會有些問題，能的話盡量使用在較不複雜的網頁結構上**。\n\n---\n\n## 參考資料\n[六角學院課程--Vue 出一個電商網站](https://www.hexschool.com/vue/)\n","tags":["E-commerce"],"categories":["Vue.js"]},{"title":"Vue.js 電商練習技術整理 -- 製作讀取動畫增加使用者體驗","url":"%2F2019%2F08%2F05%2FEcommercePractice6%2F","content":"\n![](https://i.imgur.com/el9rgW2.jpg)\n\n## 文章目的\n我們時常在逛其他網站時，讀取過程中會看到一些動畫呈現，此文章用來記錄在用 Vue 開發網站時，如何製作同樣的動畫效果。\n<!--more-->\n\n## 方法簡介\n1. 套用 vue-loading-overlay 套件達到效果 --- [vue-loading-overlay官方文件](https://www.npmjs.com/package/vue-loading-overlay)\n2. 利用 FontAwesome 提供的 loading 圖案達到效果 ---[FontAwesome Loading](https://fontawesome.com/how-to-use/on-the-web/styling/animating-icons)\n\n## vue-loading-overlay\n這是一個 vue 的套件，透過安裝此套件我們可以輕易地呈現 loading 效果。\n### vue-loading-overlay 安裝\n這邊我們透過 npm 的方式來安裝此套件\n`npm install vue-loading-overlay --save`\n\n透過此套件的官方文件，我們可以得知它有兩種使用方式：\n1. 透過 Component 方式載入。\n2. 透過 Plugin 方式載入。\n本次範例將以 Component 方式載入做講解。\n\n### vue-loading-overlay 載入\n我們先來到 Vue Cli 的進入點(main.js)，import 以下兩支檔案：\n```js\nimport Loading from 'vue-loading-overlay' //component\nimport 'vue-loading-overlay/dist/vue-loading.css' //style\n```\n利用 component 方法做載入：\n```js\nVue.component('Loading', Loading)\n```\n進行到這裡，我們已完成全域的 loading 設定，接下來就可以在需要 loading 的頁面上做載入。\n\n### 載入 loading 特效\n將此 loading 模板放入元件最外層的 div 底下(**這樣才能將效果套用到整個元件頁面上，若只需要部份做套用可以僅放在需套用的區塊內即可。**)，程式碼如下：\n```html\n<div>\n    <loading :active.sync=\"isLoading\"></loading>\n</div>\n```\n這是最基本的模板，`isLoading`負責控制效果是否出現，**若要自訂效果或是增加一些控制屬性，可參考[這篇文章](https://ithelp.ithome.com.tw/articles/10209705)**\n進行到這裡我們的頁面已會正確的出現效果，那如果要控制出現在效果的時機，我們可以透過 `isLoading` 的操作來控制。\n\n### 控制 loading 出現時機\n以範例來講，我們可以先在 data 的部分宣告我們的變數 `isLoading = false`，讓 loading 效果一開始是隱藏的，當 ajax 執行時觸發 loading 效果，並在 ajax 成功時，結束 loading 效果，程式碼如下：\n```js\nexport default {\n  data () {\n    return {\n      products: [],\n      isLoading: false\n    }\n  },\n  methods: {\n    getProducts () {\n      const api = `你的 api 路徑`\n      const vm = this\n      vm.isLoading = true //正在執行 ajax 時 isLoading = true 觸發效果\n      this.$http.get(api).then(response => {\n        console.log(response.data)\n        vm.isLoading = false //ajax結束時，isLoading = false 結束效果\n        vm.products = response.data.products\n      })\n    },\n```\n## FontAwesome 載入動畫效果\n### 將 FontAwesome 引用置專案中\n有兩種方法可以將FontAwesome引用：\n1. cdn 方式\n2. npm 安裝\ncdn 方式這邊就不多加說明，我們來稍微解釋一下如何透過 npm 載入。\n我們先在終端機上輸入以下指令：\n`npm install --save-dev @fortawesome/fontawesome-free`\n待安裝完畢我們會在 node_modules 資料夾底下看到 **@fortawesome**，這代表安裝完成。\n接著我們要載入它，先來到需要使用的元件下將下列程式碼加入該元件的 `style` 裡。\n```css\n<style>\n  @import url(\"@fortawesome/fontawesome-free/css/all.css\");\n</style>\n```\n### 使用 FontAwesome 動畫 icons\nFontAwesome 官網中的文件有提到一種 Animating icons，只要加入此 icon 就會有動畫載入的效果 --- [Animating icons](https://fontawesome.com/how-to-use/on-the-web/styling/animating-icons)。\n當然我們也可以控制 icons 的出現時機，方法和 vue-loading-overlay 相似，只是這邊我們是用 v-if 的方式來做，以下是程式碼：\n```html\n<i class=\"fas fa-spinner fa-spin\" v-if=\"status.fileUploading\"></i>\n```\n我們在 data 內宣告一個變數負責判斷 icons 的出現。\n```js\nexport default {\n  data () {\n    return {\n      status: {\n        fileUploading: false\n      }\n    }\n  }\n```\n最後一樣的可以根據事件的觸發來改變 `this.status.fileUploading` 的布林數，進而觸發 icons 的顯示與隱藏。\n**最後有一點要補充，還是會建議 FontAwesome 載入效果主要用在局部，若要全局效果還是會建議使用 vue-loading-overlay**\n\n---\n\n## 參考資料\n[六角學院課程--Vue 出一個電商網站](https://www.hexschool.com/vue/)\n[JB大的文章](https://ithelp.ithome.com.tw/articles/10209705)","tags":["E-commerce"],"categories":["Vue.js"]},{"title":"Vue.js 電商練習技術整理 -- 使用 FormData 上傳圖片的眉眉角角","url":"%2F2019%2F08%2F01%2FEcommercePractice5%2F","content":"\n![](https://i.imgur.com/el9rgW2.jpg)\n\n## 文章目的\n有時候我們會需要將圖片上傳至後端做儲存，上傳時可利用 FormData 作為圖片的資料格式。\n本篇將介紹如何操作 Vue Cli 上傳圖片的細節。\n<!--more-->\n\n## FormData 簡單介紹\nFormData 是一個表單格式，我們可以利用它將資料轉成表單的格式，並且以表單的形式回傳給後端。 ---[FormData介紹](https://developer.mozilla.org/zh-TW/docs/Web/API/FormData)\n**至於上傳圖片時需不需要用 FormData 的形式上傳，是由後端來做決定。**\n\n## 將圖片轉換成 FormData \n* 首先，我們會利用 html 的 `<input type=\"file\">` 來上傳我們的圖片，我們可以為 input 新增一個 change 事件，程式碼如下：\n```html\n <input type=\"file\" @change=\"uploadFile\"/>\n```\n* 接著我們可以透過 `console.log` 的方式來找到我們要上傳的圖片所在位置，程式碼如下：\n```js\n uploadFile () {\n      console.log(this)\n }\n```\n經觀察後會發現圖片是以陣列的形式存在 **$refs.files.files** 下。\n* 先宣告一個變數來儲存我們找到的圖片\n```js\nconst uploadedFile = this.$refs.files.files[0] //這邊可根據需求決定是抓哪一張圖片或是整個陣列\n```\n* 進行到這裡我們就可以把圖片轉換成 FromData，先宣告一個變數是我們的 `new FormData()`，接著我們利用 `append` 的方式將我們的圖片塞入，程式碼如下：\n```js\nconst formData = new FormData()\nformData.append('資料屬性(根據後端決定)', uploadedFile)\n```\n## 接取 API 與渲染上傳的圖片\n* 已成功擁有一個 FormData，接著我們就可以把 FormData 透過 API 傳給後端，那因為是以 FormData的格式傳送，跟之前以物件的形式不同，所以我們需要更改傳遞格式，程式碼如下：\n```js\n const url = `API 路徑`\n      this.$http.post(url, formData, {\n        headers: {\n          'Content-Type': 'multipart/form-data' //更改成 FormData 的格式\n        }\n```\n* \n接著後續就可以針對成功回傳後做操作，像是範例這邊我們為了讓上傳成功的圖片能在畫面上呈現，因此我們需要將圖片的連結存在本地端，程式碼如下：\n```js\n  if (response.data.success) {\n          vm.$set(vm.tempProduct, 'imageUrl', response.data.imageUrl)\n        }\n```\n這邊有一點要注意，**因為用平常的方法`vm.tempProduct.imgUrl = response.data.imgUrl` 無法正確地將路徑儲存**，因此我們**改成用`$set` 的方式強制將路徑加入**。\n另外 html 方面就可以有一個 `img` 標籤 `src` 動態綁定我們上傳的圖片路徑。\n```html\n<img :src=\"tempProduct.imageUrl\">\n```\n最後附上完整的事件程式碼：\n```js\n   uploadFile () {\n      console.log(this)\n      const uploadedFile = this.$refs.files.files[0]\n      const vm = this\n      const formData = new FormData()\n      formData.append('資料屬性(根據後端決定)', uploadedFile)\n      const url = `上傳的 API 路徑`\n      this.$http.post(url, formData, {\n        headers: {\n          'Content-Type': 'multipart/form-data'\n        }\n      }).then((response) => {\n        if (response.data.success) {\n          vm.$set(vm.tempProduct, 'imageUrl', response.data.imageUrl)\n        }\n      })\n    }\n```\n\n---\n\n## 參考資料\n[六角學院課程--Vue 出一個電商網站](https://www.hexschool.com/vue/)","tags":["E-commerce"],"categories":["Vue.js"]},{"title":"Vue.js 電商練習技術整理 -- 導入 Bootstrap 與 jQuery","url":"%2F2019%2F07%2F30%2FEcommercePractice4%2F","content":"\n![](https://i.imgur.com/el9rgW2.jpg)\n\n## 文章目的\n為了讓 Vue Cli 能正常使用 Bootstrap 4 的 jQuery 相關功能，本文用來記錄導入流程。\n<!--more-->\n## 本次示範\n本次要用來導入的是 Bootstrap 4 的 Modal 元件，那因為 Modal 會需要利用到 jQuery 來達到效果，因此我們需要先正確的導入 Bootstrap 4 的 js 檔案與 jQuery。---[Modal元件官方文件](https://bootstrap.hexschool.com/docs/4.2/components/modal/#modalshow)\n\n## 導入 Bootstrap 4 js 檔與 jQuery\n我們先到進入點(main.js)，將 Bootstrap 4 js 檔 `import` 進來，程式碼如下：\n```js\nimport Vue from 'vue'\nimport axios from 'axios'\nimport VueAxios from 'vue-axios'\nimport 'bootstrap'\nimport App from './App'\nimport router from './router'\n```\n**這邊要記得 `import` 的順序自定義檔案都要放在最後。**\n接著我們來到需要引用 Modal 的頁面(Vue檔)，在 `<script>` 標籤上做以下操作：\n```js\nimport $ from 'jquery' //需使用元件導入(區域)\n```\n**此為區域的引入，引入的 jQuery 僅有在該元件能使用**，若想要全域引用可以在 main.js 加入以下程式碼：\n```js\nimport 'jquery' //main.js導入(全域)\n```\n**這邊有一點要注意，若有使用 ESlint 會顯示不建議在全域導入**，因此需額外加入以下程式碼：\n```js\n/* global $ */ //main.js導入(全域)\n```\n最後，我們將 Bootstrap 4 的 Modal 元件程式碼放入需使用的 Vue 元件內即可。\n\n## 透過事件觸發顯示 Modal\n我們這邊要稍微修改一下 Modal 的啟動方式，一般來講僅需要按鈕有對應的 Modal id 就可以啟動它。\n那會要改寫成觸發事件是因為，這樣可以更靈活地顯示 Modal，如遇到需要接取 API 時可以讓 API 資料確定接收後再顯示 Modal。\n這邊我們僅改成利用點擊觸發事件，如需要其他觸發方法可再自行更改。\n* 先在要觸發事件的按鈕上增加點擊事件，程式碼如下：\n```html\n <button class=\"btn btn-primary\" @click.prevent=\"openModal\">建立新的產品</button>\n```\n* 接著建立我們的 `methods`，程式碼如下：\n```js\n methods: {\n    openModal () {\n      $('#productModal').modal('show')\n    }\n  },\n```\n有關程式碼可參考官方文件 ---[Modal show](https://bootstrap.hexschool.com/docs/4.2/components/modal/#modalshow)\n\n---\n\n## 參考資料\n[六角學院課程--Vue 出一個電商網站](https://www.hexschool.com/vue/)","tags":["E-commerce"],"categories":["Vue.js"]},{"title":"Vue.js 電商練習技術整理 -- 登入簡易路徑切換","url":"%2F2019%2F07%2F30%2FEcommercePractice3%2F","content":"\n![](https://i.imgur.com/el9rgW2.jpg)\n\n## 文章目的\n一般電商都會有登入畫面，當登入成功時會有畫面路徑的切換，本文用來記錄 Vue Cli 製作此方法流程。\n<!--more-->\n\n## 基本概念\n* 在登入頁面中透過接取後端驗證 API 來認證使用者的帳號密碼，若驗證成功就變更路徑至其他頁面。\n* 其他頁面具有登出功能，透過後端登出 API 將使用者帳號登出，並使路徑跳轉至登入前畫面。\n* 需登入才能進入的頁面，在尚未登入時不能隨意進入。\n\n## 驗證帳號 API 接取與路徑切換\n* 我們可以在 components 資料夾底下新增一個 pages 資料夾，並在裡面新增一個 Login.vue 檔。\n* 在 Login.vue 檔中切出需要的登入版型，並透過 v-model 方式將使用者輸入的帳號密碼做雙向綁定，程式碼如下：\n```js\n data () {\n    return {\n      user: {\n        username: '',\n        password: ''\n      }\n    }\n  },\n```\n**這邊 data 裡的格式，根據驗證 api 要求的格式來設定。**\n* 我們為登入的版型製作一個 submit 的事件來觸發驗證 API，事件方法如下：\n```js\n methods: {\n    signin: function () {\n      const api = `驗證的 api 網址`\n      const vm = this\n      this.$http.post(api, vm.user).then((response) => {\n        if (response.data.success === true) {\n          vm.$router.push('/')\n        }\n      })\n    }\n  }\n```\n我們利用 `post` 回傳使用者資料(user)給後端，利用判斷式判斷後端回傳成功與否來決定路徑是否切換。\n\n## 登出驗證與路徑切換\n\n現在我們要做一個簡易的登出按鈕，讓我們點擊時可以回到登入前的畫面。\n我們這邊示範就在登入後顯示的頁面上製作此按鈕。\n* 製作一顆按鈕，讓其點擊後觸發一個事件，事件為接取登出 API ，程式碼如下：\n```js\n methods: {\n    signout () {\n      const api = `驗證登出 api 網址`\n      const vm = this\n      this.$http.post(api).then((response) => {\n        console.log(response.data)\n      })\n    }\n  }\n```\n* 接著我們在事件裡新增一個判斷式，若驗證成功即回到登入前頁面，程式碼如下：\n```js\nmethods: {\n    signout () {\n      const api = `驗證登出 api 網址`\n      const vm = this\n      this.$http.post(api).then((response) => {\n        console.log(response.data)\n        if (response.data.success === true) {\n          vm.$router.push('/login')\n        }\n      })\n    }\n  }\n```\n\n## 導入導航守衛\n做到這裡登入前與登入後畫面已可正確切換，但這時會有個問題，即使使用者尚未登入，也可利用變更網址的方式，訪問登入後的頁面。\n我們這裡要介紹**利用導航守衛讓使用者無法不經過認證就訪問特定頁面**。\n**導航守衛的定義在於它會判斷我們要前往的頁面以及正要離開的頁面，如果要前往的頁面是需要認證的，它會等認證完後才開放通行 -- [導航守衛](https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%85%A8%E5%B1%80%E5%89%8D%E7%BD%AE%E5%AE%88%E5%8D%AB)**\n\n現在就來試著把剛剛完成的登入效果導入導航守衛吧。\n1. 決定我們需要認證才能進入的頁面，決定好後到 Vue.router 的配置檔(index.js)，在 routes 中找到該頁面加入`meta: { requiresAuth: true }`，讓系統知道此頁面是需要認證才能訪問(可參考[路由元訊息](https://router.vuejs.org/zh/guide/advanced/meta.html))。示範如下：\n```js\n{\n    path: '/',\n    name: 'HelloWorld',\n    component: HelloWorld,\n    meta: { requiresAuth: true }\n},\n```\n2. 來到我們的進入點(main.js)在裡面做全局的導航守衛部屬(可參考[全局守衛部屬](https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%85%A8%E5%B1%80%E5%89%8D%E7%BD%AE%E5%AE%88%E5%8D%AB))，程式碼如下：\n```js\nrouter.beforeEach((to, from, next) => {\n  if (to.meta.requiresAuth) {\n    const api = `檢視是否為登入狀態 api`\n    axios.post(api).then((response) => {\n      if (response.data.success === true) {\n        next()\n      } else {\n        next({\n            path: '/login'\n        })\n        // next(false)\n      }\n    })\n  } else {\n    next()\n  }\n})\n```\n這裡針對上方程式碼做解釋：\n* 參數解釋：\n    * `to` 代表我們將要前往的頁面\n    * `from` 代表我們將要離開的頁面\n    * `next` 決定是否前往的方法\n* 我們透過判斷式`if (to.meta.requiresAuth)`，判斷出當我們要前往的頁面是需要驗證時就接取 api，不需要則直接切換即可。\n* 這邊會發現接取 api 的程式碼有點不同，之前都是`this.$http.post(api)`，這裡變成`axios.post(api)`，原因是因為這時的環境是在 router 上，並不是像我們以往接取 api 時是在 Vue 的元件上，所以改成 `axios` 才能正常接取。\n* 第二個判斷式，用來判斷若後端 api 驗證為登入狀態就讓頁面切換，否則停留在登入前畫面，那停留畫面部分有兩種寫法，**一種是透過路徑的方式讓其重新導向登入前路徑，另一種是加入 false 中斷當前導覽並回到 from 的頁面**。\n\n## 避免使用者隨意改變網址導致跳轉到空白頁面\n若使用者在網址後面加入一些亂碼，會使頁面跳轉到空白的頁面去，為了避免這情況發生我們可以去配置檔(index.js)的 routes 加入以下程式碼：\n```js\n{\n    path: '*', //當路徑為其它不存在的路徑時\n    redirect: '/login' //重新導向此路徑(可自己定義)\n},\n```\n\n---\n\n## 參考資料\n[六角學院課程--Vue 出一個電商網站](https://www.hexschool.com/vue/)","tags":["E-commerce"],"categories":["Vue.js"]},{"title":"Vue.js 電商練習技術整理 -- 載入Bootsrap 4 套件，且自定義樣式","url":"%2F2019%2F07%2F29%2FEcommercePractice2%2F","content":"\n![](https://i.imgur.com/el9rgW2.jpg)\n\n## 文章目的\n藉由將 Bootstrap 4 套用到 Vue Cli 的專案裡，以方便後續開發 css 使用，並可將 Bootstrap 4 的預設樣式做修改，修改成專案所需樣式。\n<!--more-->\n## 載入 Bootstrap 4\n在我們的終端機或是命令提示字元， cd 到我們的專案路徑，輸入**npm install bootstrap --save**。\n安裝完成後，我們應該可以在 node_modules 資料夾底下看到 bootstrap 的資料夾。\n步驟進行到這邊，還不算完全安裝好，因為**我們並沒有支援 sass 的 loader，因此要再進行相關安裝**。\n這邊輸入**npm install node-sass sass-loader --save**，這樣子我們就完成載入 Bootstrap 囉。\n\n## 將 Bootstrap 4 套用到我們的專案上\n來到 App.vue 的 style，在標籤上加入 `lang=\"scss\"`，並在標籤內輸入 `@import '~bootstrap/scss/bootstrap'`，詳細程式碼如下：\n```scss\n<style lang=\"scss\">\n@import \"~bootstrap/scss/bootstrap\";\n</style>\n```\n\n## 自定義 Bootstrap 樣式\n若我們要自定義樣式，套用方式會跟上面有點差別。\n1. 來到 node_modules 底下的 bootstrap 資料夾，並在 scss 資料夾底下找到 _variables。\n在 assets 下新增一個 helpers 資料夾，將 _variables 另存新檔到 helpers 裡。\n2. 在 assets 資料夾下新增一個 all.scss 的檔案，在裡面載入檔案，程式碼如下：\n```scss\n@import \"~bootstrap/scss/functions\"; /*bootstrap 套用變數的方法，有它我們才能正確套用自定義變數*/\n@import \"./helpers/_variables\"; /*我們的自定義內容*/\n@import \"~bootstrap/scss/bootstrap\"; /*bootstrap 主套件*/\n```\n**這邊要注意一點在載入時3個的順序要如上方所示，此為 bootstrap 官方規定。**-- [規定內容](https://bootstrap.hexschool.com/docs/4.1/getting-started/theming/#importing)\n3. App.vue 的 style 載入方式也要做修改，程式碼如下：\n```scss\n<style lang=\"scss\">\n@import './assets/all' /*改成載入我們新建的all.scss*/\n</style>\n```\n4. 自定義示範\n載入完成後，我們就能來自定義自己要的樣式。\n打開我們另存的 _variables.scss，我們可以為裡面的變數做修改。\n像是 Bootstrap 4 預設 primary 顏色為藍色，這裡透過改變變數將其顏色改變，程式碼如下：\n```scss\n$theme-colors: map-merge(\n  (\n    \"primary\":    $purple, /*預設為$primary*/\n    \"secondary\":  $secondary,\n    \"success\":    $success,\n    \"info\":       $info,\n    \"warning\":    $warning,\n    \"danger\":     $danger,\n    \"light\":      $light,\n    \"dark\":       $dark\n  ),\n  $theme-colors\n); \n```\n我們只要套用相關 bootstrap 元件或是 className 就會發現 primary 變成紫色。\n這就是一個自定義內容的簡單範例。\n\n---\n\n## 參考資料\n[六角學院課程--Vue 出一個電商網站](https://www.hexschool.com/vue/)","tags":["E-commerce"],"categories":["Vue.js"]},{"title":"Vue.js 電商練習技術整理 -- 接取API與設定環境變數","url":"%2F2019%2F07%2F29%2FEcommercePractice1%2F","content":"\n![](https://i.imgur.com/el9rgW2.jpg)\n\n## 文章目的\n最近開始利用 Vue.js 實戰練習電商網站的開發，想藉由一系列的文章，來整理相關的重點技術。\n本篇重點為利用 Vue Cli 接取 API 並且將 API 設定為環境變數。\n<!--more-->\n## 環境檔案介紹\n一般來講，安裝完 Vue Cli 後，打開 config 資料夾，會看到裡面有3個環境設定檔。\n分別是：\n * index.js -- 針對整個環境進行編譯\n * dev.env.js -- 開發中的環境變數\n * prod.env.js -- 正式的環境變數\n\n那為什麼要特別分成開發中與正式版本呢？\n因為往往在**開發時接取的 API 路徑會與 正式版本不同**，因此我們可以透過兩個檔案分開各自定義環境變數，以方便操作。\n\n## Vue axios 安裝\n既然我們本次的重點是要接取 API，這邊提供一個接取 API 的套件 --- [Vue axios](https://www.npmjs.com/package/vue-axios)\n安裝與設置方面這邊就不多加敘述，連結的官方文件上都有說明。\n\n## 接取 API \n有了 Vue axios 後我們就可以開始接取 API。\n我們來到 App.vue，設定 created 時將 API 資料抓進來，程式碼如下：\n```js\n<script>\nexport default {\n  name: 'App',\n  created () {\n    const api = '輸入你的API網址'\n    this.$http.get(api).then((response) => {\n      console.log(response.data)\n    })\n  }\n}\n</script>\n```\n## 將 API 網址設定成環境變數\n用了上述方法接取 API 我們無法靈活的運用它，且無法讓它在開發環境與正式環境做區分。\n因此現在**我們要將 API 網址設定成環境變數，並透過呼叫變數來使用它**(本次範例設定在開發環境)。\n1. 我們來到 config 資料夾底下的 dev.env.js，宣告新的環境變數定義我們的 API 路徑，以下是程式碼：\n```js\nmodule.exports = merge(prodEnv, {\n  NODE_ENV: '\"development\"',\n  APIPATH: '\"你的 API 路徑\"',  //變數名稱可自己定義，一般來說都是用大寫英文命名\n})\n```\n**這邊有一點要注意，宣告的變數在插入路徑時，記得要再用一次引號包覆路徑。**\n2. 定義完環境變數後，我們回到 App.vue，將我們剛剛的路徑改成用環境變數，程式碼如下：\n```js\n<script>\nexport default {\n  name: 'App',\n  created () {\n    const api = `${process.env.APIPATH}`\n    this.$http.get(api).then((response) => {\n      console.log(response.data)\n    })\n  }\n}\n</script>\n```\n呼叫環境變數的方法：`process.env.環境變數`。\n\n---\n\n## 參考資料\n[六角學院課程--Vue 出一個電商網站](https://www.hexschool.com/vue/)","tags":["E-commerce"],"categories":["Vue.js"]},{"title":"The F2E Freecell Part 1","url":"%2F2019%2F07%2F25%2Ffreecell%2F","content":"\n![](https://i.imgur.com/ENE1GPj.png)\n\n## 文章目的\n有鑑於本周 THE F2E 的新接龍有許多邏輯方面的設計，想藉由本篇將開發邏輯記錄下來，另外也想嘗試發布部落格，因此將本篇當作第一篇文章。\n<!--more-->\n## 本次使用技術\n1. Bootsrap 4 \n2. Scss\n3. JavaScript 原生語法\n原本是想用 Vue 開發，後來覺得應該用原生語法也不致於太難，但做到一半就開始後悔怎麼沒有 Vue (因為方便好多XD)。\n這次使用原生語法就當作加強自己的觀念，也很感謝有**懷恩老師的直播開發流程**(文章最後會附上連結)，沒有老師的直播我應該會卡關到懷疑人生。\n\n## 新接龍初步分析\n新接龍規則部分我們這邊就不多加解釋，附上 [遊戲規則](https://zh.wikipedia.org/zh-tw/%E6%96%B0%E6%8E%A5%E9%BE%8D)。\n新接龍總共分為3塊遊戲區，分別是：\n1. 完成區(左上角，共4格)\n  * 只能同花色堆疊\n  * 數字要由小到大按順序堆疊\n  * 堆疊完成的牌不需要再被拖曳\n2. 暫存區(右上角，共4格)\n  * 每個空格只能存放一張卡片\n  * 空格裡的卡片可以再被拖曳至完成區或未整理區\n3. 未整理區(下方，共7排，左4排初始7張，右4排初始6張)\n  * 只能異色堆疊\n  * 數字要由小到大按順序堆疊\n  * 空排要能放牌且不限數字\n  * 此區卡片可以被拖曳至暫存區與完成區\n\n有了這樣初步的了解，我們可以開始來了解 JS 的語法。\n切版部分本文章不會提到，我是利用 Bootstrap 4 和一些 SCSS 來完成切版。\n\n## 變數宣告與各區域陣列分配\n首先，宣告一個變數來決定遊戲是否暫停，後續的一些功能處裡，暫停遊戲都會影響到，以下是程式碼：\n```js\nlet isgamePause = false;\n```\n我們可以將完成區看成一個區域，暫存區看成一個區域，未整理區看成一個區域，因此這裡變數可以這樣設計：\n```js\n    let finishArea = [[], [], [], []]; //完成區域左上角\n    \n    let temporaryArea = [[], [], [], []]; //卡片暫放區(每一格只能放一張)右上角\n    \n    let maingameArea = [ //未整理區共8排\n        [], //7張\n        [], //7張\n        [], //7張\n        [], //7張\n        [], //6張\n        [], //6張\n        [], //6張\n        [] //6張\n    ];\n```\n每個大區域就是一個陣列，每個大區域裡的每一個空格就是一個陣列。\n另外因為我是用 Bootstrap 4 的格線系統做排版，我為了方便設計，將未整理區又分為左右7張與6張兩區，變數宣告如下：\n```js\nlet cardbigGroup = [[], []];\n```\n\n## 隨機發牌\n接下來我們來設計隨機發牌，讓系統可以在遊戲開始時隨機發牌到未整理區的陣列裡，而且按照7張、6張的規則排列。\n* 撲克牌總共有52張，因此我們就用1\\~52的數字當作我們的牌，這裡我們宣告一個陣列將1\\~52的數字儲存進去。\n```js\n//利用 for 迴圈\n let pokerArr = []; \n    for (let i = 0; i < 52; i++) {\n        pokerArr.push(i + 1)\n    }\n\n//利用 Array.from 和 Array.map\nlet pokerArr =Array.from(new Array(52)).map(function(item,index){ \n    return index+1 \n})\n```\n* 接著要**將陣列的52個數字打亂**，這邊我用的方法是 shuffle，有關 shuffle 相關介紹可參考[**這篇**](http://shubo.io/javascript-random-shuffle/)，以下是程式碼。\n```js\n function shuffle(array) {\n        for (let i = array.length - 1; i > 0; i--) {\n            let j = Math.floor(Math.random() * (i + 1));\n            [array[i], array[j]] = [array[j], array[i]];\n        }\n        return array;\n    }\n\nlet pokerRandom = shuffle(pokerArr);\n```\n* 我們已成功打亂數字，接著就是要**將數字按照規則排列**，我們一開始宣告的`maingameArea`就派上用場了，我們可以按照規則將數字一一塞入`maingameArea`的陣列裡，以下是程式碼。\n```js\n function mainpokerArr() {\n        let randomarrNum = Math.floor(Math.random() * 8);\n        if (randomarrNum <= 3) {\n            if (maingameArea[randomarrNum].length >= 7) {\n                return mainpokerArr()\n            }\n        } else {\n            if (maingameArea[randomarrNum].length >= 6) {\n                return mainpokerArr()\n            }\n        }\n        return randomarrNum;\n    }\n```\n這段程式碼的想法是因為`maingameArea`總共有8個陣列，從左到右的索引號是0\\~7，因此我們利用`randomarrNum`來隨機選出一個索引號。\n透過判斷式讓索引號為0\\~3時陣列長度維持為7張，索引號為4\\~7時長度維持為6張。\n現在我們有了符合規則的發牌方法，接下來就要將牌一一放進陣列裡，以下是程式碼。\n```js\n pokerRandom.map(function (item) {\n        let runmainpokerArr = mainpokerArr();\n        maingameArea[runmainpokerArr].push(item);\n    });\n```\n這裡讓未整理區`maingameArea`透過我們剛剛設計的發牌函式`mainpokerArr()`將我們剛打亂的陣列`pokerRandom`裡的數字放入未整理區的8個陣列裡。\n這邊因為我自己的設計關係，我再把`maingameArea`裡的8個陣列，分為4個一組放入更大的陣列`cardbigGroup`，以下是程式碼。\n```js\n maingameArea.forEach(function (item, index) {\n        if (index <= 3) {\n            cardbigGroup[0].push(item);\n        } else {\n            cardbigGroup[1].push(item)\n        };\n    });\n```\n\n* 隨機發牌的資料都按照規則整理完畢了，我們接下來要做的就是**讓牌可以渲染到畫面上**。\n首先，因為我們的數字是1\\~52，但系統並不知道花色，因此我們要先來定義花色，以下是程式碼。\n```js\n function judgeColor(cardNum) {\n        if (cardNum >= 1 && cardNum <= 13) {  //1~13是黑桃\n            return 'spade'\n        } else if (cardNum >= 14 && cardNum <= 26) { //14~26是紅心\n            return 'heart'\n        } else if (cardNum >= 27 && cardNum <= 39) { //27~39是方塊\n            return 'diamond'\n        } else if (cardNum >= 40 && cardNum <= 52) { //40~52是梅花\n            return 'club'\n        }\n    };\n```\n花色也定義完成後，我們就要正式選渲染畫面，因為是原生語法關係，我們利用 `createElement` 和 `appendChild` 來做渲染，因為程式碼較多，先來看看完整程式碼，我再根據每個部份做解釋。\n```js\n    let gamingArea = document.getElementById('gamingArea');\n   function putCard() {\n        cardbigGroup.forEach(function (section, sectionNum) {\n            let cardbiggroupPart = document.createElement('div');\n            cardbiggroupPart.className = 'col-6 d-flex w-100';\n            gamingArea.appendChild(cardbiggroupPart);\n            section.forEach(function (item, index) {\n                let cardGroup = document.createElement('div');\n                cardGroup.className = 'relative w-100';\n                cardGroup.style.height = '600px'\n                cardGroup.group = index;\n                cardGroup.section = sectionNum;\n                cardbiggroupPart.appendChild(cardGroup)\n                item.forEach(function (el, num) {\n                    let oneCard = document.createElement('div');\n                    oneCard.className = 'cardArea absolute';\n                    if (!isRefresh) {\n                        oneCard.style.transition = 'all .3s'\n                        oneCard.style.top = '-1000px';\n                        oneCard.style.left = '-2000px';\n                        setTimeout(function () {\n                            oneCard.style.top = num * 30 + 'px';\n                            oneCard.style.left = '0px'\n                        }, index * num * 30)\n                    } else {\n                        oneCard.style.top = num * 30 + 'px';\n                        oneCard.style.left = '0px'\n                    }\n                    let cardImg = document.createElement('img');\n                    cardImg.draggable = false\n                    cardImg.card = el;\n                    cardImg.section = sectionNum;\n                    cardImg.group = index;\n                    cardImg.color = judgeColor(el)\n                    cardImg.src = `pokerimg/card-${judgeColor(el)}-${el % 13}.svg`;\n                    if (!isgamePause && num + 1 == item.length) {\n                        oneCard.draggable = true;\n                        cardImg.draggable = true\n                    }\n                    oneCard.appendChild(cardImg)\n                    cardGroup.appendChild(oneCard);\n                })\n               \n            })\n        });\n\n    };\n```\n```js\n let gamingArea = document.getElementById('gamingArea');\n   function putCard() {\n        cardbigGroup.forEach(function (section, sectionNum) {\n            let cardbiggroupPart = document.createElement('div');\n            cardbiggroupPart.className = 'col-6 d-flex w-100';\n            gamingArea.appendChild(cardbiggroupPart);\n```\n我利用 `getElementById`選取要做為未整理區最外層的 HTML 元素。\n宣告一個函式負責執行隨機發牌，接著我要一層一層的剝開我們的陣列往內進逼針對陣列裡的元素做設定。\n第一個陣列就是分為左右兩大區塊的`cardbigGroup`，讓兩塊區域都`createElement`區塊元素(`div`)出來，那因為我有使用格線來排版，所以為他們加了一些排版相關的`className`。\n接著就可以利用`appendChild`將我們創造出來的兩個區塊元素加入到`gamingArea`下方。\n```js\n  section.forEach(function (item, index) {\n                let cardGroup = document.createElement('div');\n                cardGroup.className = 'relative w-100';\n                cardGroup.style.height = '600px'\n                cardGroup.group = index;\n                cardGroup.section = sectionNum;\n                cardbiggroupPart.appendChild(cardGroup)\n```\n第二個碰到的陣列是各區底下的4塊小區域(7張牌與6張牌)，原理一樣我們為每塊區域創造區塊元素，並將入一些自定義的`className`和`style`。\n這邊比較重要的一點是**為每個區塊元素增加一些屬性來記錄它所在的位置(`group`,`section`)**，這些屬性將會在後面我們要製作拖曳效果時會用到。\n```js\n item.forEach(function (el, num) {\n                    let oneCard = document.createElement('div');\n                    oneCard.className = 'cardArea absolute';\n                    if (!isRefresh) {\n                        oneCard.style.transition = 'all .3s'\n                        oneCard.style.top = '-1000px';\n                        oneCard.style.left = '-2000px';\n                        setTimeout(function () {\n                            oneCard.style.top = num * 30 + 'px';\n                            oneCard.style.left = '0px'\n                        }, index * num * 30)\n                    } else {\n                        oneCard.style.top = num * 30 + 'px';\n                        oneCard.style.left = '0px'\n                    }\n```\n最後我們碰到的就是我們的主角--**撲克牌**，這邊一樣是為每張牌創建區塊元素，那因為我採用的設計稿是 **吳俊儀設計師的設計稿**，俊儀設計師很佛心的把每張牌做成svg，所以我待會只要把每張svg `appendChild`到每張牌的`div`底下就好。\n至於判斷式的部分，是設計遊戲開始時的卡片出現動畫，這邊我就不多加敘述，卡片排版方式是利用絕對定位，那`position:relative`的部分我是設定給上一層的8個小區塊。\n```js\n  let cardImg = document.createElement('img');\n                    cardImg.draggable = false\n                    cardImg.card = el;\n                    cardImg.section = sectionNum;\n                    cardImg.group = index;\n                    cardImg.color = judgeColor(el)\n                    cardImg.src = `pokerimg/card-${judgeColor(el)}-${el % 13}.svg`;\n                    if (!isgamePause && num + 1 == item.length) {\n                        oneCard.draggable = true;\n                        cardImg.draggable = true\n                    }\n                    oneCard.appendChild(cardImg)\n                    cardGroup.appendChild(oneCard);\n                })\n```\n這邊我們就來處理圖片的部分，為每個數字創造`img`標籤，`src`的部分我們可以透過命名與判斷顏色的函式(`judgeColor`)，來取得符合該數字的圖片。\n一樣的，我們玩遊戲時都會拖曳這些卡片，因此也在這為它新增一些屬性(**`card`,`section`,`group`,`color`**)，分別是**數字、所在的大區塊、所在的小區塊、花色**。\n另外一樣重要的就是**`draggable`，設定它`true`or`false`會決定該元素是否能拖曳**，那因為**遊戲規則只有最後一張牌可以拖曳**，因此額外增加判斷式來判斷該張卡片是否為最後一張牌。\n最後一樣`appendChild`至上一層元素中。\n\n## 結語\n恭喜你!! 做到這裡，你的新接龍已經可以隨機發牌並且渲染到畫面上了。\n也謝謝你，看完我的文章!! 這是我第一次用 hexo 建立部落格與寫文章，排版可能還有點拙劣，傷眼抱歉。\n有關後續的完成區、暫存區與拖曳效果，我會再利用時間補上。\n\n附上我的 [DEMO](https://hao1229.github.io/THE-F2E-Freecell/) 與 [程式碼](https://github.com/Hao1229/THE-F2E-Freecell)\n\n---\n\n## 參考資料\n[懷恩老師的開發直播](https://www.facebook.com/groups/173311386703334/permalink/364591804241957/)\n\n[shuffle 文章](http://shubo.io/javascript-random-shuffle/)\n\n[Ray大的新接龍文章](https://hsiangfeng.github.io/javascript/20190712/1140639545/?fbclid=IwAR37Iq2qAZjR5wMVfSOT_jMIidxlTGRElm3ATu0zm8Hmp9iwWd61uGRz_z)\n\n[吳俊儀設計師的設計稿](https://xd.adobe.com/spec/f01f6d09-be4f-4bf3-601d-7c817fe225ab-862e/grid)\n\n","tags":["THE F2E"],"categories":["JavaScript"]}]