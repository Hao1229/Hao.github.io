<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>如何做出會隨時間變化的同心圓？</title>
    <url>/2019/09/06/concentricCircle/</url>
    <content><![CDATA[<p><img src="https://images.unsplash.com/photo-1507576566681-1932a6a38099?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=667&q=80"></p>
<h2 id="文章目的"><a href="#文章目的" class="headerlink" title="文章目的"></a>文章目的</h2><p>在做今年的 THE F2E 第一週番茄鐘時，遇到最大難題就是要做一個隨時間逐漸填滿的同心圓，想藉由此文章為製作流程做個紀錄。</p>
<a id="more"></a>

<h2 id="開發思維"><a href="#開發思維" class="headerlink" title="開發思維"></a>開發思維</h2><p>同心圓內圓與外圓之間是有間隔的，隨時間倒數間隔會逐漸填滿，示意圖如下：<br><img src="https://i.imgur.com/TEazPyu.png"></p>
<p><img src="https://i.imgur.com/NpZ7gaR.png"></p>
<p>我的想法是用3個圓去達成效果：</p>
<ul>
<li>第一個圓在最外圍負責最外圍的 border 顯示。</li>
<li>第二個圓就是兩圓之間的間隔，它會隨時間變色進而達到效果。</li>
<li>第三個圓就是內圓，與第一個圓有大小差距，進而產生間隔效果。</li>
</ul>
<h2 id="SVG-與-Stroke-介紹"><a href="#SVG-與-Stroke-介紹" class="headerlink" title="SVG 與 Stroke 介紹"></a>SVG 與 Stroke 介紹</h2><p>在這次效果製作中，這兩者扮演了很重要的角色，因此先來為它們做個簡單介紹。</p>
<ul>
<li>SVG 是向量標籤，我們可以在向量標籤裡透過座標的方式畫出不同的圖案。</li>
<li>Stroke 是 SVG 的一種屬性，它代表邊框的意思，它總共有5種屬性：<ul>
<li>stroke：邊框顏色</li>
<li>stroke-width：邊框寬度</li>
<li>stroke-dasharray：虛線</li>
<li>stroke-linecap：邊框端點的屬性 ( butt ( 預設 )、square、round )  —本次開發不會用到</li>
<li>strkoe-linejoin：邊框接合尖角的屬性 ( miter ( 預設 )、round、bevel ) —本次開發不會用到</li>
</ul>
</li>
</ul>
<h2 id="開發流程"><a href="#開發流程" class="headerlink" title="開發流程"></a>開發流程</h2><h3 id="畫出前兩個同心圓"><a href="#畫出前兩個同心圓" class="headerlink" title="畫出前兩個同心圓"></a>畫出前兩個同心圓</h3><p>我們先創造一個 SVG 標籤並且在裡面畫出一個圓，SVG 就是我們的第一個圓，SVG 裡的圓就是我們的第二個圓。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">style</span>=<span class="string">&quot;transform:rotate(-90deg);width:540px;height:540px;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;rounded-circle&quot;</span>&gt;</span></span><br><span class="line">    circle cx=&#x27;270&#x27; cy=&#x27;270&#x27; r=&#x27;135&#x27; fill=&#x27;none&#x27;&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>這邊我定義了外圓 SVG 的長寬(540px)，並令它呈現圓形(<code>rounded-circle</code>)，內部 <code>circle</code> 方面則是畫出大小是外圓的一半的圓，至於外圓的 SVG 再記得給它畫 border線即可。<br>先為 <code>circle</code> 裡的屬性做個解釋：</p>
<ul>
<li>cx：圓心的 x 座標</li>
<li>cy：圓心的 y 座標</li>
<li>r：圓的半徑</li>
<li>fill：填色</li>
</ul>
<p><strong>因為我是要做出同心圓所以 cx 和 cy 的座標就是外圓的圓心位置。</strong></p>
<h3 id="利用-stroke-做出填色效果"><a href="#利用-stroke-做出填色效果" class="headerlink" title="利用 stroke 做出填色效果"></a>利用 stroke 做出填色效果</h3><p>我們將 stroke 屬性下在 <code>circle</code> 裡，因為要做效果的是第二個圓<br>前面有提到 stroke-width 可以控制邊框的寬度，在這邊我們就設定成 270px 讓它可以填滿第二個圓，並利用 stroke 設定邊框顏色。<br>做到這裡重點來了，我們將利用 stroke-dasharray 和 stroke-dashoffset 來做出效果。</p>
<ul>
<li>stroke-dasharray 是我們的虛線，假設我們設定 <code>stroke-dasharray=&quot;60&quot;</code>，呈現出的效果會是 60px 的虛線跟 60px 的空格一組一組呈現。</li>
<li>stroke-dashoffset 則會推移我們的虛線，假設我們設定 <code>stroke-dashoffset=&quot;40&quot;</code>，第一個虛線就會僅剩 20px 後面的循環則是正常進行。<br>利用這兩個性質，將 stroke-dasharray 動態綁定到 Vue.js 裡的一個函數，綁定的函數負責幫我們算出圓周長並回傳給我們，因此 stroke-dasharray 就會是我們的圓周長。<br>第一個虛線就是整個圓周代表一開始虛線就會填滿整個圓，所以我們就要控制 stroke-dashoffset 讓它來決定虛線出現的大小。<br>我們一樣將 stroke-dashoffset 動態綁定到 Vue.js 的另一個函數，這個函數會幫我們算出符合的 stroke-dashoffset 回傳給我們。<br>講到這裡是不是茫了，沒關係我們來看看程式碼就會知道是怎麼回事。<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">style</span>=<span class="string">&quot;transform:rotate(-90deg);width:540px;height:540px;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;rounded-circle&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">&#x27;270&#x27;</span> <span class="attr">cy</span>=<span class="string">&#x27;270&#x27;</span> <span class="attr">r</span>=<span class="string">&#x27;135&#x27;</span> <span class="attr">stroke-width</span>=<span class="string">&quot;270&quot;</span> <span class="attr">:stroke-dasharray</span>=<span class="string">&#x27;strokeDasharray(135)&#x27;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">:stroke-dashoffset</span>=<span class="string">&#x27;strokeDashoffset(135,Math.min(1,startTime/setTime))&#x27;</span> <span class="attr">fill</span>=<span class="string">&#x27;none&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<code>Math.min(1,startTime/setTime)</code> ，startTime 和 setTime 是我自定義的變數，分別代表進行中的時間(startTime)與設定的時間(setTime)，Math.min 會回傳數列中的最小值。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 透過傳遞半徑給此函數，算出圓周長後回傳</span></span><br><span class="line">strokeDasharray:<span class="function"><span class="keyword">function</span>(<span class="params">r</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> r * <span class="number">2</span> * <span class="built_in">Math</span>.PI;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 傳遞半徑和 Math.min() 參數後，算出現在剩餘的時間屬於圓周長的幾分之幾並回傳</span></span><br><span class="line">strokeDashoffset:<span class="function"><span class="keyword">function</span>(<span class="params">r,el</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span>.strokeDasharray(r) * el );</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
看完程式碼之後有沒有比較清楚了，startTime 一直在減少，所以我們會一直將它與 setTime 的比值傳給我們的函數，函數會算出剩餘時間是圓周長的幾分之幾，並將其回傳，這就會是我們的 stroke-dashoffset 。<br>簡單來講，這個方法就是透過 stroke-dashoffset 的推移來控制 stroke-dasharray 的出現。</li>
</ul>
<h3 id="製作第三個圓"><a href="#製作第三個圓" class="headerlink" title="製作第三個圓"></a>製作第三個圓</h3><p>至於，第三個圓就是為了讓它幫助我們擋住第二個圓多餘的部分，因為我們的 stroke 會填滿整個圓，如果不加上第三個圓就無法呈現出只有部分填滿的視覺效果。<br>第三個圓做法我就不多敘述，簡單來說，第三個圓圓心位置要跟前兩個圓一樣，在開發時我是用絕對定位做到這一點，再把它的長寬設定相較前兩個圓小即可。</p>
<hr>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://www.oxxostudio.tw/articles/201406/svg-06-stroke.html">SVG 研究之路 (6) - stroke 邊框</a><br><a href="https://wcc723.github.io/svg/2014/06/15/svg-css-stroke-animation/">CSS + SVG stroke 動態描繪</a></p>
]]></content>
      <categories>
        <category>THE F2E</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
        <tag>THE F2E</tag>
        <tag>scss</tag>
      </tags>
  </entry>
  <entry>
    <title>利用 CSS 做出簡單的按鈕 hover 動畫回饋</title>
    <url>/2019/08/21/CssBtnHoverSmallFeedback/</url>
    <content><![CDATA[<p><img src="https://i.imgur.com/DHCpWu1.jpg"></p>
<h2 id="文章目的"><a href="#文章目的" class="headerlink" title="文章目的"></a>文章目的</h2><p>因為最近在練習製作電商網站，學到了一個不錯的按鈕 hover 回饋小技巧，想藉此篇文章做個紀錄。</p>
<a id="more"></a>

<h2 id="使用技巧與介紹"><a href="#使用技巧與介紹" class="headerlink" title="使用技巧與介紹"></a>使用技巧與介紹</h2><h3 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h3><p>這是一個 css 屬性可以讓使用此屬性的元素，達到被平移、旋轉、縮放和傾斜等操作，那這次我們主要用到的是 translate 這個平移屬性。<br>translate 的特性是可以根據我們設定的值，<strong>以元素中心點為基準平移</strong>。</p>
<h3 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h3><p>transition 也是一個 css 屬性，我們可以操作此屬性，來決定元素顯示的快慢與時間。</p>
<h3 id="css-偽元素"><a href="#css-偽元素" class="headerlink" title="css 偽元素"></a>css 偽元素</h3><p>偽元素是個很方便的技巧，在小地方會發揮想不到的效果，基本上偽元素會根據我們的主要元素來顯示，最常看到的就是 before 與 after，分別代表在主元素之前或是之後顯示的元素。</p>
<h2 id="本次效果說明"><a href="#本次效果說明" class="headerlink" title="本次效果說明"></a>本次效果說明</h2><p>我們要讓按鈕在 hover 時，頭上會有由中心點展開的線條，如下圖所示<br><strong>觸發前</strong><br><img src="https://i.imgur.com/IIQ4IFd.png"><br><strong>觸發後</strong><br><img src="https://i.imgur.com/6cwpx6p.png"></p>
<h2 id="CSS-撰寫"><a href="#CSS-撰寫" class="headerlink" title="CSS 撰寫"></a>CSS 撰寫</h2><p>這邊我先貼上完成的程式碼，在做一一解釋：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.mainNavbarBtn</span>&#123;</span><br><span class="line">       <span class="attribute">position</span>: relative;</span><br><span class="line">       <span class="attribute">color</span>: rgba(<span class="variable">$color</span>: white, <span class="variable">$alpha</span>: <span class="number">0.8</span>);</span><br><span class="line">       &amp;<span class="selector-pseudo">::before</span>&#123;</span><br><span class="line">           <span class="attribute">position</span>: absolute;</span><br><span class="line">           <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">           <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">           <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">           <span class="attribute">height</span>: <span class="number">3px</span>;</span><br><span class="line">           <span class="attribute">background</span>: white;</span><br><span class="line">           <span class="attribute">width</span>: <span class="number">0%</span>;</span><br><span class="line">           <span class="attribute">transform</span>: translateX(-<span class="number">50%</span>);</span><br><span class="line">           <span class="attribute">transition</span>: all .<span class="number">3s</span></span><br><span class="line">       &#125;</span><br><span class="line">       &amp;:hover&#123;</span><br><span class="line">           color: rgba(<span class="variable">$color</span>: white, <span class="variable">$alpha</span>: <span class="number">1.0</span>);</span><br><span class="line">           &amp;<span class="selector-pseudo">::before</span>&#123;</span><br><span class="line">           <span class="attribute">position</span>: absolute;</span><br><span class="line">           <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">           <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">           <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">           <span class="attribute">height</span>: <span class="number">3px</span>;</span><br><span class="line">           <span class="attribute">background</span>: white;</span><br><span class="line">           <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">           <span class="attribute">transform</span>: translateX(-<span class="number">50%</span>);</span><br><span class="line">           <span class="attribute">transition</span>: all .<span class="number">3s</span></span><br><span class="line">       &#125;</span><br><span class="line">           text-decoration: none;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>偽元素設置：這邊我們先為主元素設定一個 <code>position: relative</code> 來方便定位我們的偽元素，那因為是在上頭顯示因此用 before 或 after 就顯得沒那麼重要，若是左右顯示 before、after 就會有差別，再來是**偽元素的重點屬性 <code>content</code>**，<code>content</code> 會決定我們偽元素的內容，那因為我們只需要線條，所以可以不用填入內容，但 <code>content</code> 這屬性還是必須寫入。</li>
<li>transform 應用：因為我們的目的是要讓線條可以從中心點向兩側發散顯示，預設顯示會是從左邊頭顯示到右邊尾。<br>因此我們需要利用到絕對定位與 transform 來達到效果。<br>我們先用絕對定位將線條位移主元素的 50% 寬度，這時線條的頭會在主元素寬度中間的位置，這時線條顯示時的確會從中心出發，但又會有個問題，線條出發到結束一樣從左到右，且因為我們起始位置改變導致線條長度超出我們的主元素寬度。<br>這時我們就需要用到 transform 來修正我們線條位置，我們設定 transform 往 x 軸的負方向偏移 50% 將多出的部分轉移回來，這樣視覺上我們就會以為是從中間向兩側發散。</li>
<li>transition 效果：最後我們只需要加入 transition 設定我們線條的顯示時間，就會有漸變的效果出現囉!!</li>
</ul>
<hr>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://wcc723.github.io/css/2013/09/22/css-pseudo-element/">卡斯伯老師偽元素介紹</a><br><a href="https://boohover.pixnet.net/blog/post/35341387-%E6%97%8B%E8%BD%89%E3%80%81%E5%82%BE%E6%96%9C%E3%80%81%E7%B8%AE%E6%94%BE%E7%9A%84%E8%AE%8A%E5%BD%A2%E6%95%88%E6%9E%9C-transform-(css-prope">transform各效果應用</a></p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>SCSS</tag>
      </tags>
  </entry>
  <entry>
    <title>利用 CSS 做出 offcanvas 遮罩效果</title>
    <url>/2019/08/22/CssMenuMask/</url>
    <content><![CDATA[<p><img src="https://i.imgur.com/t4j5FN5.jpg"></p>
<h2 id="文章目的"><a href="#文章目的" class="headerlink" title="文章目的"></a>文章目的</h2><p>我們在逛一些具有響應式設計的網站時，在較小裝置點開 offcanvas 的 menu 時會有類似遮罩效果出現在畫面上，此文章將用來記錄如何利用 css 做出一樣的效果。</p>
<a id="more"></a>
<h2 id="本次示範-Demo"><a href="#本次示範-Demo" class="headerlink" title="本次示範 Demo"></a>本次示範 Demo</h2><p>這邊先附上要呈現的效果圖<br><strong>點擊漢堡選單前</strong><br><img src="https://i.imgur.com/tutiujp.png"><br><strong>點擊漢堡選單後</strong><br><img src="https://i.imgur.com/qNexvaJ.png"></p>
<h2 id="效果分析"><a href="#效果分析" class="headerlink" title="效果分析"></a>效果分析</h2><p>其實遮罩並沒有想像中那麼難達成，基本上只需要設置一個佔滿螢幕大小的 <code>div</code> 並利用絕對定位就可以輕鬆達成。<br>遮罩的顏色我們可以根據背景色不同來做更換。</p>
<h2 id="示範程式碼"><a href="#示範程式碼" class="headerlink" title="示範程式碼"></a>示範程式碼</h2><h3 id="遮罩製作"><a href="#遮罩製作" class="headerlink" title="遮罩製作"></a>遮罩製作</h3><p>我先做出一個包覆 menu 的區塊元素，並將其寬高設為裝置的寬高，程式碼如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aside</span> <span class="attr">class</span>=<span class="string">&quot;side min-vh-100 min-vw-100&quot;</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.side</span>&#123;</span></span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 0;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    background-color: rgba($color:#696969, $alpha: 0.7);</span><br><span class="line">    transition: all .3s;</span><br><span class="line">    transform: translateX(100vw);</span><br><span class="line">    overflow: hidden;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>另外用絕對定位讓它脫離排版，並且利用 <code>transform</code> 將其隱藏。<br>步驟進行到這裡我們已經有個覆蓋裝置畫面的遮罩。</p>
<h3 id="offcanvas-menu-設置"><a href="#offcanvas-menu-設置" class="headerlink" title="offcanvas menu 設置"></a>offcanvas menu 設置</h3><p>接著將 menu 的 <code>ul</code> <code>li</code> 寫入我們剛剛創的遮罩中，程式碼如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aside</span> <span class="attr">class</span>=<span class="string">&quot;side min-vh-100 min-vw-100&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;liststyleNone p-0 m-0 px-2 offcanvas&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fas fa-times-circle cancel text-primary fa-2x&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;closeOffcanvas&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;mt-5 d-flex justify-content-center p-0 m-0&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/login&quot;</span> <span class="attr">class</span>=<span class="string">&quot;mainNavbarBtn pt-2 h3&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fas fa-user mr-2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>後台登入<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;mt-5 d-flex justify-content-center p-0 m-0&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">class</span>=<span class="string">&quot;mainNavbarBtn pt-2 h3&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fas fa-ticket-alt mr-2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>優惠卷<span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fas fa-angle-down ml-2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;mt-5 d-flex justify-content-center p-0 m-0&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">class</span>=<span class="string">&quot;mainNavbarBtn pt-2 h3&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fas fa-shopping-cart mr-2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>購物車<span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fas fa-angle-down ml-2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;my-5 d-flex justify-content-center p-0 m-0&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">class</span>=<span class="string">&quot;mainNavbarBtn pt-2 h3&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fas fa-shopping-bag mr-2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>全部商品<span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fas fa-angle-down ml-2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"> <span class="selector-class">.offcanvas</span>&#123;</span></span><br><span class="line">    min-width: 50vw;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 0;</span><br><span class="line">    right: 0;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    background-color: rgba($color: #DCDCDC, $alpha: 0.8);</span><br><span class="line"><span class="css">    <span class="selector-tag">overflow</span>: <span class="selector-tag">auto</span>  <span class="comment">/*加入此屬性才能讓內容改變時跟著自適應*/</span></span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>這邊我是設定 menu 的寬度為裝置的一半，同樣的利用絕對定位來決定它在遮罩上的位置。<br>最後我們只需要設置點擊漢堡選單與叉叉時為遮罩新增與移除 className 即可， class 的部分只需要修改遮罩 <code>transform</code> 的位置就會有出現與隱藏的效果。<br><strong>這裡有一點要注意的是若我們沒有在新增的 className 中寫入 <code>overflow: auto</code> 這個屬性會導致 offcanvas 不會出現滾動條在內容過多時，會無法順利觀看。</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*遮罩新增的 className*/</span></span><br><span class="line"><span class="selector-class">.offcanvasShow</span>&#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="attribute">overflow</span>: auto</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://codertw.com/%E5%89%8D%E7%AB%AF%E9%96%8B%E7%99%BC/281513/">JS CSS實現彈出全屏灰黑色透明遮罩效果的方法</a></p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>SCSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS 小技巧紀錄園地</title>
    <url>/2019/08/29/CSStips/</url>
    <content><![CDATA[<p><img src="https://images.unsplash.com/photo-1523540939399-141cbff6a8d7?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=750&q=80"></p>
<h2 id="文章目的"><a href="#文章目的" class="headerlink" title="文章目的"></a>文章目的</h2><p>有鑑於在練習前端過程中，會遇到一些好用的 css 程式碼來呈現需要的網頁效果，但因為只是小技巧，不適合寫成一篇文章，因此利用此文章來為這些小技巧做個紀錄。</p>
<a id="more"></a>

<h2 id="input-number-隱藏預設加減箭頭方法"><a href="#input-number-隱藏預設加減箭頭方法" class="headerlink" title="input number 隱藏預設加減箭頭方法"></a>input number 隱藏預設加減箭頭方法</h2><p>我們在使用 <code>&lt;input type=&quot;number&gt;</code> 時，有時候會因為預設的加減箭頭帶來困擾，且因為這兩個箭頭會導致我們的內容數字無法置中，這邊提供一段程式碼來隱藏這兩個箭頭。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&#x27;number&#x27;</span>]</span><span class="selector-pseudo">::-webkit-inner-spin-button</span>,</span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&#x27;number&#x27;</span>]</span><span class="selector-pseudo">::-webkit-outer-spin-button</span> &#123;</span><br><span class="line"><span class="attribute">-webkit-appearance</span>: none;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>這樣我們就可以達到隱藏箭頭的效果囉。<br><strong>參考文章</strong> — <a href="https://stackoverflow.com/questions/23715881/center-text-in-html-number-input">Center text in html number input</a></p>
<h2 id="如何不依賴套件製作-x-軸滾動"><a href="#如何不依賴套件製作-x-軸滾動" class="headerlink" title="如何不依賴套件製作 x 軸滾動"></a>如何不依賴套件製作 x 軸滾動</h2><p>有時候會因為網頁效果需要我們要將某部分區域做成僅有 x 軸滾動效果，而非預設的 y 軸滾動，在不依賴套件的情況下，該如何達到目的？筆者將在此文章中分享自己的方法。</p>
<h3 id="效果介紹"><a href="#效果介紹" class="headerlink" title="效果介紹"></a>效果介紹</h3><p>首先，我們要有一個認知在我們固定一個區域的寬高之後(通常是 div)，裡面的內容會觸發 <code>overflow</code> 這個屬性，並且我們知道 html 中預設 overflow 發生時 div 通常會是 y 軸滾動來讓使用者查看超出的內容，但今天我們不想要這個預設效果，我們 overflow 的內容想改成 x 軸滾動來查看，這就是我們這次的目的。</p>
<h3 id="css-說明"><a href="#css-說明" class="headerlink" title="css 說明"></a>css 說明</h3><p>了解了原理，接下來就來看看程式碼吧，我們先看程式碼筆者再來做講解：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;recommandArea&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 18rem;&quot;</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in recommand&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card-body&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h5</span> <span class="attr">class</span>=<span class="string">&quot;card-title&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h6</span> <span class="attr">class</span>=<span class="string">&quot;card-subtitle mb-2 text-muted&quot;</span>&gt;</span>Card subtitle<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;card-text&quot;</span>&gt;</span>Some quick example text to build on the card title and make up the bulk of the card&#x27;s content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">class</span>=<span class="string">&quot;card-link&quot;</span>&gt;</span>Card link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">class</span>=<span class="string">&quot;card-link&quot;</span>&gt;</span>Another link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的 html 程式碼是筆者想要在 section 中創造出複數個 bootstrap 4 的卡片元件(<strong>這邊是利用 v-for 達到，不懂這個沒關係，只要知道 section 中會產生複數個卡片元件即可。</strong>)</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.recommandArea</span> &#123;</span><br><span class="line">    <span class="attribute">overflow-x</span>: scroll;</span><br><span class="line">    <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100vw</span>; <span class="comment">/*寬度為100%的裝置寬*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.card</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">white-space</span>: normal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接著我們來看看 css 的部分，因為我們需要 x 軸滾動效果，所以需要定義 section 的寬度，因為我們是要 x 軸滾動因此下 <code>overflow-x: scroll</code> 達到目的。<br><strong>接著最重要的來了，我們必須下 <code>white-space: nowrap</code>讓文字元素不能換行，此目的是為了讓內容可以 overflow，但今天我們要 overflow 的卡片是 div 元素，所以我們透過 <code>display: inline-block</code> 來改變它，這樣子它就可以吃到 <code>white-space: nowrap</code> 的效果囉!!</strong><br>步驟進行到這裡，應該就會有一個僅有x軸滾動的卡片列表囉!!!</p>
<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://stackoverflow.com/questions/13925284/horizontal-scrollbar">horizontal scrollbar</a><br><a href="https://stackoverflow.com/questions/443700/div-with-horizontal-scrolling-only">Div with horizontal scrolling only</a></p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>SCSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js 電商練習技術整理 -- 接取API與設定環境變數</title>
    <url>/2019/07/29/EcommercePractice1/</url>
    <content><![CDATA[<p><img src="https://i.imgur.com/el9rgW2.jpg"></p>
<h2 id="文章目的"><a href="#文章目的" class="headerlink" title="文章目的"></a>文章目的</h2><p>最近開始利用 Vue.js 實戰練習電商網站的開發，想藉由一系列的文章，來整理相關的重點技術。<br>本篇重點為利用 Vue Cli 接取 API 並且將 API 設定為環境變數。</p>
<a id="more"></a>
<h2 id="環境檔案介紹"><a href="#環境檔案介紹" class="headerlink" title="環境檔案介紹"></a>環境檔案介紹</h2><p>一般來講，安裝完 Vue Cli 後，打開 config 資料夾，會看到裡面有3個環境設定檔。<br>分別是：</p>
<ul>
<li>index.js – 針對整個環境進行編譯</li>
<li>dev.env.js – 開發中的環境變數</li>
<li>prod.env.js – 正式的環境變數</li>
</ul>
<p>那為什麼要特別分成開發中與正式版本呢？<br>因為往往在<strong>開發時接取的 API 路徑會與 正式版本不同</strong>，因此我們可以透過兩個檔案分開各自定義環境變數，以方便操作。</p>
<h2 id="Vue-axios-安裝"><a href="#Vue-axios-安裝" class="headerlink" title="Vue axios 安裝"></a>Vue axios 安裝</h2><p>既然我們本次的重點是要接取 API，這邊提供一個接取 API 的套件 — <a href="https://www.npmjs.com/package/vue-axios">Vue axios</a><br>安裝與設置方面這邊就不多加敘述，連結的官方文件上都有說明。</p>
<h2 id="接取-API"><a href="#接取-API" class="headerlink" title="接取 API"></a>接取 API</h2><p>有了 Vue axios 後我們就可以開始接取 API。<br>我們來到 App.vue，設定 created 時將 API 資料抓進來，程式碼如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">&#x27;App&#x27;</span>,</span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="keyword">const</span> api = <span class="string">&#x27;輸入你的API網址&#x27;</span></span><br><span class="line">    <span class="built_in">this</span>.$http.get(api).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(response.data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="將-API-網址設定成環境變數"><a href="#將-API-網址設定成環境變數" class="headerlink" title="將 API 網址設定成環境變數"></a>將 API 網址設定成環境變數</h2><p>用了上述方法接取 API 我們無法靈活的運用它，且無法讓它在開發環境與正式環境做區分。<br>因此現在<strong>我們要將 API 網址設定成環境變數，並透過呼叫變數來使用它</strong>(本次範例設定在開發環境)。</p>
<ol>
<li>我們來到 config 資料夾底下的 dev.env.js，宣告新的環境變數定義我們的 API 路徑，以下是程式碼：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = merge(prodEnv, &#123;</span><br><span class="line">  NODE_ENV: <span class="string">&#x27;&quot;development&quot;&#x27;</span>,</span><br><span class="line">  APIPATH: <span class="string">&#x27;&quot;你的 API 路徑&quot;&#x27;</span>,  <span class="comment">//變數名稱可自己定義，一般來說都是用大寫英文命名</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>這邊有一點要注意，宣告的變數在插入路徑時，記得要再用一次引號包覆路徑。</strong><br>2. 定義完環境變數後，我們回到 App.vue，將我們剛剛的路徑改成用環境變數，程式碼如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">&#x27;App&#x27;</span>,</span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="keyword">const</span> api = <span class="string">`<span class="subst">$&#123;process.env.APIPATH&#125;</span>`</span></span><br><span class="line">    <span class="built_in">this</span>.$http.get(api).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(response.data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>呼叫環境變數的方法：<code>process.env.環境變數</code>。</p>
<hr>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://www.hexschool.com/vue/">六角學院課程–Vue 出一個電商網站</a></p>
]]></content>
      <categories>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
        <tag>JavaScript</tag>
        <tag>E-commerce</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js 電商練習技術整理 -- 載入Bootsrap 4 套件，且自定義樣式</title>
    <url>/2019/07/29/EcommercePractice2/</url>
    <content><![CDATA[<p><img src="https://i.imgur.com/el9rgW2.jpg"></p>
<h2 id="文章目的"><a href="#文章目的" class="headerlink" title="文章目的"></a>文章目的</h2><p>藉由將 Bootstrap 4 套用到 Vue Cli 的專案裡，以方便後續開發 css 使用，並可將 Bootstrap 4 的預設樣式做修改，修改成專案所需樣式。</p>
<a id="more"></a>
<h2 id="載入-Bootstrap-4"><a href="#載入-Bootstrap-4" class="headerlink" title="載入 Bootstrap 4"></a>載入 Bootstrap 4</h2><p>在我們的終端機或是命令提示字元， cd 到我們的專案路徑，輸入<strong>npm install bootstrap –save</strong>。<br>安裝完成後，我們應該可以在 node_modules 資料夾底下看到 bootstrap 的資料夾。<br>步驟進行到這邊，還不算完全安裝好，因為<strong>我們並沒有支援 sass 的 loader，因此要再進行相關安裝</strong>。<br>這邊輸入<strong>npm install node-sass sass-loader –save</strong>，這樣子我們就完成載入 Bootstrap 囉。</p>
<h2 id="將-Bootstrap-4-套用到我們的專案上"><a href="#將-Bootstrap-4-套用到我們的專案上" class="headerlink" title="將 Bootstrap 4 套用到我們的專案上"></a>將 Bootstrap 4 套用到我們的專案上</h2><p>來到 App.vue 的 style，在標籤上加入 <code>lang=&quot;scss&quot;</code>，並在標籤內輸入 <code>@import &#39;~bootstrap/scss/bootstrap&#39;</code>，詳細程式碼如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;style lang=&quot;scss&quot;&gt;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">&quot;~bootstrap/scss/bootstrap&quot;</span>;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h2 id="自定義-Bootstrap-樣式"><a href="#自定義-Bootstrap-樣式" class="headerlink" title="自定義 Bootstrap 樣式"></a>自定義 Bootstrap 樣式</h2><p>若我們要自定義樣式，套用方式會跟上面有點差別。</p>
<ol>
<li>來到 node_modules 底下的 bootstrap 資料夾，並在 scss 資料夾底下找到 _variables。<br>在 assets 下新增一個 helpers 資料夾，將 _variables 另存新檔到 helpers 裡。</li>
<li>在 assets 資料夾下新增一個 all.scss 的檔案，在裡面載入檔案，程式碼如下：<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">&quot;~bootstrap/scss/functions&quot;</span>; <span class="comment">/*bootstrap 套用變數的方法，有它我們才能正確套用自定義變數*/</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">&quot;./helpers/_variables&quot;</span>; <span class="comment">/*我們的自定義內容*/</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">&quot;~bootstrap/scss/bootstrap&quot;</span>; <span class="comment">/*bootstrap 主套件*/</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>這邊要注意一點在載入時3個的順序要如上方所示，此為 bootstrap 官方規定。</strong>– <a href="https://bootstrap.hexschool.com/docs/4.1/getting-started/theming/#importing">規定內容</a><br>3. App.vue 的 style 載入方式也要做修改，程式碼如下：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">&lt;style lang=&quot;scss&quot;&gt;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">&#x27;./assets/all&#x27;</span> /*改成載入我們新建的all.scss*/</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>自定義示範<br>載入完成後，我們就能來自定義自己要的樣式。<br>打開我們另存的 _variables.scss，我們可以為裡面的變數做修改。<br>像是 Bootstrap 4 預設 primary 顏色為藍色，這裡透過改變變數將其顏色改變，程式碼如下：<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$theme-colors</span>: map-merge(</span><br><span class="line">  (</span><br><span class="line">    <span class="string">&quot;primary&quot;</span>:    <span class="variable">$purple</span>, /*預設為<span class="variable">$primary</span>*/</span><br><span class="line">    <span class="string">&quot;secondary&quot;</span>:  <span class="variable">$secondary</span>,</span><br><span class="line">    <span class="string">&quot;success&quot;</span>:    <span class="variable">$success</span>,</span><br><span class="line">    <span class="string">&quot;info&quot;</span>:       <span class="variable">$info</span>,</span><br><span class="line">    <span class="string">&quot;warning&quot;</span>:    <span class="variable">$warning</span>,</span><br><span class="line">    <span class="string">&quot;danger&quot;</span>:     <span class="variable">$danger</span>,</span><br><span class="line">    <span class="string">&quot;light&quot;</span>:      <span class="variable">$light</span>,</span><br><span class="line">    <span class="string">&quot;dark&quot;</span>:       <span class="variable">$dark</span></span><br><span class="line">  ),</span><br><span class="line">  <span class="variable">$theme-colors</span></span><br><span class="line">); </span><br></pre></td></tr></table></figure>
我們只要套用相關 bootstrap 元件或是 className 就會發現 primary 變成紫色。<br>這就是一個自定義內容的簡單範例。</li>
</ol>
<hr>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://www.hexschool.com/vue/">六角學院課程–Vue 出一個電商網站</a></p>
]]></content>
      <categories>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
        <tag>JavaScript</tag>
        <tag>E-commerce</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js 電商練習技術整理 -- 登入簡易路徑切換</title>
    <url>/2019/07/30/EcommercePractice3/</url>
    <content><![CDATA[<p><img src="https://i.imgur.com/el9rgW2.jpg"></p>
<h2 id="文章目的"><a href="#文章目的" class="headerlink" title="文章目的"></a>文章目的</h2><p>一般電商都會有登入畫面，當登入成功時會有畫面路徑的切換，本文用來記錄 Vue Cli 製作此方法流程。</p>
<a id="more"></a>

<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>在登入頁面中透過接取後端驗證 API 來認證使用者的帳號密碼，若驗證成功就變更路徑至其他頁面。</li>
<li>其他頁面具有登出功能，透過後端登出 API 將使用者帳號登出，並使路徑跳轉至登入前畫面。</li>
<li>需登入才能進入的頁面，在尚未登入時不能隨意進入。</li>
</ul>
<h2 id="驗證帳號-API-接取與路徑切換"><a href="#驗證帳號-API-接取與路徑切換" class="headerlink" title="驗證帳號 API 接取與路徑切換"></a>驗證帳號 API 接取與路徑切換</h2><ul>
<li>我們可以在 components 資料夾底下新增一個 pages 資料夾，並在裡面新增一個 Login.vue 檔。</li>
<li>在 Login.vue 檔中切出需要的登入版型，並透過 v-model 方式將使用者輸入的帳號密碼做雙向綁定，程式碼如下：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data () &#123;</span><br><span class="line">   <span class="keyword">return</span> &#123;</span><br><span class="line">     user: &#123;</span><br><span class="line">       username: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">       password: <span class="string">&#x27;&#x27;</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure></li>
<li>*這邊 data 裡的格式，根據驗證 api 要求的格式來設定。**</li>
<li>我們為登入的版型製作一個 submit 的事件來觸發驗證 API，事件方法如下：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">   signin: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">const</span> api = <span class="string">`驗證的 api 網址`</span></span><br><span class="line">     <span class="keyword">const</span> vm = <span class="built_in">this</span></span><br><span class="line">     <span class="built_in">this</span>.$http.post(api, vm.user).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (response.data.success === <span class="literal">true</span>) &#123;</span><br><span class="line">         vm.$router.push(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
我們利用 <code>post</code> 回傳使用者資料(user)給後端，利用判斷式判斷後端回傳成功與否來決定路徑是否切換。</li>
</ul>
<h2 id="登出驗證與路徑切換"><a href="#登出驗證與路徑切換" class="headerlink" title="登出驗證與路徑切換"></a>登出驗證與路徑切換</h2><p>現在我們要做一個簡易的登出按鈕，讓我們點擊時可以回到登入前的畫面。<br>我們這邊示範就在登入後顯示的頁面上製作此按鈕。</p>
<ul>
<li>製作一顆按鈕，讓其點擊後觸發一個事件，事件為接取登出 API ，程式碼如下：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">   signout () &#123;</span><br><span class="line">     <span class="keyword">const</span> api = <span class="string">`驗證登出 api 網址`</span></span><br><span class="line">     <span class="keyword">const</span> vm = <span class="built_in">this</span></span><br><span class="line">     <span class="built_in">this</span>.$http.post(api).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(response.data)</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li>接著我們在事件裡新增一個判斷式，若驗證成功即回到登入前頁面，程式碼如下：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    signout () &#123;</span><br><span class="line">      <span class="keyword">const</span> api = <span class="string">`驗證登出 api 網址`</span></span><br><span class="line">      <span class="keyword">const</span> vm = <span class="built_in">this</span></span><br><span class="line">      <span class="built_in">this</span>.$http.post(api).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(response.data)</span><br><span class="line">        <span class="keyword">if</span> (response.data.success === <span class="literal">true</span>) &#123;</span><br><span class="line">          vm.$router.push(<span class="string">&#x27;/login&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="導入導航守衛"><a href="#導入導航守衛" class="headerlink" title="導入導航守衛"></a>導入導航守衛</h2><p>做到這裡登入前與登入後畫面已可正確切換，但這時會有個問題，即使使用者尚未登入，也可利用變更網址的方式，訪問登入後的頁面。<br>我們這裡要介紹<strong>利用導航守衛讓使用者無法不經過認證就訪問特定頁面</strong>。<br><strong>導航守衛的定義在於它會判斷我們要前往的頁面以及正要離開的頁面，如果要前往的頁面是需要認證的，它會等認證完後才開放通行 – <a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%85%A8%E5%B1%80%E5%89%8D%E7%BD%AE%E5%AE%88%E5%8D%AB">導航守衛</a></strong></p>
<p>現在就來試著把剛剛完成的登入效果導入導航守衛吧。</p>
<ol>
<li>決定我們需要認證才能進入的頁面，決定好後到 Vue.router 的配置檔(index.js)，在 routes 中找到該頁面加入<code>meta: &#123; requiresAuth: true &#125;</code>，讓系統知道此頁面是需要認證才能訪問(可參考<a href="https://router.vuejs.org/zh/guide/advanced/meta.html">路由元訊息</a>)。示範如下：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;HelloWorld&#x27;</span>,</span><br><span class="line">    component: HelloWorld,</span><br><span class="line">    meta: &#123; <span class="attr">requiresAuth</span>: <span class="literal">true</span> &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
<li>來到我們的進入點(main.js)在裡面做全局的導航守衛部屬(可參考<a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%85%A8%E5%B1%80%E5%89%8D%E7%BD%AE%E5%AE%88%E5%8D%AB">全局守衛部屬</a>)，程式碼如下：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (to.meta.requiresAuth) &#123;</span><br><span class="line">    <span class="keyword">const</span> api = <span class="string">`檢視是否為登入狀態 api`</span></span><br><span class="line">    axios.post(api).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (response.data.success === <span class="literal">true</span>) &#123;</span><br><span class="line">        next()</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next(&#123;</span><br><span class="line">            path: <span class="string">&#x27;/login&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// next(false)</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
這裡針對上方程式碼做解釋：</li>
</ol>
<ul>
<li>參數解釋：<ul>
<li><code>to</code> 代表我們將要前往的頁面</li>
<li><code>from</code> 代表我們將要離開的頁面</li>
<li><code>next</code> 決定是否前往的方法</li>
</ul>
</li>
<li>我們透過判斷式<code>if (to.meta.requiresAuth)</code>，判斷出當我們要前往的頁面是需要驗證時就接取 api，不需要則直接切換即可。</li>
<li>這邊會發現接取 api 的程式碼有點不同，之前都是<code>this.$http.post(api)</code>，這裡變成<code>axios.post(api)</code>，原因是因為這時的環境是在 router 上，並不是像我們以往接取 api 時是在 Vue 的元件上，所以改成 <code>axios</code> 才能正常接取。</li>
<li>第二個判斷式，用來判斷若後端 api 驗證為登入狀態就讓頁面切換，否則停留在登入前畫面，那停留畫面部分有兩種寫法，<strong>一種是透過路徑的方式讓其重新導向登入前路徑，另一種是加入 false 中斷當前導覽並回到 from 的頁面</strong>。</li>
</ul>
<h2 id="避免使用者隨意改變網址導致跳轉到空白頁面"><a href="#避免使用者隨意改變網址導致跳轉到空白頁面" class="headerlink" title="避免使用者隨意改變網址導致跳轉到空白頁面"></a>避免使用者隨意改變網址導致跳轉到空白頁面</h2><p>若使用者在網址後面加入一些亂碼，會使頁面跳轉到空白的頁面去，為了避免這情況發生我們可以去配置檔(index.js)的 routes 加入以下程式碼：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: <span class="string">&#x27;*&#x27;</span>, <span class="comment">//當路徑為其它不存在的路徑時</span></span><br><span class="line">    redirect: <span class="string">&#x27;/login&#x27;</span> <span class="comment">//重新導向此路徑(可自己定義)</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h2 id="補充"><a href="#補充" class="headerlink" title="補充"></a>補充</h2><p>這邊要提醒一點，有些後端 API 可能會需要我們在接取 API 的同時，將後端的 Cookie 做儲存，並在最後接取 API 的同時，將 Cookie 傳至後端，才能完成 Ajax。<br>那如果要儲存 Cookie 我們可以在我們的進入點(main.js)，加入 axios 提供的程式碼 <code>axios.defaults.withCredentials = true</code>。</p>
<hr>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://www.hexschool.com/vue/">六角學院課程–Vue 出一個電商網站</a></p>
]]></content>
      <categories>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
        <tag>JavaScript</tag>
        <tag>E-commerce</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js 電商練習技術整理 -- 導入 Bootstrap 與 jQuery</title>
    <url>/2019/07/30/EcommercePractice4/</url>
    <content><![CDATA[<p><img src="https://i.imgur.com/el9rgW2.jpg"></p>
<h2 id="文章目的"><a href="#文章目的" class="headerlink" title="文章目的"></a>文章目的</h2><p>為了讓 Vue Cli 能正常使用 Bootstrap 4 的 jQuery 相關功能，本文用來記錄導入流程。</p>
<a id="more"></a>
<h2 id="本次示範"><a href="#本次示範" class="headerlink" title="本次示範"></a>本次示範</h2><p>本次要用來導入的是 Bootstrap 4 的 Modal 元件，那因為 Modal 會需要利用到 jQuery 來達到效果，因此我們需要先正確的導入 Bootstrap 4 的 js 檔案與 jQuery。—<a href="https://bootstrap.hexschool.com/docs/4.2/components/modal/#modalshow">Modal元件官方文件</a></p>
<h2 id="導入-Bootstrap-4-js-檔與-jQuery"><a href="#導入-Bootstrap-4-js-檔與-jQuery" class="headerlink" title="導入 Bootstrap 4 js 檔與 jQuery"></a>導入 Bootstrap 4 js 檔與 jQuery</h2><p>我們先到進入點(main.js)，將 Bootstrap 4 js 檔 <code>import</code> 進來，程式碼如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">import</span> VueAxios <span class="keyword">from</span> <span class="string">&#x27;vue-axios&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;bootstrap&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br></pre></td></tr></table></figure>
<p><strong>這邊要記得 <code>import</code> 的順序自定義檔案都要放在最後。</strong><br>接著我們來到需要引用 Modal 的頁面(Vue檔)，在 <code>&lt;script&gt;</code> 標籤上做以下操作：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">&#x27;jquery&#x27;</span> <span class="comment">//需使用元件導入(區域)</span></span><br></pre></td></tr></table></figure>
<p><strong>此為區域的引入，引入的 jQuery 僅有在該元件能使用</strong>，若想要全域引用可以在 main.js 加入以下程式碼：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;jquery&#x27;</span> <span class="comment">//main.js導入(全域)</span></span><br></pre></td></tr></table></figure>
<p><strong>這邊有一點要注意，若有使用 ESlint 會顯示不建議在全域導入</strong>，因此需額外加入以下程式碼：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* global $ */</span> <span class="comment">//main.js導入(全域)</span></span><br></pre></td></tr></table></figure>
<p>最後，我們將 Bootstrap 4 的 Modal 元件程式碼放入需使用的 Vue 元件內即可。</p>
<h2 id="透過事件觸發顯示-Modal"><a href="#透過事件觸發顯示-Modal" class="headerlink" title="透過事件觸發顯示 Modal"></a>透過事件觸發顯示 Modal</h2><p>我們這邊要稍微修改一下 Modal 的啟動方式，一般來講僅需要按鈕有對應的 Modal id 就可以啟動它。<br>那會要改寫成觸發事件是因為，這樣可以更靈活地顯示 Modal，如遇到需要接取 API 時可以讓 API 資料確定接收後再顯示 Modal。<br>這邊我們僅改成利用點擊觸發事件，如需要其他觸發方法可再自行更改。</p>
<ul>
<li>先在要觸發事件的按鈕上增加點擊事件，程式碼如下：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary&quot;</span> @<span class="attr">click.prevent</span>=<span class="string">&quot;openModal&quot;</span>&gt;</span>建立新的產品<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>接著建立我們的 <code>methods</code>，程式碼如下：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">   openModal () &#123;</span><br><span class="line">     $(<span class="string">&#x27;#productModal&#x27;</span>).modal(<span class="string">&#x27;show&#x27;</span>)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure>
有關程式碼可參考官方文件 —<a href="https://bootstrap.hexschool.com/docs/4.2/components/modal/#modalshow">Modal show</a></li>
</ul>
<hr>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://www.hexschool.com/vue/">六角學院課程–Vue 出一個電商網站</a></p>
]]></content>
      <categories>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
        <tag>JavaScript</tag>
        <tag>E-commerce</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js 電商練習技術整理 -- 製作讀取動畫增加使用者體驗</title>
    <url>/2019/08/05/EcommercePractice6/</url>
    <content><![CDATA[<p><img src="https://i.imgur.com/el9rgW2.jpg"></p>
<h2 id="文章目的"><a href="#文章目的" class="headerlink" title="文章目的"></a>文章目的</h2><p>我們時常在逛其他網站時，讀取過程中會看到一些動畫呈現，此文章用來記錄在用 Vue 開發網站時，如何製作同樣的動畫效果。</p>
<a id="more"></a>

<h2 id="方法簡介"><a href="#方法簡介" class="headerlink" title="方法簡介"></a>方法簡介</h2><ol>
<li>套用 vue-loading-overlay 套件達到效果 — <a href="https://www.npmjs.com/package/vue-loading-overlay">vue-loading-overlay官方文件</a></li>
<li>利用 FontAwesome 提供的 loading 圖案達到效果 —<a href="https://fontawesome.com/how-to-use/on-the-web/styling/animating-icons">FontAwesome Loading</a></li>
</ol>
<h2 id="vue-loading-overlay"><a href="#vue-loading-overlay" class="headerlink" title="vue-loading-overlay"></a>vue-loading-overlay</h2><p>這是一個 vue 的套件，透過安裝此套件我們可以輕易地呈現 loading 效果。</p>
<h3 id="vue-loading-overlay-安裝"><a href="#vue-loading-overlay-安裝" class="headerlink" title="vue-loading-overlay 安裝"></a>vue-loading-overlay 安裝</h3><p>這邊我們透過 npm 的方式來安裝此套件<br><code>npm install vue-loading-overlay --save</code></p>
<p>透過此套件的官方文件，我們可以得知它有兩種使用方式：</p>
<ol>
<li>透過 Component 方式載入。</li>
<li>透過 Plugin 方式載入。<br>本次範例將以 Component 方式載入做講解。</li>
</ol>
<h3 id="vue-loading-overlay-載入"><a href="#vue-loading-overlay-載入" class="headerlink" title="vue-loading-overlay 載入"></a>vue-loading-overlay 載入</h3><p>我們先來到 Vue Cli 的進入點(main.js)，import 以下兩支檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Loading <span class="keyword">from</span> <span class="string">&#x27;vue-loading-overlay&#x27;</span> <span class="comment">//component</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;vue-loading-overlay/dist/vue-loading.css&#x27;</span> <span class="comment">//style</span></span><br></pre></td></tr></table></figure>
<p>利用 component 方法做載入：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;Loading&#x27;</span>, Loading)</span><br></pre></td></tr></table></figure>
<p>進行到這裡，我們已完成全域的 loading 設定，接下來就可以在需要 loading 的頁面上做載入。</p>
<h3 id="載入-loading-特效"><a href="#載入-loading-特效" class="headerlink" title="載入 loading 特效"></a>載入 loading 特效</h3><p>將此 loading 模板放入元件最外層的 div 底下(<strong>這樣才能將效果套用到整個元件頁面上，若只需要部份做套用可以僅放在需套用的區塊內即可。</strong>)，程式碼如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">loading</span> <span class="attr">:active.sync</span>=<span class="string">&quot;isLoading&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">loading</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>這是最基本的模板，<code>isLoading</code>負責控制效果是否出現，<strong>若要自訂效果或是增加一些控制屬性，可參考<a href="https://ithelp.ithome.com.tw/articles/10209705">這篇文章</a></strong><br>進行到這裡我們的頁面已會正確的出現效果，那如果要控制出現在效果的時機，我們可以透過 <code>isLoading</code> 的操作來控制。</p>
<h3 id="控制-loading-出現時機"><a href="#控制-loading-出現時機" class="headerlink" title="控制 loading 出現時機"></a>控制 loading 出現時機</h3><p>以範例來講，我們可以先在 data 的部分宣告我們的變數 <code>isLoading = false</code>，讓 loading 效果一開始是隱藏的，當 ajax 執行時觸發 loading 效果，並在 ajax 成功時，結束 loading 效果，程式碼如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      products: [],</span><br><span class="line">      isLoading: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getProducts () &#123;</span><br><span class="line">      <span class="keyword">const</span> api = <span class="string">`你的 api 路徑`</span></span><br><span class="line">      <span class="keyword">const</span> vm = <span class="built_in">this</span></span><br><span class="line">      vm.isLoading = <span class="literal">true</span> <span class="comment">//正在執行 ajax 時 isLoading = true 觸發效果</span></span><br><span class="line">      <span class="built_in">this</span>.$http.get(api).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(response.data)</span><br><span class="line">        vm.isLoading = <span class="literal">false</span> <span class="comment">//ajax結束時，isLoading = false 結束效果</span></span><br><span class="line">        vm.products = response.data.products</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>
<h2 id="FontAwesome-載入動畫效果"><a href="#FontAwesome-載入動畫效果" class="headerlink" title="FontAwesome 載入動畫效果"></a>FontAwesome 載入動畫效果</h2><h3 id="將-FontAwesome-引用置專案中"><a href="#將-FontAwesome-引用置專案中" class="headerlink" title="將 FontAwesome 引用置專案中"></a>將 FontAwesome 引用置專案中</h3><p>有兩種方法可以將FontAwesome引用：</p>
<ol>
<li>cdn 方式</li>
<li>npm 安裝<br>cdn 方式這邊就不多加說明，我們來稍微解釋一下如何透過 npm 載入。<br>我們先在終端機上輸入以下指令：<br><code>npm install --save-dev @fortawesome/fontawesome-free</code><br>待安裝完畢我們會在 node_modules 資料夾底下看到 <strong>@fortawesome</strong>，這代表安裝完成。<br>接著我們要載入它，先來到需要使用的元件下將下列程式碼加入該元件的 <code>style</code> 裡。<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">  <span class="keyword">@import</span> url(<span class="string">&quot;@fortawesome/fontawesome-free/css/all.css&quot;</span>);</span><br><span class="line">&lt;/<span class="selector-tag">style</span>&gt;</span><br></pre></td></tr></table></figure>
亦或是在 main.js 輸入以下程式碼做全局載入：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;@fortawesome/fontawesome-free/css/all.css&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;@fortawesome/fontawesome-free/js/all.js&#x27;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="使用-FontAwesome-動畫-icons"><a href="#使用-FontAwesome-動畫-icons" class="headerlink" title="使用 FontAwesome 動畫 icons"></a>使用 FontAwesome 動畫 icons</h3><p>FontAwesome 官網中的文件有提到一種 Animating icons，只要加入此 icon 就會有動畫載入的效果 — <a href="https://fontawesome.com/how-to-use/on-the-web/styling/animating-icons">Animating icons</a>。<br>當然我們也可以控制 icons 的出現時機，方法和 vue-loading-overlay 相似，只是這邊我們是用 v-if 的方式來做，以下是程式碼：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fas fa-spinner fa-spin&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;status.fileUploading&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我們在 data 內宣告一個變數負責判斷 icons 的出現。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      status: &#123;</span><br><span class="line">        fileUploading: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>最後一樣的可以根據事件的觸發來改變 <code>this.status.fileUploading</code> 的布林數，進而觸發 icons 的顯示與隱藏。<br><strong>最後有一點要補充，還是會建議 FontAwesome 載入效果主要用在局部，若要全局效果還是會建議使用 vue-loading-overlay</strong></p>
<h2 id="FontAwesome-打包時注意"><a href="#FontAwesome-打包時注意" class="headerlink" title="FontAwesome 打包時注意!!"></a>FontAwesome 打包時注意!!</h2><p><strong>因為 FontAwesome 打包後容量較大，若不修改容量限制會導致 FontAwesome 無法一起被打包。</strong><br>因此我們需要對設定檔做修改。<br>來到 build 底下的 webpack.base.conf.js 找到下列程式碼：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: <span class="regexp">/\.(woff2?|eot|ttf|otf)(\?.*)?$/</span>,</span><br><span class="line">        loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          limit: <span class="number">800000</span>, <span class="comment">//預設是10000，這邊修改成800000</span></span><br><span class="line">          name: utils.assetsPath(<span class="string">&#x27;fonts/[name].[hash:7].[ext]&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改完後，再執行 npm run build 打包動作。<br><strong>僅限利用 npm 方式引入 FontAwesome 需做此修改，若為 cdn 方式引用不需這樣做。</strong></p>
<hr>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://www.hexschool.com/vue/">六角學院課程–Vue 出一個電商網站</a><br><a href="https://ithelp.ithome.com.tw/articles/10209705">JB大的文章</a></p>
]]></content>
      <categories>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
        <tag>JavaScript</tag>
        <tag>E-commerce</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js 電商練習技術整理 -- event bus 元件間的溝通橋樑</title>
    <url>/2019/08/06/EcommercePractice7/</url>
    <content><![CDATA[<p><img src="https://i.imgur.com/el9rgW2.jpg"></p>
<h2 id="文章目的"><a href="#文章目的" class="headerlink" title="文章目的"></a>文章目的</h2><p>在我們開發 Vue 的專案時，每個元件檔案間都會有內外層的差別，例：一個 Root 下有兩個 side 每個 side 底下又有3個元件，當我們需要利用內層的資料來觸發外層的事件時，會需要一層一層的將資料向上傳遞，這會顯得較為麻煩，因此我們可以利用 event bus 的方式，直接將我們內層的資料傳遞給外層作使用。</p>
<a id="more"></a>
<h2 id="event-bus-簡介"><a href="#event-bus-簡介" class="headerlink" title="event bus 簡介"></a>event bus 簡介</h2><p>event bus 的重點在於它可以幫我們把特定事件直接掛載到 Vue 的 原型下(Prototype)，元件間透過 **$on(監聽)**以及 **$emit(觸發)**兩種行為來達到內層觸發外層事件的效果。</p>
<h2 id="透過-event-bus-將內層資料傳遞至外層觸發-alert-效果"><a href="#透過-event-bus-將內層資料傳遞至外層觸發-alert-效果" class="headerlink" title="透過 event bus 將內層資料傳遞至外層觸發 alert 效果"></a>透過 event bus 將內層資料傳遞至外層觸發 alert 效果</h2><h3 id="新增-alert-模板"><a href="#新增-alert-模板" class="headerlink" title="新增 alert 模板"></a>新增 alert 模板</h3><p>我們可以在 Vue Cli 的 components 資料夾底下新增一個 AlertMessage 的元件，並在裡面設計我們的 alert 模板。</p>
<h3 id="將-event-bus-掛載到原型上"><a href="#將-event-bus-掛載到原型上" class="headerlink" title="將 event bus 掛載到原型上"></a>將 event bus 掛載到原型上</h3><p>掛載到原型上的目的是為了讓所有元件皆能使用。<br>在 Vue Cli 的 src 資料夾底下新增一個 bus.js 並在裡面輸入以下程式碼以完成掛載：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.prototype.$bus = <span class="keyword">new</span> Vue()  <span class="comment">//$bus 為自訂義的名稱可以自行命名，建議要加上$</span></span><br></pre></td></tr></table></figure>
<p>接著我們在進入點(main.js)下 import 這隻檔案進來。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./bus&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="在-AlertMessage-元件下做監聽"><a href="#在-AlertMessage-元件下做監聽" class="headerlink" title="在 AlertMessage 元件下做監聽"></a>在 AlertMessage 元件下做監聽</h3><p>因為我們要讓底層元件觸發 event bus 時， event bus 會將相關資料傳遞到 AlertMessage 做使用，所以我們在 AlertMessage 中加入 event bus 的監聽，程式碼如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">created () &#123;</span><br><span class="line">  <span class="keyword">const</span> vm = <span class="built_in">this</span></span><br><span class="line">  <span class="comment">// 自定義名稱 &#x27;messsage:push&#x27;</span></span><br><span class="line">  <span class="comment">// message: 傳入參數</span></span><br><span class="line">  <span class="comment">// status: 樣式，預設值為 warning</span></span><br><span class="line">  vm.$bus.$on(<span class="string">&#x27;message:push&#x27;</span>, <span class="function">(<span class="params">message, status = <span class="string">&#x27;warning&#x27;</span></span>) =&gt;</span> &#123;</span><br><span class="line">    vm.updateMessage(message, status)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要監聽時會有幾個屬性與參數可以做設定，自定義的名稱以及監聽的參數，<strong>基本上參數就會是內層傳遞上來的資料</strong>，接著可以將這些資料參數套用到元件內的其他 methods 中。<br>像在本次範例中將參數傳遞給 <code>updateMessage</code> 做使用，以下附上完整程式碼：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">&#x27;Navbar&#x27;</span>,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      messages: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    updateMessage (message, status) &#123;</span><br><span class="line">      <span class="keyword">const</span> timestamp = <span class="built_in">Math</span>.floor(<span class="keyword">new</span> <span class="built_in">Date</span>() / <span class="number">1000</span>)</span><br><span class="line">      <span class="built_in">this</span>.messages.push(&#123;  <span class="comment">//以下3個數值會影響到 alert 顯示結果</span></span><br><span class="line">        message,  <span class="comment">//alert 顯示的訊息</span></span><br><span class="line">        status,  <span class="comment">//alert 的顏色</span></span><br><span class="line">        timestamp  <span class="comment">//alert 的 id</span></span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="built_in">this</span>.removeMessageWithTiming(timestamp)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//手動關閉 alert </span></span><br><span class="line">    removeMessage (num) &#123;</span><br><span class="line">      <span class="built_in">this</span>.messages.splice(num, <span class="number">1</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//讓訊息顯示後5秒自動消失</span></span><br><span class="line">    removeMessageWithTiming (timestamp) &#123;</span><br><span class="line">      <span class="keyword">const</span> vm = <span class="built_in">this</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        vm.messages.forEach(<span class="function">(<span class="params">item, i</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (item.timestamp === timestamp) &#123;</span><br><span class="line">            vm.messages.splice(i, <span class="number">1</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;, <span class="number">5000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="keyword">const</span> vm = <span class="built_in">this</span></span><br><span class="line">    vm.$bus.$on(<span class="string">&#x27;message:push&#x27;</span>, <span class="function">(<span class="params">message, status = <span class="string">&#x27;warning&#x27;</span></span>) =&gt;</span> &#123;</span><br><span class="line">      vm.updateMessage(message, status)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成 alert 部分的設定後我們可以將此元件 import 進要顯示訊息的 Dashboard 元件下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Alert <span class="keyword">from</span> <span class="string">&#x27;./AlertMessage&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Alert</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>要記得將元件加入 HTML 裡。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Navbar</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Alert</span>&gt;</span><span class="tag">&lt;/<span class="name">Alert</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container-fluid&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Sidebar</span>&gt;</span><span class="tag">&lt;/<span class="name">Sidebar</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">main</span> <span class="attr">role</span>=<span class="string">&quot;main&quot;</span> <span class="attr">class</span>=<span class="string">&quot;col-md-9 ml-sm-auto col-lg-10 px-4&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="在內層的-Products-元件上新增-event-bus-的觸發事件"><a href="#在內層的-Products-元件上新增-event-bus-的觸發事件" class="headerlink" title="在內層的 Products 元件上新增 event bus 的觸發事件"></a>在內層的 Products 元件上新增 event bus 的觸發事件</h3><p>透過 ajax 的失敗，觸發 event bus 將相關參數傳遞給 AlertMessage，以下是程式碼：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  <span class="built_in">this</span>.$http.post(url, formData, &#123;</span><br><span class="line">    headers: &#123;</span><br><span class="line">      <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;multipart/form-data&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response.data)</span><br><span class="line">    <span class="keyword">if</span> (response.data.success) &#123;</span><br><span class="line">      vm.status.fileUploading = <span class="literal">false</span></span><br><span class="line">      vm.$set(vm.tempProduct, <span class="string">&#x27;imageUrl&#x27;</span>, response.data.imageUrl)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.$bus.$emit(<span class="string">&#x27;message:push&#x27;</span>, response.data.message, <span class="string">&#x27;danger&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我們在之前 formData 上傳圖片的事件中，新增若上傳失敗就觸發 <code>message:push</code> 並根據我們當初自訂的格式回傳相關參數。<br>當 AlertMessage 收到我們回傳的參數時，就會根據這些參數去渲染 alert 效果。</p>
<h2 id="小技巧補充"><a href="#小技巧補充" class="headerlink" title="小技巧補充"></a>小技巧補充</h2><p>有時候我們在定義 event bus 的事件名稱及相關參數時會忘記是在哪個元件上做定義，因此我們可以利用註解的方式，將我們的定義方法寫在 bus.js 裡以方便了解。<br>最後，小提醒 <strong>event bus 在管理上會有些問題，能的話盡量使用在較不複雜的網頁結構上</strong>。</p>
<hr>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://www.hexschool.com/vue/">六角學院課程–Vue 出一個電商網站</a></p>
]]></content>
      <categories>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
        <tag>JavaScript</tag>
        <tag>E-commerce</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js 電商練習技術整理 -- 使用 VeeValidate 輕鬆建立表單驗證</title>
    <url>/2019/08/09/EcommercePractice8/</url>
    <content><![CDATA[<p><img src="https://i.imgur.com/el9rgW2.jpg"></p>
<h2 id="文章目的"><a href="#文章目的" class="headerlink" title="文章目的"></a>文章目的</h2><p>我們應該都有經驗在網路上購買東西，填寫資料時若資料填寫不完整，會導致表單無法送出，無法完成訂單程序，往往使用者在填寫訂單時會需要填入一些必要的資料。<br>本文章將用來記錄用 Vue.js 開發時如何使用 VeeValidate 來驗證使用者資料正不正確，若不正確就阻止資料的送出。</p>
<a id="more"></a>
<h2 id="VeeValidate-簡介"><a href="#VeeValidate-簡介" class="headerlink" title="VeeValidate 簡介"></a>VeeValidate 簡介</h2><p>VeeValidate 是 Vue.js 表單驗證的外掛套件，使用它我們只需在需要驗證的表單上加入一些特定語法就可以建立驗證，附上<a href="https://logaretm.github.io/vee-validate/">官方文件</a>。</p>
<h2 id="VeeValidate-安裝及引用"><a href="#VeeValidate-安裝及引用" class="headerlink" title="VeeValidate 安裝及引用"></a>VeeValidate 安裝及引用</h2><h3 id="套件安裝"><a href="#套件安裝" class="headerlink" title="套件安裝"></a>套件安裝</h3><p>一樣打開我們的終端機輸入<code>npm install vee-validate --save</code> 安裝至我們的 Vue Cli 裡，那當然也有 cdn 的方式，相關內容可以觀看官方文件。<br><strong>這邊有一點要注意，因為此套件官方還有持續在更新，寫這篇文章時筆者是使用2.2.14版本，後來因為更新到3.x版本時，使用方法會有點不同，本篇文章還是以2.x版本為主要介紹，3.x版本會在後續作補充。</strong><br><strong>若要改安裝2.x版本的話，可以輸入<code>npm install vee-validate@2.2.15 --save</code> 即可，在這之前若已經安裝此套件的話，要先輸入<code>npm uninstall vee-validate --save</code> 將套件移除。</strong></p>
<h3 id="中文化安裝及引用"><a href="#中文化安裝及引用" class="headerlink" title="中文化安裝及引用"></a>中文化安裝及引用</h3><p>因為 VeeValidate 有支援中文，所以我們接下來要將 VeeValidate 引用至我們的專案，並且將其中文化。</p>
<h4 id="中文化"><a href="#中文化" class="headerlink" title="中文化"></a>中文化</h4><p>為了支援中文，我們需要先在終端機輸入<code>npm install vue-i18n --save</code>。</p>
<h4 id="引用與設定"><a href="#引用與設定" class="headerlink" title="引用與設定"></a>引用與設定</h4><p>安裝完成後，來到進入點(main.js) import 以下幾支檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> VeeValidate <span class="keyword">from</span> <span class="string">&#x27;vee-validate&#x27;</span></span><br><span class="line"><span class="keyword">import</span> zhTW <span class="keyword">from</span> <span class="string">&#x27;vee-validate/dist/locale/zh_TW&#x27;</span></span><br><span class="line"><span class="keyword">import</span> VueI18n <span class="keyword">from</span> <span class="string">&#x27;vue-i18n&#x27;</span></span><br></pre></td></tr></table></figure>
<p>接著我們在下面做以下設定：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.use(VueI18n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> i18n = <span class="keyword">new</span> VueI18n(&#123;</span><br><span class="line">  locale: <span class="string">&#x27;zhTW&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line">Vue.use(VeeValidate, &#123;</span><br><span class="line">  events: <span class="string">&#x27;input|blur&#x27;</span>, <span class="comment">//這是為了讓使用者離開該欄位時觸發驗證</span></span><br><span class="line">  i18n,</span><br><span class="line">  dictionary: &#123;</span><br><span class="line">    zhTW</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>另外要記得在下面 <code>new Vue</code> 中把 <code>i18n</code> 載入，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  i18n,</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  router,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: <span class="string">&#x27;&lt;App/&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>進行到這裡我們就完成中文化與引用的步驟了，每個 Vue 元件中可以正常使用 VeeValidate。</p>
<h2 id="表單驗證設定"><a href="#表單驗證設定" class="headerlink" title="表單驗證設定"></a>表單驗證設定</h2><h3 id="基本寫法"><a href="#基本寫法" class="headerlink" title="基本寫法"></a>基本寫法</h3><p>我們來到需要驗證的 <code>html input</code> 標籤，先來看看程式碼：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;username&quot;</span>&gt;</span>收件人姓名<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;&#x27;is-invalid&#x27;:errors.has(&#x27;name&#x27;)&#125;&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">v-model</span>=<span class="string">&quot;form.user.name&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;輸入姓名&quot;</span> <span class="attr">v-validate</span>=<span class="string">&quot;&#x27;required&#x27;&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;text-danger&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;errors.has(&#x27;name&#x27;)&quot;</span>&gt;</span>姓名必須輸入<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面是一個利用 Bootstrap 4 表單做出來的版型，這裡有幾個重點：</p>
<ul>
<li><code>input</code> 標籤內要設定 <code>name</code>這個屬性，屬性值的部分則是根據該欄位性質做設定，例：姓名就是 name，地址就是 address。<br>當然屬性值根據當下情況自己命名即可。</li>
<li>**必須在 <code>input</code> 標籤裡加上 <code>v-validate=&quot;&#39;required&#39;&quot;</code>**，這是為了讓系統知道這一個欄位是必填的。</li>
<li>接著我們可以寫入提示文字效果，像是上面的「姓名必須輸入」，我們透過 v-if 去控制它若驗證錯誤就顯示文字，至於 <code>errors.has(&#39;name&#39;)</code> 括號填入我們剛剛說的 <code>name</code> 屬性值，它就會幫我們判斷 true or false ，當是 <strong>true 時驗證失敗，false 時驗證成功</strong>。</li>
<li>VeeValidate 可以與 Bootstrap 4 的驗證效果共用，因此我們一樣可以利用 v-if 的方式來動態新增 <code>is-invalid</code> 這個 className 讓提示更加明顯。<h3 id="email寫法"><a href="#email寫法" class="headerlink" title="email寫法"></a>email寫法</h3>這邊要額外提到 email 欄位的驗證法，email 會跟其他資料欄位有點不一樣，因此分出來講解。<br>一樣的我們先來看看程式碼：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;useremail&quot;</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">id</span>=<span class="string">&quot;useremail&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;&#x27;is-invalid&#x27;:errors.has(&#x27;email&#x27;)&#125;&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">v-model</span>=<span class="string">&quot;form.user.email&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;請輸入 Email&quot;</span> <span class="attr">v-validate</span>=<span class="string">&quot;&#x27;required|email&#x27;&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;text-danger&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;errors.has(&#x27;email&#x27;)&quot;</span>&gt;</span>&#123;&#123;errors.first(&#x27;email&#x27;)&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
這邊有兩個地方跟基本寫法不太一樣。</li>
<li>在我們設定 <code>v-validate=&quot;&#39;required|email&#39;&quot;</code> 時，需要在 <code>required</code> 後面加入 <code>email</code>，這樣在驗證時才會以 email 的格式來驗證。</li>
<li>另外在驗證提示文字用**兩個中括號包覆填入 errors.first(‘email’)**，會顯示 VeeValidate 的預設文字，它會根據 email 驗證的各種狀態來顯示不同的提示文字，我們一開始設定的中文化也在這邊派上用場，提示文字會是中文。<h2 id="驗證方法設定"><a href="#驗證方法設定" class="headerlink" title="驗證方法設定"></a>驗證方法設定</h2>進行到這邊我們的表單已經能正常驗證，但是這僅僅是效果，若我們搭配 API 去設計表單的話依然一樣會將資料送出，因此我們需要利用方法來阻止 API 的接取，根據官方提供的寫法，可以這樣寫：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$validator.validate().then(<span class="function">(<span class="params">valid</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">          <span class="comment">// 當驗證成功時執行 AJAX 的行為</span></span><br><span class="line">         &#125;)</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 驗證失敗產生的行為</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125;)</span><br></pre></td></tr></table></figure>
上述的方法可以加在 submit 後觸發的事件內。</li>
</ul>
<h2 id="補充–VeeValidate-3-x-使用方法介紹"><a href="#補充–VeeValidate-3-x-使用方法介紹" class="headerlink" title="補充–VeeValidate 3.x 使用方法介紹"></a>補充–VeeValidate 3.x 使用方法介紹</h2><p>有鑑於現在此套件版本已更新，使用方法與過往 2.x 有些許不同，因此透過補充的方式來記錄方法。</p>
<h3 id="安裝與引用"><a href="#安裝與引用" class="headerlink" title="安裝與引用"></a>安裝與引用</h3><p>我們在終端機輸入 <code>npm install vee-validate --save</code>，即可安裝最新版本的套件。<br>接著我們在 main.js 做引用，引用方法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ValidationProvider, extend &#125; <span class="keyword">from</span> <span class="string">&#x27;vee-validate&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add a rule，此範例中添加了一個名為&#x27;secret&#x27;的規則，若 value 值不為 &#x27;example&#x27;，就會回饋 message 裡的文字。</span></span><br><span class="line">extend(<span class="string">&#x27;secret&#x27;</span>, &#123;</span><br><span class="line">  validate: <span class="function"><span class="params">value</span> =&gt;</span> value === <span class="string">&#x27;example&#x27;</span>,</span><br><span class="line">  message: <span class="string">&#x27;This is not the magic word&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register it globally</span></span><br><span class="line">Vue.component(<span class="string">&#x27;ValidationProvider&#x27;</span>, ValidationProvider);</span><br></pre></td></tr></table></figure>
<p>你一定會發現多了一個 add rule，3.x 版本對於驗證規則添加了更多的彈性，我們可以自訂規則並在不同驗證中引用我們所需要的驗證規則。</p>
<h3 id="使用方法與簡單功能介紹"><a href="#使用方法與簡單功能介紹" class="headerlink" title="使用方法與簡單功能介紹"></a>使用方法與簡單功能介紹</h3><p>現在我們知道 3.x 版本帶給我們更多的彈性，也帶給我們更多強大的功能，筆者會介紹幾個實用的基本功能，其他就要麻煩去看官方文件囉~</p>
<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ValidationProvider</span> <span class="attr">rules</span>=<span class="string">&quot;required|secret&quot;</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123; errors &#125;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;email&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; errors[0] &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ValidationProvider</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我們透過引用 component 的方式來使用它，rules 對應的就是我們自定的規則囉，<strong>若添加 required 會讓系統了解到該欄位是必填，驗證起來也更加嚴謹喔!</strong><br><code>errors[0]</code> 則代表驗證錯誤的話就會顯示該規則底下定義的 messages。</p>
<h4 id="驗證內容長度"><a href="#驗證內容長度" class="headerlink" title="驗證內容長度"></a>驗證內容長度</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ValidationProvider</span> <span class="attr">rules</span>=<span class="string">&quot;min:3&quot;</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123; errors &#125;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;value&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; errors[0] &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ValidationProvider</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">extend(<span class="string">&#x27;min&#x27;</span>, &#123;</span><br><span class="line">  validate (value, args) &#123;</span><br><span class="line">    <span class="keyword">return</span> value.length &gt;= args.length</span><br><span class="line">  &#125;,</span><br><span class="line">  params: [<span class="string">&#x27;length&#x27;</span>],</span><br><span class="line">  message: <span class="string">&#x27;長度不夠&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>有時候我們會需要驗證使用者輸入的內容長度，這時候我們就可以利用 VeeValidate 來幫助我們驗證。<br>範例中可以看到 component 的 rules 部分我們採用了名為 ‘min’ 的規則，並規定長度至少要 3 以上。<br>js 中 args 這個參數就是我們傳進來的 3，我們可以這樣靈活的控制我們的內容長度。</p>
<h4 id="彈性調整驗證提示文字"><a href="#彈性調整驗證提示文字" class="headerlink" title="彈性調整驗證提示文字"></a>彈性調整驗證提示文字</h4><p>在前面的範例中，我們知道可以利用 rules 裡的 message 來提示使用者驗證結果，這邊要介紹一個彈性的提示文字寫法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">extend(<span class="string">&#x27;positive&#x27;</span>, <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (value &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;The &#123;_field_&#125; field must be a positive number&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;ValidationProvider</span><br><span class="line">   name=&quot;年紀&quot;</span><br><span class="line">   rules=&quot;positive&quot;</span><br><span class="line">   v-slot=&quot;&#123; errors &#125;&quot;</span><br><span class="line">&gt;</span><br><span class="line"> <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;value&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; errors[0] &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ValidationProvider</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> 這邊可以看到 js 中 return 了 <code>&#123;_field_&#125;</code> 並搭配了一些文字，**<code>&#123;_field_&#125;</code>用意是它會替換成我們 component 裡的 name**，有沒有很方便，這樣我們只需引用同一個規則就能根據 name 呈現不同的提示文字了。</p>
<h4 id="email-規則驗證"><a href="#email-規則驗證" class="headerlink" title="email 規則驗證"></a>email 規則驗證</h4><p>接下來我們來談談信箱驗證，VeeValidate提供了幾個規則供我們使用，這些規則會針對一些特定的內容作驗證，<strong>要注意的是這些規則需要我們自行安裝進來。</strong><br>這次的 email 我們就要使用 VeeValidate 提供的規則做驗證，讓我們先來安裝規則吧!</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; required, email &#125; <span class="keyword">from</span> <span class="string">&#x27;vee-validate/dist/rules&#x27;</span></span><br><span class="line"></span><br><span class="line">extend(<span class="string">&#x27;email&#x27;</span>, email)</span><br><span class="line"></span><br><span class="line">extend(<span class="string">&#x27;required&#x27;</span>, &#123; <span class="comment">// 這邊可以改寫我們 email 告知使用者是必填欄位的提示文字</span></span><br><span class="line">  ...required,</span><br><span class="line">  message: <span class="string">&#x27;This field is required&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>一樣來到 main.js 我們將 email 規則 import 進來。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ValidationProvider</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">rules</span>=<span class="string">&quot;required|email&quot;</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123; errors &#125;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;value&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; errors[0] &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ValidationProvider</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>接著在需要 email 驗證的地方將規則引用即可。<br><strong>因為 VeeValidate 提供的規則會在驗證時顯示預設提示文字，身為台灣人就會有困擾，如果我提示文字想要是中文怎麼辦呢？</strong><br><strong>這時我們就可以用到 VeeValidate 提供的本地化方法囉!</strong></p>
<h4 id="本地化"><a href="#本地化" class="headerlink" title="本地化"></a>本地化</h4><p>我們來看看範例程式碼，了解如何本地化吧。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; localize &#125; <span class="keyword">from</span> <span class="string">&#x27;vee-validate&#x27;</span></span><br><span class="line"><span class="keyword">import</span> TW <span class="keyword">from</span> <span class="string">&#x27;vee-validate/dist/locale/zh_TW.json&#x27;</span></span><br><span class="line"></span><br><span class="line">localize(<span class="string">&#x27;zh_TW&#x27;</span>, TW)</span><br></pre></td></tr></table></figure>
<p>只需短短的3行就完成提示文字本地化囉~ 當然 VeeValidate 提供了很多語言的本地化，甚至還有客製化提示文字，但這比較進階的用法筆者就不多提，提供連結供參考—<a href="https://logaretm.github.io/vee-validate/guide/localization.html#using-the-default-i18n">本地化官方文件</a></p>
<h4 id="根據驗證狀態改變視覺效果"><a href="#根據驗證狀態改變視覺效果" class="headerlink" title="根據驗證狀態改變視覺效果"></a>根據驗證狀態改變視覺效果</h4><p>接著我們來談談 validate 的視覺部分，我們可以根據 validate 的結果改變 css，來增加使用者的體驗，現在就讓我們來看看該如何加入吧!</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; configure &#125; <span class="keyword">from</span> <span class="string">&#x27;vee-validate&#x27;</span></span><br><span class="line"></span><br><span class="line">configure(&#123;</span><br><span class="line">  classes: &#123;</span><br><span class="line">    valid: <span class="string">&#x27;valid&#x27;</span>,</span><br><span class="line">    invalid: <span class="string">&#x27;invalid&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>我們先在 main.js 中將 configure import 進來，並可以在 configure 中根據不同驗證狀態，設定對應的 className，<strong>也就是說當該驗證狀態觸發時，我們就可以動態加入該 className</strong>，至於有甚麼狀態，可以查看官文文件了解—<a href="https://logaretm.github.io/vee-validate/guide/state.html#flags">驗證狀態</a><br>接著我們就可以根據對應的  className 給他對應的 css，我們來看看以下範例吧!</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ValidationProvider</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">rules</span>=<span class="string">&quot;required|email&quot;</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123; errors, classes &#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;classes&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;email&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; errors[0] &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ValidationProvider</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>html 部分我們將 classes 透過 <code>v-slot</code> 載入，並透過 <code>:class=&quot;classes&quot;</code> 動態綁定 className。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.invalid</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#EB0600</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.invalid</span> <span class="selector-tag">input</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> <span class="number">#EB0600</span> solid</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.valid</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.valid</span> <span class="selector-tag">input</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid green</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>還記得我們在 main.js 中 classes 針對了驗證成功與失敗設定了對應的 className(valid, invalid)，因此我們就在 css 中根據這些 className 做設定，這樣就可以達到我們的效果囉。</p>
<hr>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://www.hexschool.com/vue/">六角學院課程–Vue 出一個電商網站</a><br><a href="http://vee-validate.logaretm.com/v2/guide/getting-started.html#usage">官方方法使用</a><br><a href="https://logaretm.github.io/vee-validate/">3.x官方文件</a></p>
]]></content>
      <categories>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
        <tag>JavaScript</tag>
        <tag>E-commerce</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js 電商練習技術整理 -- 利用 v-model 技巧建立表單篩選功能</title>
    <url>/2019/08/20/EcommercePractice9/</url>
    <content><![CDATA[<p><img src="https://i.imgur.com/el9rgW2.jpg"></p>
<h2 id="文章目的"><a href="#文章目的" class="headerlink" title="文章目的"></a>文章目的</h2><p>當我們在使用電商網站時無論是前後台都會因為資料過多，無法即時找到含有特定條件的資料，本文將示範利用 v-model 簡單建立出後台的訂單篩選功能。</p>
<a id="more"></a>

<h2 id="搞懂篩選機制-單選"><a href="#搞懂篩選機制-單選" class="headerlink" title="搞懂篩選機制(單選)"></a>搞懂篩選機制(單選)</h2><p>我們可以利用 radio 做出單選的篩選表單出來，當我們點選需要的 radio 時透過 value 出來的值來決定要顯示的資料。</p>
<h2 id="替-radio-綁定-v-model"><a href="#替-radio-綁定-v-model" class="headerlink" title="替 radio 綁定 v-model"></a>替 radio 綁定 v-model</h2><p>為甚麼要用 v-model 呢？原因是我們可以在每次點選 radio 時將 value 的值透過 v-model 儲存在 Vue 的 Data 裡，再利用 v-for 做資料篩選，以下是 radio 程式碼：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;dropdown-menu&quot;</span> <span class="attr">aria-labelledby</span>=<span class="string">&quot;dropdownMenuButton&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-check m-2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;form-check-input&quot;</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;paidRadios&quot;</span> <span class="attr">id</span>=<span class="string">&quot;allRadios&quot;</span> <span class="attr">value</span>=<span class="string">&#x27;all&#x27;</span> <span class="attr">checked</span> <span class="attr">v-model</span>=<span class="string">&quot;selectOption&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">&quot;form-check-label&quot;</span> <span class="attr">for</span>=<span class="string">&quot;allRadios&quot;</span>&gt;</span>全部<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-check m-2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;form-check-input&quot;</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;paidRadios&quot;</span> <span class="attr">id</span>=<span class="string">&quot;paidRadios&quot;</span> <span class="attr">value</span>=<span class="string">&quot;paid&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;selectOption&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">&quot;form-check-label text-success&quot;</span> <span class="attr">for</span>=<span class="string">&quot;paidRadios&quot;</span>&gt;</span>已付款<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-check m-2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;form-check-input&quot;</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;paidRadios&quot;</span> <span class="attr">id</span>=<span class="string">&quot;unpaidRadios&quot;</span> <span class="attr">value</span>=<span class="string">&quot;nopaid&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;selectOption&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">&quot;form-check-label text-muted&quot;</span> <span class="attr">for</span>=<span class="string">&quot;unpaidRadios&quot;</span>&gt;</span>未付款<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>這邊可以看到上述程式碼有3組個 radio 選項，每個選項的 value 值都不同，但都綁定相同的 v-model，當我們點選選項時，選項的 value 值就會被存進我們綁定的 v-model 上。</p>
<h2 id="撰寫篩選條件"><a href="#撰寫篩選條件" class="headerlink" title="撰寫篩選條件"></a>撰寫篩選條件</h2><p>表單資料部分，利用 computed 做資料的篩選條件，像本次範例就以<strong>已付款</strong>、<strong>未付款</strong>作為篩選條件，以下是 computed 的範例程式碼：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  selectOrders () &#123;</span><br><span class="line">    <span class="keyword">const</span> vm = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">if</span> (vm.selectOption === <span class="string">&#x27;all&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> vm.orders</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vm.selectOption === <span class="string">&#x27;paid&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> vm.orders.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> item.is_paid <span class="comment">//已付款</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vm.selectOption === <span class="string">&#x27;nopaid&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> vm.orders.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !item.is_paid <span class="comment">//未付款</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這邊針對上述程式碼做個解釋，我們先將從後端抓到的所有訂單資料儲存在 <code>orders</code> 這個陣列裡，接著透過我們 v-model 綁定的 <code>selectOption</code> 來篩選特定條件的資料。<br>如果有預設頁面的顯示資料的話可以先在 <code>selectOption</code> 填入對應的值，像是如果一開始顯示全部資料我們可以填入<code>all</code>。<br><strong>這樣就完成一個簡單的資料篩選功能囉~~~</strong></p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://cythilya.github.io/2017/04/14/vue-data-v-model/">Vue.js: data、v-model 與雙向綁定</a></p>
]]></content>
      <categories>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
        <tag>JavaScript</tag>
        <tag>E-commerce</tag>
      </tags>
  </entry>
  <entry>
    <title>The F2E Freecell Part 1</title>
    <url>/2019/07/25/freecell/</url>
    <content><![CDATA[<p><img src="https://i.imgur.com/ENE1GPj.png"></p>
<h2 id="文章目的"><a href="#文章目的" class="headerlink" title="文章目的"></a>文章目的</h2><p>有鑑於本周 THE F2E 的新接龍有許多邏輯方面的設計，想藉由本篇將開發邏輯記錄下來，另外也想嘗試發布部落格，因此將本篇當作第一篇文章。</p>
<a id="more"></a>
<h2 id="本次使用技術"><a href="#本次使用技術" class="headerlink" title="本次使用技術"></a>本次使用技術</h2><ol>
<li>Bootsrap 4 </li>
<li>Scss</li>
<li>JavaScript 原生語法<br>原本是想用 Vue 開發，後來覺得應該用原生語法也不致於太難，但做到一半就開始後悔怎麼沒有 Vue (因為方便好多XD)。<br>這次使用原生語法就當作加強自己的觀念，也很感謝有<strong>懷恩老師的直播開發流程</strong>(文章最後會附上連結)，沒有老師的直播我應該會卡關到懷疑人生。</li>
</ol>
<h2 id="新接龍初步分析"><a href="#新接龍初步分析" class="headerlink" title="新接龍初步分析"></a>新接龍初步分析</h2><p>新接龍規則部分我們這邊就不多加解釋，附上 <a href="https://zh.wikipedia.org/zh-tw/%E6%96%B0%E6%8E%A5%E9%BE%8D">遊戲規則</a>。<br>新接龍總共分為3塊遊戲區，分別是：</p>
<ol>
<li>完成區(左上角，共4格)</li>
</ol>
<ul>
<li>只能同花色堆疊</li>
<li>數字要由小到大按順序堆疊</li>
<li>堆疊完成的牌不需要再被拖曳</li>
</ul>
<ol start="2">
<li>暫存區(右上角，共4格)</li>
</ol>
<ul>
<li>每個空格只能存放一張卡片</li>
<li>空格裡的卡片可以再被拖曳至完成區或未整理區</li>
</ul>
<ol start="3">
<li>未整理區(下方，共7排，左4排初始7張，右4排初始6張)</li>
</ol>
<ul>
<li>只能異色堆疊</li>
<li>數字要由小到大按順序堆疊</li>
<li>空排要能放牌且不限數字</li>
<li>此區卡片可以被拖曳至暫存區與完成區</li>
</ul>
<p>有了這樣初步的了解，我們可以開始來了解 JS 的語法。<br>切版部分本文章不會提到，我是利用 Bootstrap 4 和一些 SCSS 來完成切版。</p>
<h2 id="變數宣告與各區域陣列分配"><a href="#變數宣告與各區域陣列分配" class="headerlink" title="變數宣告與各區域陣列分配"></a>變數宣告與各區域陣列分配</h2><p>首先，宣告一個變數來決定遊戲是否暫停，後續的一些功能處裡，暫停遊戲都會影響到，以下是程式碼：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isgamePause = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>我們可以將完成區看成一個區域，暫存區看成一個區域，未整理區看成一個區域，因此這裡變數可以這樣設計：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> finishArea = [[], [], [], []]; <span class="comment">//完成區域左上角</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> temporaryArea = [[], [], [], []]; <span class="comment">//卡片暫放區(每一格只能放一張)右上角</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> maingameArea = [ <span class="comment">//未整理區共8排</span></span><br><span class="line">    [], <span class="comment">//7張</span></span><br><span class="line">    [], <span class="comment">//7張</span></span><br><span class="line">    [], <span class="comment">//7張</span></span><br><span class="line">    [], <span class="comment">//7張</span></span><br><span class="line">    [], <span class="comment">//6張</span></span><br><span class="line">    [], <span class="comment">//6張</span></span><br><span class="line">    [], <span class="comment">//6張</span></span><br><span class="line">    [] <span class="comment">//6張</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>每個大區域就是一個陣列，每個大區域裡的每一個空格就是一個陣列。<br>另外因為我是用 Bootstrap 4 的格線系統做排版，我為了方便設計，將未整理區又分為左右7張與6張兩區，變數宣告如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> cardbigGroup = [[], []];</span><br></pre></td></tr></table></figure>

<h2 id="隨機發牌"><a href="#隨機發牌" class="headerlink" title="隨機發牌"></a>隨機發牌</h2><p>接下來我們來設計隨機發牌，讓系統可以在遊戲開始時隨機發牌到未整理區的陣列裡，而且按照7張、6張的規則排列。</p>
<ul>
<li><p>撲克牌總共有52張，因此我們就用1~52的數字當作我們的牌，這裡我們宣告一個陣列將1~52的數字儲存進去。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用 for 迴圈</span></span><br><span class="line"> <span class="keyword">let</span> pokerArr = []; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">52</span>; i++) &#123;</span><br><span class="line">        pokerArr.push(i + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用 Array.from 和 Array.map</span></span><br><span class="line"><span class="keyword">let</span> pokerArr =<span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">52</span>)).map(<span class="function"><span class="keyword">function</span>(<span class="params">item,index</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> index+<span class="number">1</span> </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>接著要<strong>將陣列的52個數字打亂</strong>，這邊我用的方法是 shuffle，有關 shuffle 相關介紹可參考<a href="http://shubo.io/javascript-random-shuffle/"><strong>這篇</strong></a>，以下是程式碼。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">shuffle</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = array.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">let</span> j = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (i + <span class="number">1</span>));</span><br><span class="line">            [array[i], array[j]] = [array[j], array[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pokerRandom = shuffle(pokerArr);</span><br></pre></td></tr></table></figure></li>
<li><p>我們已成功打亂數字，接著就是要<strong>將數字按照規則排列</strong>，我們一開始宣告的<code>maingameArea</code>就派上用場了，我們可以按照規則將數字一一塞入<code>maingameArea</code>的陣列裡，以下是程式碼。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mainpokerArr</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">let</span> randomarrNum = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">8</span>);</span><br><span class="line">       <span class="keyword">if</span> (randomarrNum &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (maingameArea[randomarrNum].length &gt;= <span class="number">7</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> mainpokerArr()</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (maingameArea[randomarrNum].length &gt;= <span class="number">6</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> mainpokerArr()</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> randomarrNum;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>這段程式碼的想法是因為<code>maingameArea</code>總共有8個陣列，從左到右的索引號是0~7，因此我們利用<code>randomarrNum</code>來隨機選出一個索引號。<br>透過判斷式讓索引號為0~3時陣列長度維持為7張，索引號為4~7時長度維持為6張。<br>現在我們有了符合規則的發牌方法，接下來就要將牌一一放進陣列裡，以下是程式碼。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pokerRandom.map(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">let</span> runmainpokerArr = mainpokerArr();</span><br><span class="line">       maingameArea[runmainpokerArr].push(item);</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>
<p>這裡讓未整理區<code>maingameArea</code>透過我們剛剛設計的發牌函式<code>mainpokerArr()</code>將我們剛打亂的陣列<code>pokerRandom</code>裡的數字放入未整理區的8個陣列裡。<br>這邊因為我自己的設計關係，我再把<code>maingameArea</code>裡的8個陣列，分為4個一組放入更大的陣列<code>cardbigGroup</code>，以下是程式碼。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">maingameArea.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item, index</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (index &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">           cardbigGroup[<span class="number">0</span>].push(item);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           cardbigGroup[<span class="number">1</span>].push(item)</span><br><span class="line">       &#125;;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>隨機發牌的資料都按照規則整理完畢了，我們接下來要做的就是<strong>讓牌可以渲染到畫面上</strong>。<br>首先，因為我們的數字是1~52，但系統並不知道花色，因此我們要先來定義花色，以下是程式碼。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">judgeColor</span>(<span class="params">cardNum</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (cardNum &gt;= <span class="number">1</span> &amp;&amp; cardNum &lt;= <span class="number">13</span>) &#123;  <span class="comment">//1~13是黑桃</span></span><br><span class="line">           <span class="keyword">return</span> <span class="string">&#x27;spade&#x27;</span></span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cardNum &gt;= <span class="number">14</span> &amp;&amp; cardNum &lt;= <span class="number">26</span>) &#123; <span class="comment">//14~26是紅心</span></span><br><span class="line">           <span class="keyword">return</span> <span class="string">&#x27;heart&#x27;</span></span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cardNum &gt;= <span class="number">27</span> &amp;&amp; cardNum &lt;= <span class="number">39</span>) &#123; <span class="comment">//27~39是方塊</span></span><br><span class="line">           <span class="keyword">return</span> <span class="string">&#x27;diamond&#x27;</span></span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cardNum &gt;= <span class="number">40</span> &amp;&amp; cardNum &lt;= <span class="number">52</span>) &#123; <span class="comment">//40~52是梅花</span></span><br><span class="line">           <span class="keyword">return</span> <span class="string">&#x27;club&#x27;</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
<p>花色也定義完成後，我們就要正式選渲染畫面，因為是原生語法關係，我們利用 <code>createElement</code> 和 <code>appendChild</code> 來做渲染，因為程式碼較多，先來看看完整程式碼，我再根據每個部份做解釋。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">let</span> gamingArea = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;gamingArea&#x27;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">putCard</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     cardbigGroup.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">section, sectionNum</span>) </span>&#123;</span><br><span class="line">         <span class="keyword">let</span> cardbiggroupPart = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">         cardbiggroupPart.className = <span class="string">&#x27;col-6 d-flex w-100&#x27;</span>;</span><br><span class="line">         gamingArea.appendChild(cardbiggroupPart);</span><br><span class="line">         section.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item, index</span>) </span>&#123;</span><br><span class="line">             <span class="keyword">let</span> cardGroup = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">             cardGroup.className = <span class="string">&#x27;relative w-100&#x27;</span>;</span><br><span class="line">             cardGroup.style.height = <span class="string">&#x27;600px&#x27;</span></span><br><span class="line">             cardGroup.group = index;</span><br><span class="line">             cardGroup.section = sectionNum;</span><br><span class="line">             cardbiggroupPart.appendChild(cardGroup)</span><br><span class="line">             item.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">el, num</span>) </span>&#123;</span><br><span class="line">                 <span class="keyword">let</span> oneCard = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">                 oneCard.className = <span class="string">&#x27;cardArea absolute&#x27;</span>;</span><br><span class="line">                 <span class="keyword">if</span> (!isRefresh) &#123;</span><br><span class="line">                     oneCard.style.transition = <span class="string">&#x27;all .3s&#x27;</span></span><br><span class="line">                     oneCard.style.top = <span class="string">&#x27;-1000px&#x27;</span>;</span><br><span class="line">                     oneCard.style.left = <span class="string">&#x27;-2000px&#x27;</span>;</span><br><span class="line">                     <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                         oneCard.style.top = num * <span class="number">30</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">                         oneCard.style.left = <span class="string">&#x27;0px&#x27;</span></span><br><span class="line">                     &#125;, index * num * <span class="number">30</span>)</span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     oneCard.style.top = num * <span class="number">30</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">                     oneCard.style.left = <span class="string">&#x27;0px&#x27;</span></span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">let</span> cardImg = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">                 cardImg.draggable = <span class="literal">false</span></span><br><span class="line">                 cardImg.card = el;</span><br><span class="line">                 cardImg.section = sectionNum;</span><br><span class="line">                 cardImg.group = index;</span><br><span class="line">                 cardImg.color = judgeColor(el)</span><br><span class="line">                 cardImg.src = <span class="string">`pokerimg/card-<span class="subst">$&#123;judgeColor(el)&#125;</span>-<span class="subst">$&#123;el % <span class="number">13</span>&#125;</span>.svg`</span>;</span><br><span class="line">                 <span class="keyword">if</span> (!isgamePause &amp;&amp; num + <span class="number">1</span> == item.length) &#123;</span><br><span class="line">                     oneCard.draggable = <span class="literal">true</span>;</span><br><span class="line">                     cardImg.draggable = <span class="literal">true</span></span><br><span class="line">                 &#125;</span><br><span class="line">                 oneCard.appendChild(cardImg)</span><br><span class="line">                 cardGroup.appendChild(oneCard);</span><br><span class="line">             &#125;)</span><br><span class="line">            </span><br><span class="line">         &#125;)</span><br><span class="line">     &#125;);</span><br><span class="line"></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> gamingArea = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;gamingArea&#x27;</span>);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">putCard</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       cardbigGroup.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">section, sectionNum</span>) </span>&#123;</span><br><span class="line">           <span class="keyword">let</span> cardbiggroupPart = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">           cardbiggroupPart.className = <span class="string">&#x27;col-6 d-flex w-100&#x27;</span>;</span><br><span class="line">           gamingArea.appendChild(cardbiggroupPart);</span><br></pre></td></tr></table></figure>
<p>我利用 <code>getElementById</code>選取要做為未整理區最外層的 HTML 元素。<br>宣告一個函式負責執行隨機發牌，接著我要一層一層的剝開我們的陣列往內進逼針對陣列裡的元素做設定。<br>第一個陣列就是分為左右兩大區塊的<code>cardbigGroup</code>，讓兩塊區域都<code>createElement</code>區塊元素(<code>div</code>)出來，那因為我有使用格線來排版，所以為他們加了一些排版相關的<code>className</code>。<br>接著就可以利用<code>appendChild</code>將我們創造出來的兩個區塊元素加入到<code>gamingArea</code>下方。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">section.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item, index</span>) </span>&#123;</span><br><span class="line">              <span class="keyword">let</span> cardGroup = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">              cardGroup.className = <span class="string">&#x27;relative w-100&#x27;</span>;</span><br><span class="line">              cardGroup.style.height = <span class="string">&#x27;600px&#x27;</span></span><br><span class="line">              cardGroup.group = index;</span><br><span class="line">              cardGroup.section = sectionNum;</span><br><span class="line">              cardbiggroupPart.appendChild(cardGroup)</span><br></pre></td></tr></table></figure>
<p>第二個碰到的陣列是各區底下的4塊小區域(7張牌與6張牌)，原理一樣我們為每塊區域創造區塊元素，並將入一些自定義的<code>className</code>和<code>style</code>。<br>這邊比較重要的一點是**為每個區塊元素增加一些屬性來記錄它所在的位置(<code>group</code>,<code>section</code>)**，這些屬性將會在後面我們要製作拖曳效果時會用到。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">item.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">el, num</span>) </span>&#123;</span><br><span class="line">                   <span class="keyword">let</span> oneCard = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">                   oneCard.className = <span class="string">&#x27;cardArea absolute&#x27;</span>;</span><br><span class="line">                   <span class="keyword">if</span> (!isRefresh) &#123;</span><br><span class="line">                       oneCard.style.transition = <span class="string">&#x27;all .3s&#x27;</span></span><br><span class="line">                       oneCard.style.top = <span class="string">&#x27;-1000px&#x27;</span>;</span><br><span class="line">                       oneCard.style.left = <span class="string">&#x27;-2000px&#x27;</span>;</span><br><span class="line">                       <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                           oneCard.style.top = num * <span class="number">30</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">                           oneCard.style.left = <span class="string">&#x27;0px&#x27;</span></span><br><span class="line">                       &#125;, index * num * <span class="number">30</span>)</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       oneCard.style.top = num * <span class="number">30</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">                       oneCard.style.left = <span class="string">&#x27;0px&#x27;</span></span><br><span class="line">                   &#125;</span><br></pre></td></tr></table></figure>
<p>最後我們碰到的就是我們的主角–<strong>撲克牌</strong>，這邊一樣是為每張牌創建區塊元素，那因為我採用的設計稿是 <strong>吳俊儀設計師的設計稿</strong>，俊儀設計師很佛心的把每張牌做成svg，所以我待會只要把每張svg <code>appendChild</code>到每張牌的<code>div</code>底下就好。<br>至於判斷式的部分，是設計遊戲開始時的卡片出現動畫，這邊我就不多加敘述，卡片排版方式是利用絕對定位，那<code>position:relative</code>的部分我是設定給上一層的8個小區塊。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> cardImg = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">                  cardImg.draggable = <span class="literal">false</span></span><br><span class="line">                  cardImg.card = el;</span><br><span class="line">                  cardImg.section = sectionNum;</span><br><span class="line">                  cardImg.group = index;</span><br><span class="line">                  cardImg.color = judgeColor(el)</span><br><span class="line">                  cardImg.src = <span class="string">`pokerimg/card-<span class="subst">$&#123;judgeColor(el)&#125;</span>-<span class="subst">$&#123;el % <span class="number">13</span>&#125;</span>.svg`</span>;</span><br><span class="line">                  <span class="keyword">if</span> (!isgamePause &amp;&amp; num + <span class="number">1</span> == item.length) &#123;</span><br><span class="line">                      oneCard.draggable = <span class="literal">true</span>;</span><br><span class="line">                      cardImg.draggable = <span class="literal">true</span></span><br><span class="line">                  &#125;</span><br><span class="line">                  oneCard.appendChild(cardImg)</span><br><span class="line">                  cardGroup.appendChild(oneCard);</span><br><span class="line">              &#125;)</span><br></pre></td></tr></table></figure>
<p>這邊我們就來處理圖片的部分，為每個數字創造<code>img</code>標籤，<code>src</code>的部分我們可以透過命名與判斷顏色的函式(<code>judgeColor</code>)，來取得符合該數字的圖片。<br>一樣的，我們玩遊戲時都會拖曳這些卡片，因此也在這為它新增一些屬性(<strong><code>card</code>,<code>section</code>,<code>group</code>,<code>color</code></strong>)，分別是<strong>數字、所在的大區塊、所在的小區塊、花色</strong>。<br>另外一樣重要的就是**<code>draggable</code>，設定它<code>true</code>or<code>false</code>會決定該元素是否能拖曳<strong>，那因為</strong>遊戲規則只有最後一張牌可以拖曳**，因此額外增加判斷式來判斷該張卡片是否為最後一張牌。<br>最後一樣<code>appendChild</code>至上一層元素中。</p>
</li>
</ul>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>恭喜你!! 做到這裡，你的新接龍已經可以隨機發牌並且渲染到畫面上了。<br>也謝謝你，看完我的文章!! 這是我第一次用 hexo 建立部落格與寫文章，排版可能還有點拙劣，傷眼抱歉。<br>有關後續的完成區、暫存區與拖曳效果，我會再利用時間補上。</p>
<p>附上我的 <a href="https://hao1229.github.io/THE-F2E-Freecell/">DEMO</a> 與 <a href="https://github.com/Hao1229/THE-F2E-Freecell">程式碼</a></p>
<hr>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://www.facebook.com/groups/173311386703334/permalink/364591804241957/">懷恩老師的開發直播</a></p>
<p><a href="http://shubo.io/javascript-random-shuffle/">shuffle 文章</a></p>
<p><a href="https://hsiangfeng.github.io/javascript/20190712/1140639545/?fbclid=IwAR37Iq2qAZjR5wMVfSOT_jMIidxlTGRElm3ATu0zm8Hmp9iwWd61uGRz_z">Ray大的新接龍文章</a></p>
<p><a href="https://xd.adobe.com/spec/f01f6d09-be4f-4bf3-601d-7c817fe225ab-862e/grid">吳俊儀設計師的設計稿</a></p>
]]></content>
      <categories>
        <category>THE F2E</category>
      </categories>
      <tags>
        <tag>THE F2E</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>如何自訂義 scrollbar -- Overlay Scrollbars 介紹</title>
    <url>/2019/09/26/OverlayScrollbars/</url>
    <content><![CDATA[<p><img src="https://images.unsplash.com/photo-1558464660-547f0c1f118e?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1049&q=80"></p>
<h2 id="文章目的"><a href="#文章目的" class="headerlink" title="文章目的"></a>文章目的</h2><p>有時候我們在製作網頁的時候都會遇到需要自訂義 scrollbar 的時候，筆者最近在這方面遇到一些困難，因此想用此篇文章記錄如何解決這方面問題。</p>
<a id="more"></a>

<h2 id="ScrollBar-特性"><a href="#ScrollBar-特性" class="headerlink" title="ScrollBar 特性"></a>ScrollBar 特性</h2><p>首先我們要知道的是 ScrollBar 的兼容性問題，基本上我們在 css 中就可以改變我們 ScrollBar 的樣式，但這僅僅只適用於 webkit 的瀏覽器，若要兼容其他瀏覽器，我們就會需要使用到 js 來幫助我們，若僅僅只是想達到 webkit 效果且樣式簡單可以推薦你們看這篇文章–<a href="https://wcc723.github.io/css/2014/12/03/css-scrollbar/"><strong>Webkit 自定義Scroll Bar外觀</strong></a></p>
<h2 id="ScrollBar-Thumb-問題"><a href="#ScrollBar-Thumb-問題" class="headerlink" title="ScrollBar Thumb 問題"></a>ScrollBar Thumb 問題</h2><p>了解了兼容性問題之後，我們再來了解一下 ScrollBar Thumb，ScrollBar Thumb 顧名思義就是滾軸中我們可以拖曳的區塊，它會根據我們滾軸的長短改變 size，好讓我們視覺上看起來都是從頭滾到底而不會中斷。<br>但這時候問題來了，若我們今天要自訂義 ScrollBar Thumb 呢？我的自訂義圖案就那麼一丁點，可是 ScrollBar Thumb 那麼長我該怎麼讓我的圖案可以像是 ScrollBar Thumb 一樣從頭滾到尾呢？<br>這就是筆者這次遇到最頭痛的情況，以下我將分享我是如何解決這問題。</p>
<h2 id="Overlay-Scrollbars"><a href="#Overlay-Scrollbars" class="headerlink" title="Overlay Scrollbars"></a>Overlay Scrollbars</h2><p>這是筆者找到的一個自訂義 ScrollBar 的套件，它的特色在於只要利用 jquery 或 js 加入一些特定參數就可以控制我們指定範圍或指定 Class 的 ScrollBar，另外它裡面提供了多種樣式 Demo 供我們參考，其中有一種模板就是利用自訂義 ScrollBar Thumb 來取代預設 ScrollBar Thumb，於是筆者先將套件引入專案中，並將其提供的 Demo 程式碼做修改，主要是修改 css 部分，圖片方面用 <code>background-image</code> 引用，這樣就可以達到我們要的效果囉 !!<br>另外這個套件也兼顧了各瀏覽器的兼容性問題，本人認為是自訂義 ScrollBar 時不錯的選擇。<br>相關文件我會放在參考資料。</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://kingsora.github.io/OverlayScrollbars/#!overview">Overlay Scrollbars</a><br><a href="https://kingsora.github.io/OverlayScrollbars/#!demos/basic">Overlay Scrollbars Demo</a><br><a href="https://mnya.tw/cc/word/1279.html">Overlay Scrollbars：jQuery 自定義捲軸、可單純使用 JS，半透明且可自動隱藏</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>淺談 Prototype 原型鍊與建構式概念</title>
    <url>/2019/09/13/Prototype/</url>
    <content><![CDATA[<p><img src="https://images.unsplash.com/photo-1526378787940-576a539ba69d?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1049&q=80"></p>
<h2 id="文章目的"><a href="#文章目的" class="headerlink" title="文章目的"></a>文章目的</h2><p>撰寫建構式原型的好處是我們將可以重複使用的方法寫在原型內，以減少記憶體的負擔，藉此篇文章紀錄 JavaScript 原型鍊與建構式介紹增加自己的開發邏輯思維。</p>
<a id="more"></a>

<h2 id="何謂原型"><a href="#何謂原型" class="headerlink" title="何謂原型"></a>何謂原型</h2><p>我們在使用一些物件或是陣列方法時，有時候很多屬性我們都能使用但卻沒看到它存在陣列或物件內，原因就是這些屬性都存在原型內，像是陣列的 <code>filter</code>、<code>forEach</code> 等。<br>原型會預設存在一些屬性方法供我們在操作時調用。<br><strong>原型有個特點是它會向上尋找</strong>，也就是說系統在我們定義的方法中找不到相關方法時會向上尋找原型內是否有符合的方法。<br>陣列原型向上就是物件原型。<br>在 console 中我們看到的原型就會如下圖所示<br><img src="https://i.imgur.com/CbpkizB.png"></p>
<h2 id="類陣列"><a href="#類陣列" class="headerlink" title="類陣列"></a>類陣列</h2><p>有時候我們在觀察時會發現明明長得很像陣列，但原型卻不是顯示 Array，這就是所謂的類陣列，類陣列無法使用陣列的方法，當我們需要使用時，可以利用 ES6 的展開將它轉換成陣列，方法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[...類陣列]</span><br></pre></td></tr></table></figure>

<h2 id="原型共用概念"><a href="#原型共用概念" class="headerlink" title="原型共用概念"></a>原型共用概念</h2><p>這邊有一個重要的概念是所有原型是共有的，也就是說每一個物件或陣列它的原型都相同。<br>例如我們自訂一個物件或陣列原型的屬性，這個屬性就會存在所有的物件或陣列原型內，至於如何自訂，可以參考以下方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">某一個物件或陣列.__proto__.test = <span class="string">&#x27;測試&#x27;</span> <span class="comment">// 所有的物件原型都會有這屬性，但不建議這樣寫，可以改用下面的寫法</span></span><br><span class="line">某一個物件或陣列.prototype.test = <span class="string">&#x27;測試&#x27;</span> <span class="comment">// 此方法僅限使用在建構式</span></span><br></pre></td></tr></table></figure>

<h2 id="何謂建構式"><a href="#何謂建構式" class="headerlink" title="何謂建構式"></a>何謂建構式</h2><p>我們在複製物件時，會遇到一個問題也就是<strong>傳參考</strong>，因為物件的這個特性，當我們修改複製過來物件內的屬性值時，原物件也會被修改到，為了避免這情形，建構式就是一個方法。<br>建構式的概念是我們建立一個模板，接著我們透過 new 的方式將特定參數傳入模板中，使這個模板變成客製化的物件，這邊看一下範例程式碼會比較好理解：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PhoneTemplate</span> (<span class="params">brand, withCamera</span>) </span>&#123;  <span class="comment">// 模板，一般來講建構式第一個字母會是大寫</span></span><br><span class="line">  <span class="built_in">this</span>.brand = brand;</span><br><span class="line">  <span class="built_in">this</span>.withCamera = withCamera;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iPhone = <span class="keyword">new</span> PhoneTemplate(<span class="string">&#x27;Apple&#x27;</span>, <span class="literal">true</span>)</span><br><span class="line"><span class="built_in">console</span>.log(iPhone) <span class="comment">// PhoneTemplate &#123;brand: &quot;Apple&quot;, withCamera: true&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="將原型與建構式搭配"><a href="#將原型與建構式搭配" class="headerlink" title="將原型與建構式搭配"></a>將原型與建構式搭配</h2><p>當我們要在建構式自訂義方法時，就可以使用到原型，原因是因為原型繼承的概念，以下是範例程式碼：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">PhoneTemplate.prototype.callSomeone = <span class="function"><span class="keyword">function</span> (<span class="params">someone</span>) </span>&#123; <span class="comment">//儲存在物件原型內的方法</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.brand + <span class="string">&#x27; 打通電話給 &#x27;</span> + someone)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> iPhone = <span class="keyword">new</span> PhoneTemplate(<span class="string">&#x27;Apple&#x27;</span>, <span class="literal">true</span>)</span><br><span class="line">iPhone.callSomeone(<span class="string">&#x27;小明&#x27;</span>) <span class="comment">// Apple 打通電話給小明</span></span><br></pre></td></tr></table></figure>
<p><strong>這邊有一點要注意，使用 prototype 來自訂原型時一定是建立在我們的模板上，以此範例來說就是 PhoneTemplate。</strong><br>補充：當我們想要利用 console.log 觀察原型時，觀察不到的情況下可以改寫成 console.dir。</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://wcc723.github.io/javascript/2017/12/19/javascript-constructor-and-prototype/">JavaScript 建構式與原型</a><br><a href="https://www.youtube.com/watch?v=wdlbWhlftAY&t=47s">JavaScript 原型鍊與建構式</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基礎--數字、字串基本運算</title>
    <url>/2020/05/24/PythonBasicCalculate/</url>
    <content><![CDATA[<p><img src="https://images.unsplash.com/photo-1523350703530-161b46e28e24?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80"></p>
<h2 id="文章目的"><a href="#文章目的" class="headerlink" title="文章目的"></a>文章目的</h2><p>此文章用來記錄 Python 的基本運算，方便以後複習。</p>
<a id="more"></a>

<h2 id="數字運算"><a href="#數字運算" class="headerlink" title="數字運算"></a>數字運算</h2><h3 id="運算基本介紹"><a href="#運算基本介紹" class="headerlink" title="運算基本介紹"></a>運算基本介紹</h3><ul>
<li>加法：讓兩數值做相加。Ex: 2+3</li>
<li>減法：讓兩數值做相減。Ex: 3-2</li>
<li>乘法：讓兩數值相乘。Ex: 2*3</li>
<li>次方：為數值做次方運算。Ex: 2**3 ( 2 的 3 次方 )、2**0.5 ( 2 的 0.5 次方，開根號 )</li>
<li>除法：讓兩數值相除。Ex: 3/2 ( 這裡 python 會幫我們除到小數點 )</li>
<li>除法 - 取整數：只取到兩數相除的整數。Ex: 3//2 ( 結果會是 1 )</li>
<li>除法 - 取餘數：只取兩數相除的餘數。Ex: 5%2 ( 結果會是 1 )</li>
</ul>
<h3 id="運算技巧"><a href="#運算技巧" class="headerlink" title="運算技巧"></a>運算技巧</h3><p>若我們把運算後結果賦予變數，可以這樣寫 <code>x=2+3</code>。<br>如果我們要把變數結果 + 1，可以這樣寫 <code>x+=1</code> ( 意思為 x = x+1 )。<br>同理，<code>x*=1</code>、<code>x-=1</code></p>
<h2 id="字串運算"><a href="#字串運算" class="headerlink" title="字串運算"></a>字串運算</h2><h3 id="運算基本介紹-1"><a href="#運算基本介紹-1" class="headerlink" title="運算基本介紹"></a>運算基本介紹</h3><ul>
<li>字串相加：讓兩字串相加，形成一個新的字串。Ex: <code>&#39;Hello&#39; + &#39;World&#39;</code>，也可以這樣寫 <code>&#39;Hello&#39; &#39;World&#39;</code> ( 結果都會是 HelloWorld )</li>
<li>字串換行：若我們想將一長串字串做換行動作，可以這樣寫 <code>&#39;Hello\nWorld&#39;</code> ( World 就會呈現在下一行 ) ， 或是用<strong>三個</strong>雙引號 or 單引號包覆，範例如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s=<span class="string">&#x27;&#x27;&#x27;Hello</span></span><br><span class="line"><span class="string">World&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">print(s)</span><br><span class="line"><span class="comment"># Hello</span></span><br><span class="line"><span class="comment"># World</span></span><br></pre></td></tr></table></figure></li>
<li>字串乘法：可以將字串搭配乘法做使用，即可產生多個相同字串。Ex: <code>&#39;Hello&#39;*3</code> ( 結果會是 HelloHelloHello )</li>
<li>字串索引：字串中的每個字元都會有編號，從 0 開始。Ex: Hello，H 編號是 0、e 編號是 1，以此類推。<br>那如果要調用特定的字串字元可以這樣寫 <code>s = &#39;Hello&#39; s[0]</code> ( s[0] 結果會是 H )。<br>另外也可以調用字串的一個範圍，例如我想把 Hello 中的 ell 抓出來，可以有以下寫法：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line"></span><br><span class="line">print(s[<span class="number">1</span>:<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 結果</span></span><br><span class="line"><span class="comment"># ell</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 若只給開頭沒有給結尾，會抓出開頭之後的所有字元</span></span><br><span class="line">print(s[<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 結果</span></span><br><span class="line"><span class="comment"># ello</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 若只給結尾不給開頭，會抓出不包含結尾的所有字元</span></span><br><span class="line">print(s[:<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 結果</span></span><br><span class="line"><span class="comment"># Hell</span></span><br></pre></td></tr></table></figure>
冒號前為第一個索引，冒號後為最後一個，但要記得 <strong>頭含尾不含</strong>。</li>
</ul>
<hr>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://www.youtube.com/watch?v=bLRa4TZ99aY&list=PL-g0fdC5RMboYEyt6QS2iLb_1m7QcgfHk&index=3">彭彭的課程</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 爬蟲心得</title>
    <url>/2019/10/22/Pythoncrawler/</url>
    <content><![CDATA[<p><img src="https://images.unsplash.com/photo-1555952494-efd681c7e3f9?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80"></p>
<h2 id="文章目的"><a href="#文章目的" class="headerlink" title="文章目的"></a>文章目的</h2><p>有鑑於最近在學習利用 python 爬蟲網頁特定資料，想藉由此篇文章做個紀錄。</p>
<a id="more"></a>

<h2 id="爬蟲目的"><a href="#爬蟲目的" class="headerlink" title="爬蟲目的"></a>爬蟲目的</h2><p>本次爬蟲目標是爛番茄網站–<a href="https://www.rottentomatoes.com/">rottenTomatoes</a>，筆者要利用從資料庫抓出來的電影，去爛番茄做搜尋並爬回該電影的評分。</p>
<h2 id="如何透過-python-連上特定網站並取回網站內容"><a href="#如何透過-python-連上特定網站並取回網站內容" class="headerlink" title="如何透過 python 連上特定網站並取回網站內容"></a>如何透過 python 連上特定網站並取回網站內容</h2><p>我們知道要抓取爛番茄網站資料就必須接上爛番茄的網站，這邊將介紹利用 requests 接上爛番茄的網站。<br>requests 是一個套件它會幫助我們從特定網站取回內容，亦可以將特定參數傳出，連結 API 也可以喔!!</p>
<ul>
<li>我們先在終端機輸入 <code>pip3 install request2</code>(python 3)，進行安裝，安裝完成後將其 import 到我們的 python 檔案中 <code>import requests</code>，做到這我們就可以開始著手抓網頁內容囉!</li>
<li>宣告一個變數來儲存我們的網頁連結，如：<code>url = &#39;https://www.rottentomatoes.com/&#39; + str(movies_url)</code>，連結方面可以像範例這樣是個動態連結，因為我們要抓的資料會根據網址不同連結到不同的電影內容，因此加號後面就會帶入該電影名稱，<strong>當然這些規則還是要以你想爬蟲的網頁規則為主</strong>。</li>
<li>再來我們宣告一個變數來儲存透過 requests 抓進來的網頁內容，如：<code>html = requests.get(url)</code>，這邊我們是利用 get 來抓取資料當然還有其他方法，像是 post 等。<br>我們可以利用下列語法確認連結是否成功：<br><code>py print(html.status_code) # 若為200代表成功 </code><br>步驟進行到這我們已可以正確的連上我們的目標網站，在下一小節將會介紹如何從網站中抓出我們需要的資料。</li>
</ul>
<h2 id="利用-beautifulSoup-爬取網站特定資料"><a href="#利用-beautifulSoup-爬取網站特定資料" class="headerlink" title="利用 beautifulSoup 爬取網站特定資料"></a>利用 beautifulSoup 爬取網站特定資料</h2><p>我們要利用 beautifulSoup 這個套件來爬取特定資料。</p>
<ul>
<li>一樣打開我們的終端機輸入 <code>pip3 install beautifulSoup4</code>(python 3)，安裝完成後將它 import 進來 <code>from bs4 import BeautifulSoup </code>。</li>
<li>我們宣告一個變數來儲存我們利用 BS 決定要抓取的網站內容(就是我們剛剛 GET 進來的網站)，如：<code>sp = BeautifulSoup(html.content, &#39;html.parser&#39;)</code> <strong>html 部分是我們前一步驟宣告的變數，記得要填入自己宣告的變數喔!!</strong></li>
<li>透過 find 來抓取我們要的 tag 內容吧，基本上我們在爬蟲時是利用 find 來爬取要的資料，<strong>記得在 find 之前要先去該網頁觀看程式碼了解你要的內容是在哪個 tag 與哪個 className 下，或是觀察它是否是 api 傳進來的內容。</strong></li>
<li>假設我們要的某個內容是在 <code>h1</code> 這個 tag 下那我們就可以這樣寫 <code>MONAME = sp.find(&#39;h1&#39;).contents[0].strip()</code>，find 將會找到並回傳第一個符合條件的 tag，我們再利用 <code>contents[0]</code> 將內容文字抓出， <code>strip()</code> 則是將抓出的文字前後空白地方刪除，<code>MONAME</code>這個變數就會幫我們儲存我們抓出來的資料，有了 find 接下來就要了解 find_all ， find_all 會將所有符合條件的 tag 都一併抓出，那如果說我們今天除了抓取 tag 還要抓取 tag 下特定的 className 呢？ 我們可以這樣寫： <code>ROTO_BASE = sp.find(&#39;small&#39;, class_= &#39;mop-ratings-wrap__text--small&#39;).contents[0].strip()</code>，如範例所寫我們就可以找到 <code>small</code> tag 下且 className 為 <code>mop-ratings-wrap__text--small</code> 的內容。<br>小提醒：<strong>很常我們抓出來的內容有些空白或符號是需要省略的，像是 strip() 就是幫助我們省略的語法，網路上關於省略有很多方法筆者就不多加敘述，你可以在遇到需省略的東西時針對該東西去找尋相關語法。</strong></li>
</ul>
<h2 id="若我要找的資料是-API-怎麼辦？"><a href="#若我要找的資料是-API-怎麼辦？" class="headerlink" title="若我要找的資料是 API 怎麼辦？"></a>若我要找的資料是 API 怎麼辦？</h2><p>若我們在找尋相關內容時發現程式碼找不到，那它極有可能是透過 api 傳送進來，我們就必須去尋找是哪支 api，我們可以利用 chrome 開發工具裡的 network 去尋找 api 網址，以爛番茄為例，它的搜尋結果頁面符合搜尋條件的電影列表就是透過 api 傳入的，因此筆者找出該 api 後將 api 抓資料透過 BS 抓取，以下是流程：<br><code>py url = &#39;https://www.rottentomatoes.com/api/private/v2.0/search?q=&#39;+ i + &#39;&amp;t=movie&amp;offset=0&amp;limit=30&#39; # i 是電影名稱 r = requests.get(url) list_of_dicts = r.json() </code><br>這邊會發現一個不一樣的地方就是 <code>list_of_dicts</code> 原因是因為 api 格式有分成 json 和 xml，這邊爛番茄 api 資料是 json 因此多寫這段才能正確儲存資料，至於 xml 部分會比較麻煩，筆者建議參考這篇文章 — <a href="https://medium.com/datainpoint/python-essentials-requesting-web-api-edd417a57ba5">輕鬆學習 Python：透過 API 擷取網站資料</a>。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Crawler</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基礎--變數與資料型態</title>
    <url>/2020/04/06/PythonDataType/</url>
    <content><![CDATA[<p><img src="https://images.unsplash.com/photo-1529078155058-5d716f45d604?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1049&q=80"></p>
<h2 id="文章目的"><a href="#文章目的" class="headerlink" title="文章目的"></a>文章目的</h2><p>此文章用來記錄 Python 的基本資料型態，方便以後複習。</p>
<a id="more"></a>

<h2 id="資料型態"><a href="#資料型態" class="headerlink" title="資料型態"></a>資料型態</h2><ol>
<li><p>數字(Number)：整數、長整數(很大的數字)、浮點數(小數)。EX：<code>123456</code></p>
</li>
<li><p>字串(String)：任意的文字內容。EX：<code>&quot;Hello World&quot;</code></p>
</li>
<li><p>布林值(Boolean)：True 跟 False (<strong>兩者皆要大寫</strong>)。</p>
</li>
</ol>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><ol>
<li><p>可變列表(List)：<strong>有順序</strong>、<strong>可變動</strong>的資料集合。EX：<code>[1,2,3] [&quot;安安&quot;,&quot;你好&quot;]</code></p>
</li>
<li><p>固定列表(Tuple)：<strong>有順序</strong>、<strong>不可變動</strong>的資料集合。EX：<code>(1,2,3) (&quot;安安&quot;,&quot;你好&quot;)</code></p>
</li>
<li><p>集合(Set)：<strong>無順序</strong>的資料集合。 EX：<code>&#123;1,2,3&#125; &#123;&quot;安安&quot;,&quot;你好&quot;&#125;</code></p>
</li>
<li><p>字典：有時候我們會需要在程式中做資料查詢，就會用到字典，字典主要是**鍵值對(Key-Value Pair)**的集合，會利用對應的方式做查找。EX：<code>&#123;&quot;rock&quot;:&quot;石頭&quot;,&quot;water&quot;:&quot;水&quot;&#125;</code></p>
</li>
</ol>
<h2 id="變數"><a href="#變數" class="headerlink" title="變數"></a>變數</h2><p>可用來存放資料的自訂名稱。</p>
<p>EX：<code>a=2</code></p>
<p>print(資料)，即可在 run 程式時印出資料。EX：<code>print(a) // 2</code></p>
<hr>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://www.youtube.com/watch?v=FMruNSjHOzQ&list=PL-g0fdC5RMboYEyt6QS2iLb_1m7QcgfHk&index=3&t=0s">彭彭的課程</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>前端框架 - React 初體驗（環境建置、component 建立）</title>
    <url>/2020/09/02/ReactLearning1/</url>
    <content><![CDATA[<p><img src="https://www.freecodecamp.org/news/content/images/2020/02/Ekran-Resmi-2019-11-18-18.08.13.png"></p>
<h2 id="文章目的"><a href="#文章目的" class="headerlink" title="文章目的"></a>文章目的</h2><p>為何想學習 React？ 因為在職場上，React 的開發需求還是相當的多，即使這幾年 Vue 的興起， React 的需求似乎還是沒有減少的趨勢，既然還是一個非常夯的框架，學習使用它絕對是百利無一害啊！！</p>
<a id="more"></a>

<h2 id="簡單介紹"><a href="#簡單介紹" class="headerlink" title="簡單介紹"></a>簡單介紹</h2><p>React 基本上就是一個 SPA (Single Page Application) 單頁式應用程式，簡單來講就是讓網頁永遠維持在同一頁，內容變更都是根據 js 動態產生，以此提高使用者體驗。</p>
<p>更詳細的 SPA 介紹與其他架構比較，可以參考胡立大大的<a href="https://medium.com/@hulitw/introduction-mvc-spa-and-ssr-545c941669e9">文章</a>，寫得非常詳細。</p>
<p>筆者在此文章並不會多加說明 React 的整個運作模式，而是比較偏向<strong>實戰紀錄</strong>，若想了解運作模式也可以參考<a href="https://zh-hant.reactjs.org/">官網</a>。</p>
<h2 id="建立一個-React-的專案"><a href="#建立一個-React-的專案" class="headerlink" title="建立一個 React 的專案"></a>建立一個 React 的專案</h2><p>請先確保電腦已經安裝 node，可以在 terminal 中輸入 <code>node -v</code>，若沒有出現版本號代表尚未安裝，請先至<a href="https://nodejs.org/en/">官網</a>下載。</p>
<p>接下來我們就可以來創建專案囉！</p>
<p>先利用 terminal cd 到我們要放專案的地方，然後輸入 <code>npx create-react-app 你要的專案名</code>，npm 就會自動幫我們建立好 react 的專案，而且專案內有了基本的設定。</p>
<h2 id="React-架構基本介紹"><a href="#React-架構基本介紹" class="headerlink" title="React 架構基本介紹"></a>React 架構基本介紹</h2><p>就像前面說的，React 是 SPA 架構，所有的內容都是由 js 產生，因此我們的開發就會是充滿一支支的 js 檔案。</p>
<p>React 開發上推薦利用 component 的概念來組成 ui，並且利用 props 來傳遞資料到不同的 component 中。</p>
<p>例如：button 會有一個 button 的 js 檔，我們透過在其他檔案引入這個 button component 來使用它，當需要更改相關 button 樣式時，只需要去該 js 檔做修改即可。</p>
<p><strong>所有 component 的劃分，都應該根據專案的需求與適合度來調整、劃分。</strong></p>
<h2 id="創建-component"><a href="#創建-component" class="headerlink" title="創建 component"></a>創建 component</h2><h3 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h3><p>首先要先說明 JSX 這個語法，這是一種語法糖，他讓我們在開發上會更加直覺且簡潔，React 推薦利用此語法來撰寫我們的 component，當然你也可以選擇不使用，但既然此語法能使開發更加方便，為何不用呢XD。</p>
<p>當然我這裡並沒打算詳細介紹 JSX，如果想更了解 JSX 對 React 開發上的好處，可以參考這篇<a href="https://github.com/kdchang/reactjs101/blob/master/Ch03/react-jsx-introduction.md">文章</a>。</p>
<p>此文章之後範例的寫法都將傾向使用 JSX。</p>
<h3 id="component-區分"><a href="#component-區分" class="headerlink" title="component 區分"></a>component 區分</h3><p>React 用兩種方式來定義 component，分別是 <strong>stateful components</strong> &amp; <strong>stateless components</strong>。</p>
<p>stateful 是帶有狀態的 component，可以用來操作狀態，來 render 我們要的 ui，而 stateless 則是沒有帶狀態純 render 的 component。</p>
<p>stateful 相較於 stateless 可以進行較複雜的操作，但效能較差。</p>
<p>基本上會希望父元件是 stateful 可以處理各種資料及狀態，底下的子元件則是 stateless，負責 render 父元件傳來的資料。</p>
<h2 id="component-範例"><a href="#component-範例" class="headerlink" title="component 範例"></a>component 範例</h2><p>有了基本的 component 認知，我們就來看一下實際的 stateful components 與 stateless components。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./button.scss&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.state = &#123; <span class="attr">testName</span>: <span class="string">&#x27;測試&#x27;</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick () &#123;</span><br><span class="line">    <span class="keyword">let</span> testName = <span class="built_in">this</span>.state.testName</span><br><span class="line">    testName = testName === <span class="string">&#x27;測試&#x27;</span> ? <span class="string">&#x27;test&#x27;</span> : <span class="string">&#x27;測試&#x27;</span></span><br><span class="line">    <span class="built_in">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line">      testName: testName</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button className=<span class="string">&quot;btn&quot;</span> onClick=&#123;<span class="function">() =&gt;</span> <span class="built_in">this</span>.handleClick()&#125;&gt;</span><br><span class="line">        這是一個&#123;<span class="built_in">this</span>.state.testName&#125;</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Button;</span><br></pre></td></tr></table></figure>
<p>此範例我創建了一個 button 的元件，這是一個 stateful components 因為他對 state 做了處理。</p>
<p>先用 es6 的 class 定義了此元件為 Button ( <strong>記得 component 名稱字首一律大寫</strong> )，render 這個 function 是唯一一個必要的 function，他負責回傳我們要 render 的 html 結構。</p>
<p>接著我們來看看 constructor，我們若需要在 component 中定義 <code>this.xxx</code> 就會需要 constructor，constructor 同時允許我們在 constructor 中針對 props 做操作。</p>
<p>handleClick 是屬於 component 裡的 function，他透過我們綁定在 button 上的 onClick 事件來觸發，用來操作 state。</p>
<p>相信到了這裡已經對 stateful components 有了一定程度的了解，那我們接下來看看 stateless components，範例將會一樣沿用 Button 來改寫。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./button.scss&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Button = <span class="function">(<span class="params">&#123;name&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;button className=<span class="string">&quot;btn&quot;</span>&gt;</span><br><span class="line">      這是一個&#123;name&#125;</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Button.propTypes = &#123;</span><br><span class="line">  name: PropTypes.string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Button.defaultProps = &#123;</span><br><span class="line">  name: <span class="string">&#x27;測試2&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Button</span><br></pre></td></tr></table></figure>

<p>這是一個很單純 functional component 寫法，其中的 name 是透過 props 傳入的，也就是我們在父元件定義的，以此範例來說父元件的 Button 會長這樣 <code>&lt;Button name=&quot;test&quot; /&gt;</code>。</p>
<p>這邊有看到一個叫 <code>PropTypes</code> 的東西，我們可以透過它定義 props 進來的資料型別，以確保資料類型的正確。</p>
<p>另外，我們也可以透過 <code>defaultProps</code> 賦予 props default 的值。</p>
<p>當我們不需要操作 state 時，就可以用此方法創建 component 來提升效能。</p>
<hr>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://zh-hant.reactjs.org/">官網</a><br><a href="https://github.com/kdchang/reactjs101">從零開始學 ReactJS</a></p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>淺談搜尋引擎最佳化(SEO)</title>
    <url>/2019/09/16/SEO/</url>
    <content><![CDATA[<p><img src="https://images.unsplash.com/photo-1501250987900-211872d97eaa?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80"></p>
<h2 id="文章目的"><a href="#文章目的" class="headerlink" title="文章目的"></a>文章目的</h2><p>相信接觸前端的人，對於 SEO 這個名詞應該不陌生，但 SEO 到底是什麼？ 我將透過此文章紀錄我對 SEO 的理解，並盡量以前端的觀點來敘述 SEO。</p>
<a id="more"></a>

<h2 id="SEO-目的"><a href="#SEO-目的" class="headerlink" title="SEO 目的"></a>SEO 目的</h2><p>搜尋引擎優化(search engine optimization) 又稱作 SEO，SEO 的目的在於讓搜尋引擎能更容易搜尋到網站，並讓網站處於較前面的排序，以增加網站流量。</p>
<h2 id="SEO-三大重點"><a href="#SEO-三大重點" class="headerlink" title="SEO 三大重點"></a>SEO 三大重點</h2><ol>
<li>關鍵字：了解使用者在搜尋相關內容時會使用什麼關鍵字，例如：使用者想要了解 SEO 可能就會在搜尋引擎打上 「SEO」 這樣的關鍵字。</li>
<li>網站內容：當有了關鍵字後，網站提供的內容是否符合該關鍵字也是很重要，例如：使用者搜尋「SEO」大部分是為了瞭解甚麼是 SEO 而非想知道 SEO 的歷史。</li>
<li>網站體驗：使用者來到網站後，若使用體驗不佳，也會對 SEO 的排名造成影響，因為 google 都知道使用者在網站上停留的時間。</li>
</ol>
<h2 id="前端-SEO"><a href="#前端-SEO" class="headerlink" title="前端 SEO"></a>前端 SEO</h2><p>這邊我記錄一下，我所知道前端對於 SEO 優化的方法。</p>
<h3 id="h-標籤使用"><a href="#h-標籤使用" class="headerlink" title="h 標籤使用"></a>h 標籤使用</h3><p>大家應該都知道 <code>&lt;h1&gt;</code>、<code>&lt;h2&gt;</code> 這類的標籤，妥善運用這些標籤可以優化網站的 SEO。</p>
<h3 id="圖片取代文字"><a href="#圖片取代文字" class="headerlink" title="圖片取代文字"></a>圖片取代文字</h3><p>我們都知道 <code>&lt;h1&gt;</code> 是一個網站裡最重要的標題，但如果今天我想把它替換成網頁 logo 讓它變成 <code>&lt;h1&gt;</code> 呢？我們可以利用圖片取代文字的方法來實行。<br>概念是利用背景圖片來取代我們的 <code>&lt;h1&gt;</code> 文字，範例程式碼如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span>&#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(背景圖片路徑);</span><br><span class="line">    <span class="attribute">width</span>: 自訂;</span><br><span class="line">    <span class="attribute">height</span>: 自訂;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">    <span class="attribute">text-indent</span>: <span class="number">101%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這邊概念是我們將文字縮排到原區域外，並讓它不會斷行，最後利用 <code>overflow: hidden</code> 把文字隱藏起來，這樣就完成效果囉!</p>
<h3 id="將網頁標籤結構化"><a href="#將網頁標籤結構化" class="headerlink" title="將網頁標籤結構化"></a>將網頁標籤結構化</h3><p>我們可以利用 HTML 5 的結構化標籤讓網頁結構化，使搜尋引擎能更快速了解網頁資訊。</p>
<h3 id="充分利用標題與敘述"><a href="#充分利用標題與敘述" class="headerlink" title="充分利用標題與敘述"></a>充分利用標題與敘述</h3><p>我們都知道 header 裡的 <code>&lt;title&gt;</code> 可以用來決定網頁標題，創造一個與內容有關聯的標題(但不要太過冗長)對 SEO 有很大的幫助。<br><code>&lt;meta name=&quot;description&quot; content=&quot;網站敘述&quot;&gt;</code> 利用網站敘述也可以有效的幫助 SEO，最好是能為網站中的每一個網頁作與內容相關的敘述。</p>
<h3 id="簡單易懂的網址"><a href="#簡單易懂的網址" class="headerlink" title="簡單易懂的網址"></a>簡單易懂的網址</h3><p>可以嘗試讓網頁網址中含有文字，且該文字與網頁內容有關。</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://www.newscan.com.tw/all-seo/seo-guide.htm">SEO的初學者教學</a><br><a href="https://transbiz.com.tw/seo-guide/">網頁SEO優化入門</a><br><a href="https://www.youtube.com/watch?v=H8aEWX-llSc">SEO 初學者教學，3分鐘搞懂搜尋引擎優化</a><br><a href="https://www.astralweb.com.tw/the-best-seo-practices-for-front-end-coding/">從前端設計的角度來實踐SEO！</a></p>
]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>others</tag>
      </tags>
  </entry>
  <entry>
    <title>如何將 Vue Cli 2 專案轉移成 Vue Cli 3</title>
    <url>/2019/09/07/VueCli2toVueCli3/</url>
    <content><![CDATA[<p><img src="https://images.unsplash.com/photo-1500479694472-551d1fb6258d?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80"></p>
<h2 id="文章目的"><a href="#文章目的" class="headerlink" title="文章目的"></a>文章目的</h2><p>有時候可能會需要將 Vue Cli 2 的專案轉移成 Vue Cli 3，畢竟現在 Vue Cli 已經進化到 3 了，會讓我們管理專案時更加方便，因此利用此文章做紀錄。</p>
<a id="more"></a>

<h2 id="建立新專案"><a href="#建立新專案" class="headerlink" title="建立新專案"></a>建立新專案</h2><p>要轉移專案的話，得先建立好一個新專案，並在新專案中套用 Vue Cli 3。<br>我們可以利用 Vue GUI 快速建立好我們需要的專案。</p>
<h2 id="安裝舊專案的相關套件"><a href="#安裝舊專案的相關套件" class="headerlink" title="安裝舊專案的相關套件"></a>安裝舊專案的相關套件</h2><ul>
<li>我們有了新專案後，需要先為它安裝舊專案所擁有的套件。<br>我們可以打開舊專案的 package.json，裡頭 dependencies 會寫出有安裝的套件，根據這個我們為新專案重新安裝套件。<br>安裝方式有兩種，一種是利用 Vue GUI 的插件去做安裝，另一種則是在專案下利用指令碼的方式做安裝。<br>利用指令碼的好處是我們只需要輸入 <code>npm install --save</code> 後面加上需要安裝的套件(可以有多個)，這樣子我們就可以一口氣安裝所需套件。</li>
<li>接著我們參考舊專案的 main.js(進入點)，將相關套件 import 進來，這邊有一點要注意的是 <strong>Vue Cli 3 裡的 vue 檔，在 import 時一定要加上 .vue 的副檔名</strong>。</li>
</ul>
<h2 id="將專案檔案複製-vue-檔"><a href="#將專案檔案複製-vue-檔" class="headerlink" title="將專案檔案複製( vue 檔)"></a>將專案檔案複製( vue 檔)</h2><p>接著我們將相關的元件 vue 檔複製過來新專案，這邊說明下 Vue Cli 3 除了 components 這個資料夾外，多了一個 views 的資料夾，<strong>views 資料夾是專門給我們放分頁用，假如說是不同 router 的檔案可以放在這</strong>。<br>在轉移檔案時，要注意環境變數問題，因為 3 和 2 的環境變數設定不太一樣，來到 3 我們需要重新設定，有關環境變數設定可以參考這篇 — <a href="/2019/09/04/VueCli3EnvVar/">Vue Cli 3 環境變數設定</a><br>這樣子我們就可以將我們的舊專案轉變成新的 Vue Cli 3 專案囉!!</p>
<h2 id="補充–-Vue-Cli-3-Router-小技巧"><a href="#補充–-Vue-Cli-3-Router-小技巧" class="headerlink" title="補充– Vue Cli 3 Router 小技巧"></a>補充– Vue Cli 3 Router 小技巧</h2><p>在以前我們使用 router 時需先將元件 import 進來再去做使用，但現在有新的方法不需要麼麻煩，只需要在路徑的 component 利用箭頭函式的方式將元件載入即可。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;about&#x27;</span>,</span><br><span class="line">    component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./views/About.vue&#x27;</span>) <span class="comment">//直接載入路徑即可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://www.hexschool.com/vue/">六角學院課程–Vue 出一個電商網站</a></p>
]]></content>
      <categories>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
        <tag>Vue Cli 3</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue Cli 3 環境變數設定</title>
    <url>/2019/09/04/VueCli3EnvVar/</url>
    <content><![CDATA[<p><img src="https://images.unsplash.com/photo-1472313420546-a46e561861d8?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=667&q=80"></p>
<h2 id="文章目的"><a href="#文章目的" class="headerlink" title="文章目的"></a>文章目的</h2><p>之前是用 VueCli 2 做開發，那 VueCli 3 一樣有環境變數的設定，但設定方式會與 2 不太一樣，因此透過此文章來做紀錄。</p>
<a id="more"></a>

<h2 id="環境變數使用時機"><a href="#環境變數使用時機" class="headerlink" title="環境變數使用時機"></a>環境變數使用時機</h2><p>基本上，在開發時，測試環境下的 API 路徑會與正式環境的路徑不太一樣，因此我們可以利用環境變數來定義這些路徑，以方便我們使用。</p>
<h2 id="VueCli-2-和-VueCli-3-環境變數差異"><a href="#VueCli-2-和-VueCli-3-環境變數差異" class="headerlink" title="VueCli 2 和 VueCli 3 環境變數差異"></a>VueCli 2 和 VueCli 3 環境變數差異</h2><p>在 2 中我們會透過 config 資料夾底下的 <strong>dev.env.js</strong> 和 <strong>prod.env.js</strong> 兩隻檔案來定義不同環境下的環境變數。<br>但 3 很不一樣，沒有 config 資料夾了，我們只需要自己命名環境檔，並做一些簡單設定，就可以讓系統自己去判斷該使用哪個檔案中的環境變數，以下我將要做一一介紹。</p>
<h2 id="環境檔命名差別"><a href="#環境檔命名差別" class="headerlink" title="環境檔命名差別"></a>環境檔命名差別</h2><p>剛剛有提到，系統會根據我們的環境檔名稱來判斷使用時機，因此我們先來看看有甚麼命名吧。</p>
<ul>
<li>.env – 這個檔名的環境檔會在所有環境中被載入。</li>
<li>.env.local – 這個檔名的環境檔會在所有環境中被載入，但在 git 時會被忽略。</li>
<li>.env.[mode] – 只會在指定的環境中被載入，mode 的部分就是填入指定環境 Ex：production。</li>
<li>.env.[mode].local – 同上，但在 git 時會被忽略。<br>檔案部分只需要新增在專案資料夾底下即可，不用新增在 src 底下。</li>
</ul>
<h2 id="變數命名"><a href="#變數命名" class="headerlink" title="變數命名"></a>變數命名</h2><p>接下來是環境檔中的環境變數命名，這邊跟 2 差別在於命名變數時，需要在自定義名稱前面加上 <strong>VUE_APP_</strong> ，後面再加上自定義名稱。<br><strong>要記得新增一個新的環境變數時，環境要重啟，變數才能做使用。</strong></p>
<h2 id="切換環境檔"><a href="#切換環境檔" class="headerlink" title="切換環境檔"></a>切換環境檔</h2><p>前面有提到環境檔也可以在特定環境下才被啟用，這邊要說明如何啟用我們命名的環境檔。<br>假設我們今天新增一個環境檔，檔名叫做 <code>.env.testing</code>，並且我們希望它只在測試環境下運行。<br>這時我們需要來到 <code>package.json</code> 資料夾中，裏頭的 <code>scripts</code> 部分，有分為三個類型：</p>
<ul>
<li><code>&#39;serve&#39;: &#39;vue-cli-service serve&#39;</code></li>
<li><code>&#39;build&#39;: &#39;vue-cli-service build&#39;</code></li>
<li><code>&#39;lint&#39;: &#39;vue-cli-service lint&#39;</code><br>我們只需要這樣改寫即可，<br><code>&#39;vue-cli-service serve --mode testing&#39;</code><br>至於官方，有提供正式的命名方式，只需要照著命名就可以不用再去變更 <code>package.json</code>。<br>開發環境下的環境檔命名為：<code>.env.development</code><br>正式環環下的環境檔命名為：<code>.env.production</code></li>
</ul>
<p><strong>最後一點提醒，當我們的指定環境檔中(<code>.env.\[mode\]</code>)存在與全域環境檔(<code>.env</code>)相同的環境變數時，指定環境檔的權重會比較高。</strong></p>
<hr>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://cli.vuejs.org/zh/guide/mode-and-env.html#%E6%A8%A1%E5%BC%8F">Vue官方文件–環境變量和模式</a></p>
]]></content>
      <categories>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
        <tag>Vue Cli 3</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue Cli 3 安裝與創建專案</title>
    <url>/2019/09/07/VueCli3Insatll/</url>
    <content><![CDATA[<p><img src="https://images.unsplash.com/photo-1475809913362-28a064062ccd?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80"></p>
<h2 id="文章目的"><a href="#文章目的" class="headerlink" title="文章目的"></a>文章目的</h2><p>因為之前是使用 Vue Cli 2 做開發，現在在學習 Vue Cli 3 因此用此文章做個紀錄，此文章將介紹如何安裝 Vue Cli 3 及快速創建一個專案。<br>本文操作皆在 command line 中執行。</p>
<a id="more"></a>

<h2 id="Vue-Cli-2-卸載與-Vue-Cli-3-安裝"><a href="#Vue-Cli-2-卸載與-Vue-Cli-3-安裝" class="headerlink" title="Vue Cli 2 卸載與 Vue Cli 3 安裝"></a>Vue Cli 2 卸載與 Vue Cli 3 安裝</h2><h3 id="Vue-Cli-2-卸載"><a href="#Vue-Cli-2-卸載" class="headerlink" title="Vue Cli 2 卸載"></a>Vue Cli 2 卸載</h3><p>在安裝之前，可以先確認 Node.js 是否有安裝，且版本是否為 8.9 以上的版本。<br>確認完畢後，若電腦目前是有 Vue Cli 2 的話，在安裝 3 之前需要先卸載，卸載指令碼為 <code>npm uninstall vue-cli -g</code>，成功卸載後我們就能安裝 3 囉!!</p>
<h3 id="Vue-Cli-3-安裝"><a href="#Vue-Cli-3-安裝" class="headerlink" title="Vue Cli 3 安裝"></a>Vue Cli 3 安裝</h3><p>我們在 command line 中輸入 <code>npm install -g @vue/cli</code> 即可安裝 3，安裝完成輸入 <code>vue --version</code> 檢查版本，若為 3 以上代表安裝成功。</p>
<h2 id="創建專案"><a href="#創建專案" class="headerlink" title="創建專案"></a>創建專案</h2><p>輸入 <code>vue create 你的專案名</code> 即可建立專案，在建立過程中，會有一些設定檔的安裝問題，以下做一一解釋。</p>
<h3 id="自訂你要安裝的設定檔"><a href="#自訂你要安裝的設定檔" class="headerlink" title="自訂你要安裝的設定檔"></a>自訂你要安裝的設定檔</h3><p>基本上系統一開始會提供你一個預設的安裝，裡面有部分的設定檔，那如果你想在專案上安裝自己想要的設定檔，可以選擇 <code>Manually select features</code> 來自訂。<br>選完要安裝的設定檔後，系統會詢問你一些關於你的設定檔的細節，只要選擇符合你的需求即可。<br>再來會詢問你是否把這次的設定儲存，方便以後創立專案時直接套用，這邊就看個人需求。<br>最後系統會詢問你這些設定檔要獨立出來管理，或是全部寫在 package.json 中。</p>
<h3 id="執行專案"><a href="#執行專案" class="headerlink" title="執行專案"></a>執行專案</h3><p>建立完畢專案後，command line 會提供兩個指令來開啟專案，照著指令輸入，會出現網址，在瀏覽器上輸入網址就可以確認專案是否正確運行囉!!</p>
<h2 id="簡單的資料夾介紹"><a href="#簡單的資料夾介紹" class="headerlink" title="簡單的資料夾介紹"></a>簡單的資料夾介紹</h2><p>這邊我要介紹兩個 Vue Cli 3 專案裡的資料夾，分別是<strong>src</strong> 和 <strong>public</strong>。<br>這兩者的差別簡單來講，放在 src 中的檔案都會被編譯，public 資料夾底下的檔案不會被編譯。<br>public 資料夾底下，僅有 index.html 這隻檔案會被編譯。</p>
<hr>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://www.hexschool.com/vue/">六角學院課程–Vue 出一個電商網站</a><br><a href="https://cli.vuejs.org/zh/guide/installation.html">官方文件</a></p>
]]></content>
      <categories>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
        <tag>Vue Cli 3</tag>
      </tags>
  </entry>
  <entry>
    <title>如何快速開發建立原型</title>
    <url>/2019/09/08/VueInstantPrototyping/</url>
    <content><![CDATA[<p><img src="https://images.unsplash.com/photo-1425082661705-1834bfd09dca?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1055&q=80"></p>
<h2 id="文章目的"><a href="#文章目的" class="headerlink" title="文章目的"></a>文章目的</h2><p>有時候我們在開發小型專案時，檔案量不多僅僅只是想要使用 vue serve 和 vue build 的功能，不需要特地使用 Vue Cli 的情況下，就可以利用快速開發原型達到目的，此文章將紀錄如何快速建立原型。</p>
<a id="more"></a>

<h2 id="建立全域相關安裝"><a href="#建立全域相關安裝" class="headerlink" title="建立全域相關安裝"></a>建立全域相關安裝</h2><p>想要建立原型開發，需要先在 command line 中輸入 <code>npm install -g @vue/cli-service-global</code>，做全域安裝。<br><strong>記得此方法僅適用於快速原型開發</strong>。</p>
<h2 id="利用-vue-檔開發專案"><a href="#利用-vue-檔開發專案" class="headerlink" title="利用 vue 檔開發專案"></a>利用 vue 檔開發專案</h2><p>我們將開發程式碼寫寫在我們的 vue 檔內，例如創造一個 <code>index.vue</code> 並將程式碼寫入，記得 js 部分要用 <code>export default</code> 載入。<br>接著我們就可以在 command line 輸入 <code>vue serve index.vue</code> 來觀看我們的專案網頁(開發中)。<br>輸入 <code>vue build index.vue</code> 就可以將其打包成 dist 檔。</p>
<hr>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://www.hexschool.com/vue/">六角學院課程–Vue 出一個電商網站</a><br><a href="https://cli.vuejs.org/zh/guide/prototyping.html">官方文件</a></p>
]]></content>
      <categories>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 小技術小工具園地</title>
    <url>/2019/08/13/VueTips/</url>
    <content><![CDATA[<p><img src="https://images.unsplash.com/photo-1534398079543-7ae6d016b86a?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=750&q=80"></p>
<h2 id="文章目的"><a href="#文章目的" class="headerlink" title="文章目的"></a>文章目的</h2><p>有鑑於現在在練習利用 Vue 開發電商網站，中間會發現一些前端前輩提供的好用程式碼，或是一些好用的套件、工具，想透過此文章記錄下來，方便以後回憶查找。<br>若陸續發現好用的工具與程式碼會持續更新，或許會出好幾回XD</p>
<a id="more"></a>
<h2 id="Vue-Awesome-Swiper-讓-Vue-輕鬆使用輪播功能"><a href="#Vue-Awesome-Swiper-讓-Vue-輕鬆使用輪播功能" class="headerlink" title="Vue Awesome Swiper 讓 Vue 輕鬆使用輪播功能"></a>Vue Awesome Swiper 讓 Vue 輕鬆使用輪播功能</h2><p>Vue Awesome Swiper 是一個提供 Vue 能使用輪播功能的套件，我們只需做簡單的安裝與引用就可以達到效果。</p>
<h3 id="安裝與引用套件"><a href="#安裝與引用套件" class="headerlink" title="安裝與引用套件"></a>安裝與引用套件</h3><ol>
<li>在終端機輸入 <code>npm install vue-awesome-swiper --save</code> 進行安裝。</li>
<li>此套件可以做全域與區域的引用，這邊我們要介紹如何全域引用它，來到進入點(main.js)，在裡面輸入以下程式碼：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> VueAwesomeSwiper <span class="keyword">from</span> <span class="string">&#x27;vue-awesome-swiper&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;swiper/dist/css/swiper.css&#x27;</span></span><br><span class="line">Vue.use(VueAwesomeSwiper)</span><br></pre></td></tr></table></figure>
進行到這邊我們已完成安裝與引用的動作，接下來就是使用它。<h3 id="Vue-Awesome-Swiper-使用方法"><a href="#Vue-Awesome-Swiper-使用方法" class="headerlink" title="Vue Awesome Swiper 使用方法"></a>Vue Awesome Swiper 使用方法</h3></li>
<li>在需要使用的 Vue 元件 html 部分載入以下程式碼：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">swiper</span> <span class="attr">:options</span>=<span class="string">&quot;swiperOption&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">swiper-slide</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;...&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">swiper-slide</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">swiper-slide</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;...&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">swiper-slide</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">swiper-slide</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;...&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">swiper-slide</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">swiper</span>&gt;</span></span><br></pre></td></tr></table></figure>
每一個 <code>swiper-slide</code> 就是一張輪播圖片，裡面不一定要使用 <code>img</code> 也可以使用 <code>background-image</code> 方式去設定圖片。<br><code>swiper</code> 綁定的 <code>options</code> 提供我們對輪播的參數設定。</li>
<li>來到 js 部分對輪播做一些簡單設定與介紹，程式碼如下：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">name: <span class="string">&#x27;carousel&#x27;</span>,</span><br><span class="line">data () &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    swiperOption: &#123;</span><br><span class="line">      autoplay: &#123;</span><br><span class="line">        delay: <span class="number">2500</span>, <span class="comment">/*自動輪播間格時間*/</span></span><br><span class="line">        disableOnInteraction: <span class="literal">false</span> <span class="comment">/*使用者拖曳輪播時是否取消自動輪播*/</span></span><br><span class="line">      &#125;,</span><br><span class="line">      loop: <span class="literal">true</span>, <span class="comment">/*是否重複輪播*/</span></span><br><span class="line">      effect: <span class="string">&#x27;fade&#x27;</span> <span class="comment">/*輪播顯示效果(預設為slide)*/</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
這邊只做一些簡單的介紹，若需要其他額外效果或了解其他參數，這邊附上我找到的相關文章，另外基本上<strong>參數部分都與 swiper 這個套件相同</strong>。<br><a href="https://segmentfault.com/a/1190000014609379#autoplay">參數與效果示範</a><br><a href="https://3.swiper.com.cn/">swiper官方文件</a><br><a href="https://github.com/surmon-china/vue-awesome-swiper">Vue Awesome Swiper官方文件</a></li>
</ol>
<h2 id="Vue-Filter-金錢格式程式碼-currency"><a href="#Vue-Filter-金錢格式程式碼-currency" class="headerlink" title="Vue Filter 金錢格式程式碼(currency)"></a>Vue Filter 金錢格式程式碼(currency)</h2><p>有時候我們會需要將數字轉換成金錢的格式，像是加入千分號及錢字號，這邊提供一個 js 程式碼，方便套用至 Vue filter 就可以輕鬆轉換格式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> n = <span class="built_in">Number</span>(num)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`$<span class="subst">$&#123;n.toFixed(<span class="number">0</span>).replace(<span class="regexp">/./g</span>, (c, i, a) =&gt; &#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">    <span class="keyword">const</span> currency = (i &amp;&amp; c !== <span class="string">&#x27;.&#x27;</span> &amp;&amp; ((a.length - i) % <span class="number">3</span> === <span class="number">0</span>) ? <span class="string">`, <span class="subst">$&#123;c&#125;</span>`</span>.replace(<span class="regexp">/\s/g</span>, <span class="string">&#x27;&#x27;</span>) : c)</span></span></span><br><span class="line"><span class="string"><span class="subst">    <span class="keyword">return</span> currency</span></span></span><br><span class="line"><span class="string"><span class="subst">  &#125;)&#125;</span>`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Vue-filter-日期格式程式碼-date"><a href="#Vue-filter-日期格式程式碼-date" class="headerlink" title="Vue filter 日期格式程式碼(date)"></a>Vue filter 日期格式程式碼(date)</h2><p>在我們抓取日期時，基本上後端抓來的日期都會是 Timestamp 格式，這邊提供將 Timestamp 轉換成一般時間格式的程式碼，方便使用在 Vue filter 裡。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(time * <span class="number">1000</span>)</span><br><span class="line">  <span class="keyword">return</span> date.toLocaleDateString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Vue-簡單搭配-localStorage-寫法"><a href="#Vue-簡單搭配-localStorage-寫法" class="headerlink" title="Vue 簡單搭配 localStorage 寫法"></a>Vue 簡單搭配 localStorage 寫法</h2><p>有時候我們在寫網頁的時候，會需要用到 localStorage 來幫助我們儲存一些資料，這邊將介紹簡單的 Vue localStorage 寫法。</p>
<ul>
<li>一樣的我們先為需要儲存的資料變數下以下語法，來抓取 localStorage 的資料：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data () &#123;</span><br><span class="line">   <span class="keyword">return</span> &#123;</span><br><span class="line">     變數名稱: <span class="built_in">JSON</span>.parse(<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;localStorage名稱&#x27;</span>)) || [],</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li>*這邊有很重要的一點是 <code>JSON.parse</code> 與空陣列的順序不能對調，不然抓取資料時會有錯誤!!!**</li>
<li>接著我們可以下 <code>watch</code> 語法來監聽這個變數的資料變化，當資料一產生變化就儲存到 localStorage 裡，程式碼如下：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">   上一步驟的變數名: &#123;</span><br><span class="line">     handler () &#123;</span><br><span class="line">       <span class="keyword">let</span> storageName = <span class="string">&#x27;localStorage名稱&#x27;</span></span><br><span class="line">       <span class="built_in">localStorage</span>.setItem(storageName, <span class="built_in">JSON</span>.stringify(<span class="built_in">this</span>.上一步驟的變數名))</span><br><span class="line">     &#125;,</span><br><span class="line">     deep: <span class="literal">true</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
進行到這裡，我們就可以順利的儲存我們監聽的資料到 localStorage 中囉。</li>
</ul>
<h2 id="當動態路由改變時該如何讓畫面重新渲染？"><a href="#當動態路由改變時該如何讓畫面重新渲染？" class="headerlink" title="當動態路由改變時該如何讓畫面重新渲染？"></a>當動態路由改變時該如何讓畫面重新渲染？</h2><p>什麼時候會發生這情況呢？目前筆者遇到這情況是已經在某一個動態路徑底下，在這路徑下我想切換到另一個動態路徑，但因為元件模組是相同的，因此我們沒做監視的話，畫面是不會重新渲染的。<br>這時候需要用到我們 Vue 的 watch 功能，用 watch 來監視我們動態路由，當路由改變就執行一些指令讓畫面重新渲染。<br>程式碼如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  $route: &#123;</span><br><span class="line">    handler () &#123;</span><br><span class="line">      <span class="built_in">this</span>.productId = <span class="built_in">this</span>.$route.params.Id</span><br><span class="line">      <span class="built_in">this</span>.getDetail()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此段程式碼中我們監視 <code>$route</code> ，當它發生變化時我們就重新抓取它改變後的路徑名，並儲存起來，方便後面的函數執行重新抓取資料，進而重新渲染畫面。</p>
<p><a href="https://github.com/stuxt/stuxt.github.io/issues/29"><strong>參考資料</strong></a></p>
<h2 id="切換-router-時讓新畫面可以回到畫面最上層"><a href="#切換-router-時讓新畫面可以回到畫面最上層" class="headerlink" title="切換 router 時讓新畫面可以回到畫面最上層"></a>切換 router 時讓新畫面可以回到畫面最上層</h2><p>我們知道 vue 在切換 router 時會因為 SPA 的特性讓新渲染的畫面位置停留在使用者之前的滾動位置，那如果我們想要將新畫面渲染後位置回到頂層該怎麼做呢？<br>我們來到 router 資料夾裡的 <code>index.js</code> 檔案，並在下列部分加入新程式碼：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes,</span><br><span class="line">  <span class="comment">/*新增這段程式碼讓畫面切換可以回到頂層*/</span></span><br><span class="line">  scrollBehavior (to, <span class="keyword">from</span>, savedPosition) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>這樣子我們切換畫面時，畫面就會自動回到頂層囉!!</p>
<p><a href="https://stackoverflow.com/questions/53687424/vue-router-go-to-top-on-new-page"><strong>參考資料</strong></a></p>
<h2 id="Vue-range-slider-輕鬆在-vue-中使用滑動工具"><a href="#Vue-range-slider-輕鬆在-vue-中使用滑動工具" class="headerlink" title="Vue-range-slider 輕鬆在 vue 中使用滑動工具"></a>Vue-range-slider 輕鬆在 vue 中使用滑動工具</h2><p>因為筆者最近開發的網頁需要用到 slider 的效果，但因為開發環境是 NUXT + Vue 很多套件在使用上都會遇到莫名的 bug，最後終於找到適合的套件，想在這邊做個紀錄。<br>如果我們在 google 關鍵字打上 <code>slider、vue slider 等</code>，跳出來的套件會有 <strong>jquery ui slider</strong> 與 <strong>vue-range-slider</strong>，兩者筆者都有嘗試但都踩到雷。</p>
<h3 id="雷點"><a href="#雷點" class="headerlink" title="雷點"></a>雷點</h3><p>jquery 部分在使用 <code>v-model</code> 的雙向綁定時會有些問題，會建議在開發 Vue 時能不用 jquery 就不使用，避免不必要的衝突。<br>vue-range-slider 則是會有兩個套件分別是 <code>vue-range-component</code> 和 <code>vue-range-slider</code>，強烈建議安裝 <code>vue-range-slider</code>，因為 <code>vue-range-component</code> 使用時會出現 bug，且在 NUXT 中引用會稍微麻煩。</p>
<h3 id="vue-range-slider-使用方法"><a href="#vue-range-slider-使用方法" class="headerlink" title="vue-range-slider 使用方法"></a>vue-range-slider 使用方法</h3><p>這邊我們就來介紹一下此套件的使用方法，這邊附上連結—<a href="https://www.npmjs.com/package/vue-range-slider"><strong>vue-range-slider</strong></a>。<br>基本上就按照連結裡的步驟去做應該就能正確使用，筆者這邊要說的是自定義style部分，若我們需要自定義 style，打開 <strong>node_modules 裡的 vue-range-slider/dist/vue-range-slider.css</strong> 這隻檔案並在裡面做 css 的修改。<br><strong>重點是它還支援 touch device 喔!!!!!!!!</strong><br>以上就是筆者在使用 sldier 的心得(若你沒有用框架開發的話 jquery ui slider 會是不錯的選擇)。<a href="https://jqueryui.com/"><strong>jquery-ui</strong></a></p>
]]></content>
      <categories>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Vuex 管理專案資料傳遞</title>
    <url>/2019/09/08/Vuex/</url>
    <content><![CDATA[<p><img src="https://images.unsplash.com/photo-1461360228754-6e81c478b882?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1053&q=80"></p>
<h2 id="文章目的"><a href="#文章目的" class="headerlink" title="文章目的"></a>文章目的</h2><p>之前在學習 vue 的資料傳遞時，是使用 Event Bus 的方式來做傳遞，但當專案較大時，Event Bus 會較難管理資料，這時我們就可以利用 Vuex 來達成資料管理與傳遞的目的，本文將介紹 Vuex 與說明使用方法。</p>
<a id="more"></a>

<h2 id="Vuex-介紹"><a href="#Vuex-介紹" class="headerlink" title="Vuex 介紹"></a>Vuex 介紹</h2><p>Vuex 和 Event Bus 不一樣的地方是它是一個儲存庫的概念，儲存庫中將會為每一個步驟做分類與分工並讓所有的元件做使用，簡單來講就是<strong>先將資料做個統整再做傳遞</strong>。</p>
<h3 id="Vuex-方法"><a href="#Vuex-方法" class="headerlink" title="Vuex 方法"></a>Vuex 方法</h3><ul>
<li>state：如同元件中的 data，負責管理資料。</li>
<li>actions：如同元件中的 methods，負責處裡非同步事件，或是取得遠端資料等。</li>
<li>getter：如同元件中的 computed，在資料呈現之前做過濾的動作。</li>
<li>mutations：這是 Vuex 新增的方法，改變資料內容的方法，在以前我們要改變資料狀態時都會直接在 methods 做變更，但在 Vuex 不同，actions 並不會做資料的變更，而是在 mutations 才會做資料狀態的變更。</li>
</ul>
<h3 id="Vuex-運作方法"><a href="#Vuex-運作方法" class="headerlink" title="Vuex 運作方法"></a>Vuex 運作方法</h3><p>在 Vue 的元件中，我們透過 dispatch 來觸發 actions，actions 就會去取得遠端資料，並透過 commit 的方式呼叫 mutations，最後透過 mutations 來改變 state 中的資料狀態並反映給元件。<br><strong>這邊有一點要注意，當要使用一些非同步的行為時(AJAX、Settimeout 等)，請在 actions 中就完成它。</strong></p>
<h2 id="Vuex-簡單範例，透過-Vuex-改變資料狀態"><a href="#Vuex-簡單範例，透過-Vuex-改變資料狀態" class="headerlink" title="Vuex 簡單範例，透過 Vuex 改變資料狀態"></a>Vuex 簡單範例，透過 Vuex 改變資料狀態</h2><p>現在我們就來看看 Vuex 各方法的寫法吧。</p>
<h3 id="範例狀況"><a href="#範例狀況" class="headerlink" title="範例狀況"></a>範例狀況</h3><p>現在我們的專案中有讀取的動畫功能，因為很多元件在取得資料時都會需要使用這功能，因此我們打算利用 Vuex 統一管理動畫功能。<br>我們利用 <code>isLoading = true or false</code> 來控制動畫的出現與消失。</p>
<h3 id="創造我們的-Vuex-儲存庫"><a href="#創造我們的-Vuex-儲存庫" class="headerlink" title="創造我們的 Vuex 儲存庫"></a>創造我們的 Vuex 儲存庫</h3><p>我們先在 <code>src</code> 資料夾中創造一個名為 <code>store</code> 的資料夾，並在此資料夾中創造一個名為 <code>index.js</code> 的檔案，這個檔案將為我們管理 Vuex。</p>
<ul>
<li><p>在檔案中我們先將 <code>vue</code> 和 <code>vuex</code> import 進來，程式碼如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br></pre></td></tr></table></figure>
<p>另外在 main.js(進入點) 也要做 import 的動作，並把 store 也 import 進來，程式碼如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store, <span class="comment">//記得這裡也要補上 store 喔</span></span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>接著我們在 <code>export default</code> 中輸入我們的方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    isLoading: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    updateLoading (context, status) &#123;</span><br><span class="line">      context.commit(<span class="string">&#x27;LOADING&#x27;</span>, status)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    LOADING (state, status) &#123;</span><br><span class="line">      state.isLoading = status</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>這邊將為 actions 和 mutations 做解釋</p>
</li>
</ul>
<p>actions：創建一個 function，function 中擁有兩個參數，分別是 <code>context</code> 和 <code>payload(載核)</code>， <code>context</code> 是必要的參數， <code>payload</code> 則是我們自定義的參數(名稱也可自訂，以此範例來說就是 <code>status</code>)，接著使用 <code>context.commit</code> 觸發 mutations 並把載核傳遞給它。</p>
<p>mutations：一樣創建一個 function，當此 function 被觸發時就會對 state 中的資料做變更。</p>
<p>統整：在元件中因為某個事件透過 <code>dispatch</code> 觸發了 <code>updateLoading</code> 這個 action，觸發的同時將 status 的資料傳遞進來，接著 <code>updateLoading</code> 透過 <code>context.commit</code> 觸發名為 <code>LOADING</code> 的 mutations 並將 status 資料傳遞給它，最後在名為 <code>LOADING</code> 的 mutations 中將 state 中的資料狀態變更，資料變更的同時會反應回元件上。</p>
<h3 id="元件-Vuex-設定"><a href="#元件-Vuex-設定" class="headerlink" title="元件 Vuex 設定"></a>元件 Vuex 設定</h3><p>因為是整個專案都會用到此動畫效果，因此我們將動畫程式碼放在我們的 App.vue 中就可以反映在每個元件上。<br>那因為資料的變更也是反應在 App.vue(根元件)，因此我們可以利用 <code>computed</code> 來監控 Vuex 中的這個資料，程式碼如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">   isLoading () &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">this</span>.$store.state.isLoading</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>接著我們需要改寫的就是 methods 中觸發效果的寫法，程式碼如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.$store.dispatch(<span class="string">&#x27;updateLoading&#x27;</span>, <span class="literal">true</span>)</span><br><span class="line">vm.$store.dispatch(<span class="string">&#x27;updateLoading&#x27;</span>, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<p>透過 <code>dispatch</code> 觸發 <code>updateLoading</code> 這個 actions，並將 payload(true or false) 傳入，接著系統就會執行我們剛剛說的 Vuex 內部流程。</p>
<h3 id="為-Vuex-加入嚴謹模式來檢視錯誤"><a href="#為-Vuex-加入嚴謹模式來檢視錯誤" class="headerlink" title="為 Vuex 加入嚴謹模式來檢視錯誤"></a>為 Vuex 加入嚴謹模式來檢視錯誤</h3><p>我們另外可以在 Vuex 中加入嚴謹模式，讓我們的程式碼撰寫都在規範中，加入方式只需在 state 之前寫入以下程式碼即可：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">strict: <span class="literal">true</span>,</span><br></pre></td></tr></table></figure>

<h2 id="使用-actions-取得遠端資料"><a href="#使用-actions-取得遠端資料" class="headerlink" title="使用 actions 取得遠端資料"></a>使用 actions 取得遠端資料</h2><p>剛剛有說過若要在 Vuex 中執行非同步行為我們就需要在 actions 中執行完這個動作。<br>現在將要介紹如何在 actions 中執行 AJAX 的行為。<br>在 Vuex 中執行 AJAX 的好處是我們可以統一管理這個行為，且較大型網站若有很多元件都需要用到此 AJAX，也可以隨時調用，不需要在元件內重複撰寫。</p>
<h3 id="範例狀況-1"><a href="#範例狀況-1" class="headerlink" title="範例狀況"></a>範例狀況</h3><p>現在我們要接取一支可以取得商品資料的 api， 抓取到的 api 資料皆儲存在 <code>products</code> 這個陣列裡，以下是程式碼：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  strict: <span class="literal">true</span>,</span><br><span class="line">  state: &#123;</span><br><span class="line">    isLoading: <span class="literal">false</span>,</span><br><span class="line">    products: []</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    updateLoading (context, status) &#123; <span class="comment">//前一步驟的 loading 效果</span></span><br><span class="line">      context.commit(<span class="string">&#x27;LOADING&#x27;</span>, status)</span><br><span class="line">    &#125;,</span><br><span class="line">    getProducts (context) &#123;</span><br><span class="line">      <span class="keyword">const</span> url = <span class="string">`api 路徑`</span></span><br><span class="line">      context.commit(<span class="string">&#x27;LOADING&#x27;</span>, <span class="literal">true</span>) <span class="comment">//觸發loading效果</span></span><br><span class="line">      axios.get(url).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">        context.commit(<span class="string">&#x27;PRODUCTS&#x27;</span>, response.data.products)</span><br><span class="line">        context.commit(<span class="string">&#x27;LOADING&#x27;</span>, <span class="literal">false</span>) <span class="comment">//取消loading效果</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    LOADING (state, status) &#123;</span><br><span class="line">      state.isLoading = status</span><br><span class="line">    &#125;,</span><br><span class="line">    PRODUCTS (state, payload) &#123;</span><br><span class="line">      state.products = payload</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>我們的目的是要把 AJAX 的資料儲存到 state 的 products 裡，因此我們先在 actions 利用 <code>getProducts</code> 這個 function 去接取 api 並把抓取到的資料透過 commit 傳遞給 <code>PRODUCTS</code>，<code>PRODUCTS</code> 收到資料後，再將資料儲存進 state 的 products 裡。</p>
<h3 id="axios-解釋"><a href="#axios-解釋" class="headerlink" title="axios 解釋"></a>axios 解釋</h3><p>這邊使用的接取 api 方法是 Vue axios，但你會發現我們上列的程式碼，接取 api 時不是這樣寫 <code>this.$http.get(url)</code>，原因是現在 AJAX 的行為是在 Vuex 中進行，this 是代表元件，但現在並非在元件內，因此才會改寫，那改寫步驟如以下：</p>
<ul>
<li>將 <code>axios import from &#39;axios&#39;</code> 寫入 Vuex 裡。</li>
<li>把 <code>this.$http</code> 改寫成 <code>axios</code>。</li>
</ul>
<p>我們是直接透過掛載 axios 的方法並呼叫它，而非像一開始用 Vue 呼叫。</p>
<h3 id="元件改寫"><a href="#元件改寫" class="headerlink" title="元件改寫"></a>元件改寫</h3><p>我們元件中一樣要有事件觸發 AJAX 的行為，一樣是使用 <code>dispatch</code> 做觸發，寫法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getProducts () &#123;</span><br><span class="line">  <span class="keyword">const</span> vm = <span class="built_in">this</span>;</span><br><span class="line">  vm.$store.dispatch(<span class="string">&#x27;getProducts&#x27;</span>)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>一樣的我們要將 products 這個陣列內容反應在元件中，我們透過 computed 來調用，寫法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">products () &#123; <span class="comment">//寫在 computed 中</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.$store.state.products</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="利用-actions-傳遞參數"><a href="#利用-actions-傳遞參數" class="headerlink" title="利用 actions 傳遞參數"></a>利用 actions 傳遞參數</h2><p>這邊要說明的是，actions 方法中只能傳遞一個參數，當我們今天要傳遞複數個參數時，就得利用物件的方法做傳遞，程式碼如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$store.dispatch(<span class="string">&#x27;actions 方法&#x27;</span>, &#123; 參數<span class="number">1</span>, 參數<span class="number">2</span> &#125;)</span><br></pre></td></tr></table></figure>
<p>另外若我們在執行某個 actions 方法時，需要執行另外一個 actions 方法可以利用 <code>commit.dispatch(&#39;actions 方法名&#39;, 參數)</code>，利用這種方法調用其他 actions。</p>
<h2 id="getters-寫法"><a href="#getters-寫法" class="headerlink" title="getters 寫法"></a>getters 寫法</h2><p>前面有提到 getters 相當於 computed 我們也可以將部分寫法改成用 getters 替代，這邊示範將前幾個範例改寫。<br>我們在 Vuex 中新增一個名為 <code>getters</code> 的物件，並將要 computed 回傳的資料寫入，程式碼如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">  categories (state) &#123;</span><br><span class="line">    <span class="keyword">return</span> state.categories</span><br><span class="line">  &#125;,</span><br><span class="line">  products (state) &#123;</span><br><span class="line">    <span class="keyword">return</span> state.products</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這邊回傳前面範例的 products 和 categories。<br>接著我們回到元件中改寫程式碼，我們先將 getters import 進元件內 <code>import &#123; mapGetters &#125; from &#39;vuex&#39;</code>，接著在 computed 做改寫，改寫成 <code>...mapGetters ([&#39;products&#39;, &#39;categories&#39;])</code>，陣列中是我們 Vuex 中 getters 的方法。<br>另外，我們也可以將 actions 做改寫，只要在 import 中把 actions import 進來 <code>import &#123; mapGetters, mapActions &#125; from &#39;vuex&#39;</code>，並在 methods 將方法改寫成 <code>...mapActions ([&#39;getProducts&#39;])</code>，一樣的陣列中是我們的 actions 方法名。<br><strong>這邊有一點要注意的是用這方法取用 actions 時不適用在需要傳遞參數的 actions。</strong></p>
<h2 id="Vuex-模組化"><a href="#Vuex-模組化" class="headerlink" title="Vuex 模組化"></a>Vuex 模組化</h2><p>你可以發現到在前面的範例中我們已經在 Vuex 中寫入了很多程式碼，但這只是一個小小的範例而已，若遇到更大型專案時，模組化的概念就會顯得相當重要。<br>我們可以把 Vuex 中管理的行為再做進一步的拆分，使我們更加方便管理。<br>這邊將示範將範例中取得商品的方法做拆分。</p>
<ul>
<li>我們先在 store 資料夾中再新增一個叫做 <code>products.js</code> 的檔案，並把 getProducts 的 actions 和相關參數從 <code>index.js</code> 中拆出來並寫進 <code>products.js</code> 中。</li>
<li>接著我們利用 import 將 <code>products.js</code> 的內容載入至 <code>index.js</code>： <code>import productsModule from &#39;./products&#39;</code>，然後在 index 中新增一個名為 <code>modules</code> 的物件，並把 <code>productsModule</code> 加入。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">modules: &#123;</span><br><span class="line">  productsModule</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="加強觀念"><a href="#加強觀念" class="headerlink" title="加強觀念"></a>加強觀念</h3>在 Vuex 中 <strong>state 是屬於模組區域變數</strong>，裡頭的資料只會在該模組中才能做使用，但是 <strong>actions, mutations 和 getters 屬於全域變數</strong>。<br>全域變數好處是在小型專案時可以節省開發時間，但在大型專案中就會建議使用區域變數，避免衝突(當有相同方法名的時候就會產生衝突)。</li>
</ul>
<h3 id="如何取得拆分模組中的-state-區域變數-元件中"><a href="#如何取得拆分模組中的-state-區域變數-元件中" class="headerlink" title="如何取得拆分模組中的 state 區域變數(元件中)"></a>如何取得拆分模組中的 state 區域變數(元件中)</h3><p>這方法很簡單，只需要將程式碼這樣改寫即可：<br><code>this.$store.state.productModule.products</code></p>
<h3 id="將模組內全域變數改成區域變數"><a href="#將模組內全域變數改成區域變數" class="headerlink" title="將模組內全域變數改成區域變數"></a>將模組內全域變數改成區域變數</h3><p>若我們要避免衝突，將全域變數變成區域變數，可以在該模組的 export default 底下寫入這行程式碼：<code>namespaced: true</code>。<br>變成區域變數之後我們要如何調用它呢？延續前面的調用方法我們可以這樣寫：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...mapActions(<span class="string">&#x27;productModule&#x27;</span>, [<span class="string">&#x27;getProducts&#x27;</span>]) <span class="comment">// 第一種方法，在第一個參數中寫入要調用的模組名</span></span><br><span class="line"><span class="comment">/*****/</span></span><br><span class="line">getProducts () &#123;</span><br><span class="line">  <span class="built_in">this</span>.$store.dispatch(<span class="string">&#x27;productsModule/getProducts&#x27;</span>) <span class="comment">// 第二種方法，利用 dispatch 做調用 模組名/actions名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="讓特定行為變為全域調用"><a href="#讓特定行為變為全域調用" class="headerlink" title="讓特定行為變為全域調用"></a>讓特定行為變為全域調用</h3><p>若我們要某方法可以全域調用，像是範例的讀取動畫效果，因為變數是存在 index 裡，若我們要在 products 中調用可以這樣寫：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">context.commit(<span class="string">&#x27;LOADING&#x27;</span>, <span class="literal">true</span>, &#123; <span class="attr">root</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">context.commit(<span class="string">&#x27;LOADING&#x27;</span>, <span class="literal">false</span>, &#123; <span class="attr">root</span>: <span class="literal">true</span> &#125;)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://www.hexschool.com/vue/">六角學院課程–Vue 出一個電商網站</a><br><a href="https://vuex.vuejs.org/zh/">官方文件</a></p>
]]></content>
      <categories>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack 學習紀錄</title>
    <url>/2020/07/22/webpackNote/</url>
    <content><![CDATA[<p><img src="https://images.unsplash.com/photo-1541544181051-e46607bc22a4?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1350&q=80"></p>
<h2 id="文章目的"><a href="#文章目的" class="headerlink" title="文章目的"></a>文章目的</h2><p>接觸前端到現在幾乎碰到的專案都會使用到前端的三大框架，框架中都會用到 webpack 的技術，但實際上 webpack 是什麼呢？<br>如果我今天不用框架開發，一樣能用 webpack 幫助我開發專案嗎？<br>這一直是我想了解的地方，利用此筆記記錄我學到的東西以方便日後複習。</p>
<a id="more"></a>

<h2 id="webpack-目的"><a href="#webpack-目的" class="headerlink" title="webpack 目的"></a>webpack 目的</h2><p>為什麼要使用 webpack？前端發展至今，開發上已經不是單純的寫 html、css、js 了，我們會在開發上利用許多衍生的語法來幫助我們開發，像是 es6、sass、pug 等等。<br>但瀏覽器根本壓根看不懂這些東西，那我們要怎麼把這些東西變成瀏覽器看得懂的語言呢？<br>這就是使用 webpack 的原因之一，webpack 可以幫助我們將這些衍生語法編譯成瀏覽器看得懂的語法，打包成一包並壓縮檔案大小，這麼方便還不用嗎？</p>
<h2 id="建立-webpack-環境"><a href="#建立-webpack-環境" class="headerlink" title="建立 webpack 環境"></a>建立 webpack 環境</h2><p>在使用 webpack 前我們要先建立基本的環境，並做一些基本設定，讓我們後續使用更加方便。</p>
<h3 id="創建-package-json"><a href="#創建-package-json" class="headerlink" title="創建 package.json"></a>創建 package.json</h3><p>在我們的新專案中輸入 <code>npm init</code> 來安裝並填入一些訊息設定，若不想那麼麻煩也可以直接輸入 <code>npm init -y</code>。</p>
<h3 id="安裝-webpack"><a href="#安裝-webpack" class="headerlink" title="安裝 webpack"></a>安裝 webpack</h3><p>接下來安裝 webpack，輸入 <code>npm install webpack webpack-cli --save-dev</code>，安裝完後我們的專案會出現 node_modules 和 package-lock.json。</p>
<h3 id="撰寫-webpack-設定檔"><a href="#撰寫-webpack-設定檔" class="headerlink" title="撰寫 webpack 設定檔"></a>撰寫 webpack 設定檔</h3><p>先創建兩個檔案，分別是 <code>index.js</code> 跟 <code>webpack.config.js</code>，<code>webpack.config.js</code> 是 webpack 的設定檔，我們先來幫他做點設定：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">  <span class="comment">// 進入點，所以檔案必須與此檔案有關聯才會被編譯</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">&#x27;index.bundle.js&#x27;</span>,</span><br><span class="line">    <span class="comment">// 編譯檔案名稱</span></span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>)</span><br><span class="line">    <span class="comment">// 編譯檔案的位置</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我們可以看到在 entry 部分關連的檔案是 index.js，也就是我們剛剛建立的檔案，webpack 會以此檔案作為進入點來執行打包作業，因此往後需要用到 webpack 的檔案都要注入這個 index.js。<br>例如可以這樣寫：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./src/all.scss&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./src/all.js&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="創建編譯指令"><a href="#創建編譯指令" class="headerlink" title="創建編譯指令"></a>創建編譯指令</h3><p>不論是開發或是打包發布，我們可以利用一些簡單的指令來方便我們操作，可以在 package.json 中做以下設定：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;watch&quot;</span>: <span class="string">&quot;webpack --mode=development --watch&quot;</span>,</span><br><span class="line">  <span class="string">&quot;dev&quot;</span>: <span class="string">&quot;webpack --mode=development&quot;</span>,</span><br><span class="line">  <span class="string">&quot;build&quot;</span>: <span class="string">&quot;webpack --mode=production&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>watch 的部分會即時監聽修改並編譯，建議只使用在開發上。</p>
<h2 id="webpack-工具"><a href="#webpack-工具" class="headerlink" title="webpack 工具"></a>webpack 工具</h2><p>webpack 工具可以幫助我們在打包過程中做更多自動化的事情，讓所有繁瑣的工作交給它來處理，介紹幾個實用的工具。</p>
<h3 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h3><p>Babel 可以幫助我們將 js 高版本的語法轉譯成瀏覽器看得懂的 js 語法，像是 es6 等。<br>利用 <code>npm install babel-loader @babel/core @babel/preset-env --save-dev</code> 做安裝，安裝完成後我們在 <code>webpack.config.js</code> 做設定：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.m?js$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/(node_modules|bower_components)/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            presets: [<span class="string">&#x27;@babel/preset-env&#x27;</span>]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="css-loader-與-sass-loader"><a href="#css-loader-與-sass-loader" class="headerlink" title="css loader 與 sass loader"></a>css loader 與 sass loader</h3><p>若需要編譯 css 會需要 css-loader 跟 style-loader 兩種 loader，若今天開發是使用 sass 的話就得多加一個 sass-loader<br>輸入以下指令做安裝：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install css-loader style-loader --save-dev</span><br><span class="line">npm install sass-loader node-sass --save-dev</span><br></pre></td></tr></table></figure>

<p>一樣在 <code>webpack.config.js</code> 引入：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// 編譯 css 檔案設定</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/i</span>,</span><br><span class="line">        use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 編譯 scss 檔案設定</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.s[ac]ss$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;sass-loader&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到了這邊已經確實將 css 編譯引入了，編譯後的結果會存在 <code>index.bundle.js</code> 中，但如果今天想要將編譯結果獨立出來呢？不想將 css 相關編譯到 js 中，那就會需要利用到 mini-css-extract-plugin。<br>這時候我們就不需要 style-loader 了，style-loader 幫助我們將 css 編譯進 js 但我們要獨立出來，因此不需要了。<br>輸入 <code>npm uninstall style-loader --save-dev </code> 解除安裝，並輸入 <code>npm install mini-css-extract-plugin --save-dev</code> 安裝 mini-css-extract-plugin。<br>在 <code>webpack.config.js</code> 設定：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">&#x27;mini-css-extract-plugin&#x27;</span>); <span class="comment">// 先引入</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123; <span class="comment">// css</span></span><br><span class="line">        test: <span class="regexp">/\.css$/i</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123; <span class="comment">// sass</span></span><br><span class="line">      test: <span class="regexp">/\.s[ac]ss$/i</span>,</span><br><span class="line">      use: [</span><br><span class="line">          MiniCssExtractPlugin.loader,</span><br><span class="line">          <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;sass-loader&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [<span class="keyword">new</span> MiniCssExtractPlugin()]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>設定完後去 build 就會發現 build 出來的檔案中 css 被獨立出來了。</p>
<p><strong>補充</strong><br>在 css 打包之後我們最常遇到的問題是圖片路徑引用不正確，我們在引入 <code>background-image</code> 時最常看到 <code>url(&#39;../.....&#39;)</code> 相對路徑的用法，但這時要注意的地方在於通常開發上會習慣把同一類型的檔案用一個資料夾做管理。<br>例如：js 有 js 資料夾，css 有 css 資料夾，img 有 img 資料夾。<br>這時會發生一件事，假如我們的 css 這樣寫 <code>background-image: url(&#39;../img/...png&#39;)</code>，在打包過後這樣的路徑其實會指定到 css 這個資料夾，但 img 應該是上一層才對啊，所以我們又要來調整 <code>webpack.config.js</code> 了。<br>我們可以針對 css 的編譯給他一個 <code>publicPath</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.s[ac]ss$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: MiniCssExtractPlugin.loader,</span><br><span class="line">            options: &#123;</span><br><span class="line">              publicPath: <span class="string">&#x27;../&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;sass-loader&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這樣子編譯完成時，路徑就會自動地指定到上一層，**最後這部分要記得根據開發的專案資料夾結構，去修改 <code>publicPath</code>**。</p>
<h3 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h3><p>在前面的 webpack 打包檔不管是 <code>index.bundle.js</code> 或是獨立出來的 css 檔案都會需要我們手動引入 html，但這會是一個麻煩點，開發者得要一個一個引入，難道不能讓 webpack 幫助我們處理這件事嗎？<br>當然可以～ 來看看 html-webpack-plugin 吧！<br>輸入 <code>npm install html-webpack-plugin --save-dev</code> 安裝。<br>針對 <code>webpack.config.js</code> 設定：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>); <span class="comment">// 先引入</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">&#x27;./src/index.html&#x27;</span>, <span class="comment">// 自動引入靜態 html 的目標文件</span></span><br><span class="line">      filename: <span class="string">&#x27;index.html&#x27;</span> <span class="comment">// 打包完成後生成的檔案名稱</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 若要引入複數個 html 可以有多個 HtmlWebpackPlugin</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">&#x27;./src/content.html&#x27;</span>,</span><br><span class="line">      filename: <span class="string">&#x27;content.html&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>完成之後當我們打包檔案，就會出現我們設定的 html 而且裡面就會自動引入我們打包的 js 跟 css 囉。<br>另外，html-webpack-plugin 預設會幫我們對 html 做壓縮，除非有些自定義需求，不然基本上不需要管它。</p>
<h3 id="terser-webpack-plugin"><a href="#terser-webpack-plugin" class="headerlink" title="terser-webpack-plugin"></a>terser-webpack-plugin</h3><p>接下來介紹的套件，可以幫助我們壓縮 js 檔，甚至可以針對選項做一些設定 <a href="https://github.com/webpack-contrib/terser-webpack-plugin#terseroptions">參考</a>。<br>輸入 <code>npm install terser-webpack-plugin --save-dev</code> 安裝。</p>
<p>針對 <code>webpack.config.js</code> 設定：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> TerserPlugin = <span class="built_in">require</span>(<span class="string">&#x27;terser-webpack-plugin&#x27;</span>); <span class="comment">// 先引入</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimize: <span class="literal">true</span>,</span><br><span class="line">    minimizer: [</span><br><span class="line">      <span class="keyword">new</span> TerserPlugin()</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>這樣子，打包檔案我們就能得到壓縮的 js 了。</p>
<h3 id="clean-webpack-plugin"><a href="#clean-webpack-plugin" class="headerlink" title="clean-webpack-plugin"></a>clean-webpack-plugin</h3><p>若我們在 webpack 為打包的檔案設定命名時有加入 hash 的話，就會遇到我們每次打包時檔名都不同的情形發生，有些檔案是舊的根本用不到，但還留在資料夾內。<br>因此就需要在打包前先清空我們的目標資料夾，以確保內部檔案都是最新的，利用 clean-webpack-plugin 來幫助我們做這件事。<br>輸入 <code>npm install --save-dev clean-webpack-plugin</code> 安裝。</p>
<p>針對 <code>webpack.config.js</code> 設定：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>); <span class="comment">// 先引入</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>設定完後每次打包 webpack 就會幫我們把目標資料夾清空了。</p>
<h3 id="url-loader-amp-file-loader"><a href="#url-loader-amp-file-loader" class="headerlink" title="url-loader &amp; file-loader"></a>url-loader &amp; file-loader</h3><p>在開發網頁時，很容易會遇到靜態資源，如：圖片、字型等。<br>因此 webpack 打包時我們當然也需要將這些靜態資源打包，甚至能壓縮更好，這時就會需要用到 url-loader 跟 file-loader。<br>輸入以下指令來安裝這兩個套件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install file-loader --save-dev</span><br><span class="line">npm install url-loader --save-dev</span><br></pre></td></tr></table></figure>

<p>file-loader 可以幫我們將靜態資源打包處理，url-loader 則是可以針對設定的檔案大小去比對靜態資源，若是低於設定大小就會轉變成 base64 提高之後載入的效能，若是高於設定值則將檔案丟給 file-loader 做處理。</p>
<p>針對 <code>webpack.config.js</code> 設定：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpe?g|gif)$/i</span> <span class="comment">// 驗證副檔名</span></span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              name: <span class="string">&#x27;img/[name].[ext]&#x27;</span>, <span class="comment">// 不做設定預設會是 hash + 副檔名</span></span><br><span class="line">              limlt: <span class="number">10000</span> <span class="comment">// 超過此限制，會將圖片轉成 base64 (byte)</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接下來，來載入字體看看<br>將下載下來的字體放入對應的資料夾中，接著到 scss 以 <code>@font-face</code> 做 import：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&#x27;NotoSansTC&#x27;</span>;</span><br><span class="line">  <span class="attribute">src</span>: url(<span class="string">&#x27;../font/NotoSansTC-Regular.otf&#x27;</span>) format(<span class="string">&#x27;opentype&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一樣到 <code>webpack.config.js</code> 為 file-loader 做配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(woff|woff2|eot|ttf|otf|)$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              name: <span class="string">&#x27;font/[name].[ext]&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>build 之後就會發現 font 的檔案也跟著打包進去了。</p>
<h3 id="image-webpack-loader"><a href="#image-webpack-loader" class="headerlink" title="image-webpack-loader"></a>image-webpack-loader</h3><p>每次開發的時候都會因為圖片檔案大小問題，都要事先壓縮圖片，這件事情我們一樣可以交給 webpack 來幫我們處理。<br>輸入 <code>npm install image-webpack-loader --save-dev</code> 安裝此套件<br>這個套件可以跟 url-loader 並用，接下來到 <code>webpack.config.js</code> 做設定：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.(png|jpe?g|gif)$/i</span>,</span><br><span class="line">      use: [</span><br><span class="line">        &#123;</span><br><span class="line">          loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            name: <span class="string">&#x27;img/[name].[ext]&#x27;</span>,</span><br><span class="line">            limit: <span class="number">200000</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          loader: <span class="string">&#x27;image-webpack-loader&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>接下來只要我們 build，webpack 就會自動幫我們壓縮圖片囉。</p>
<h3 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack dev server"></a>webpack dev server</h3><p>既然我們已經對很多的事情透過 webpack 做自動化的處理，但是最重要的問題，我們的開發畫面呢？<br>我也必須要開發畫面會隨著我更新 code 的時候做即時的更新，這時我們就需要 <code>webpack dev server</code>。<br>先執行此指令做安裝 <code>npm install webpack-dev-server -D</code>，安裝完成後，我們先來 <code>package.json</code> 做設定：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;dev&quot;</span>: <span class="string">&quot;webpack-dev-server&quot;</span>, <span class="comment">// 在這裡加入 webpack-dev-server</span></span><br><span class="line">  <span class="string">&quot;build&quot;</span>: <span class="string">&quot;webpack --mode=production&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>現在已經有指令可以觸發 webpack dev server 了，接下來我們只要去 <code>webpack.config.js</code> 針對 webpack dev server 做設定即可：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  contentBase: path.join(__dirname, <span class="string">&#x27;dist&#x27;</span>), <span class="comment">// 指定 webpack dev server 以哪個資料夾為基礎作監聽。</span></span><br><span class="line">  compress: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多相關設定可以參考<a href="https://webpack.js.org/configuration/dev-server/">官網</a>。<br>最後我們只要根據在 <code>package.json</code> 設定的跑 <code>npm run dev</code> 就會啟動本地 localhost 監聽囉。</p>
<h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>講了那麼多，總算是對 webpack 有更深入的了解，接下來就是整理一個底層的 webpack core 方便以後不使用框架的專案開發了，希望真的能用在實戰上XD。<br>也感謝網路上寫相關教學文章的大大，讓我受益良多。</p>
<hr>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://ithelp.ithome.com.tw/articles/10212909">webpack - 學習筆記</a><br><a href="https://awdr74100.github.io/categories/Webpack/">webpack 前端打包工具</a></p>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js 電商練習技術整理 -- 使用 FormData 上傳圖片的眉眉角角</title>
    <url>/2019/08/05/EcommercePractice5/</url>
    <content><![CDATA[<p><img src="https://i.imgur.com/el9rgW2.jpg"></p>
<h2 id="文章目的"><a href="#文章目的" class="headerlink" title="文章目的"></a>文章目的</h2><p>有時候我們會需要將圖片上傳至後端做儲存，上傳時可利用 FormData 作為圖片的資料格式。<br>本篇將介紹如何操作 Vue Cli 上傳圖片的細節。</p>
<a id="more"></a>

<h2 id="FormData-簡單介紹"><a href="#FormData-簡單介紹" class="headerlink" title="FormData 簡單介紹"></a>FormData 簡單介紹</h2><p>FormData 是一個表單格式，我們可以利用它將資料轉成表單的格式，並且以表單的形式回傳給後端。 —<a href="https://developer.mozilla.org/zh-TW/docs/Web/API/FormData">FormData介紹</a><br><strong>至於上傳圖片時需不需要用 FormData 的形式上傳，是由後端來做決定。</strong></p>
<h2 id="將圖片轉換成-FormData"><a href="#將圖片轉換成-FormData" class="headerlink" title="將圖片轉換成 FormData"></a>將圖片轉換成 FormData</h2><ul>
<li>首先，我們會利用 html 的 <code>&lt;input type=&quot;file&quot;&gt;</code> 來上傳我們的圖片，我們可以為 input 新增一個 change 事件，程式碼如下：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> @<span class="attr">change</span>=<span class="string">&quot;uploadFile&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;files&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>*這邊請務必加入 <code>ref=&#39;files&#39;</code> 否則下個步驟我們會找不到檔案。**</li>
<li>接著我們可以透過 <code>console.log</code> 的方式來找到我們要上傳的圖片所在位置，程式碼如下：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">uploadFile () &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
經觀察後會發現圖片是以陣列的形式存在 <strong>$refs.files.files</strong> 下。</li>
<li>先宣告一個變數來儲存我們找到的圖片<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> uploadedFile = <span class="built_in">this</span>.$refs.files.files[<span class="number">0</span>] <span class="comment">//這邊可根據需求決定是抓哪一張圖片或是整個陣列</span></span><br></pre></td></tr></table></figure></li>
<li>進行到這裡我們就可以把圖片轉換成 FromData，先宣告一個變數是我們的 <code>new FormData()</code>，接著我們利用 <code>append</code> 的方式將我們的圖片塞入，程式碼如下：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> formData = <span class="keyword">new</span> FormData()</span><br><span class="line">formData.append(<span class="string">&#x27;資料屬性(根據後端決定)&#x27;</span>, uploadedFile)</span><br></pre></td></tr></table></figure>
<h2 id="接取-API-與渲染上傳的圖片"><a href="#接取-API-與渲染上傳的圖片" class="headerlink" title="接取 API 與渲染上傳的圖片"></a>接取 API 與渲染上傳的圖片</h2></li>
<li>已成功擁有一個 FormData，接著我們就可以把 FormData 透過 API 傳給後端，那因為是以 FormData的格式傳送，跟之前以物件的形式不同，所以我們需要更改傳遞格式，程式碼如下：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> url = <span class="string">`API 路徑`</span></span><br><span class="line">     <span class="built_in">this</span>.$http.post(url, formData, &#123;</span><br><span class="line">       headers: &#123;</span><br><span class="line">         <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;multipart/form-data&#x27;</span> <span class="comment">//更改成 FormData 的格式</span></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li>
<li>接著後續就可以針對成功回傳後做操作，像是範例這邊我們為了讓上傳成功的圖片能在畫面上呈現，因此我們需要將圖片的連結存在本地端，程式碼如下：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (response.data.success) &#123;</span><br><span class="line">        vm.$set(vm.tempProduct, <span class="string">&#x27;imageUrl&#x27;</span>, response.data.imageUrl)</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
這邊有一點要注意，<strong>因為用平常的方法<code>vm.tempProduct.imgUrl = response.data.imgUrl</code> 無法正確地將路徑儲存</strong>，因此我們<strong>改成用<code>$set</code> 的方式強制將路徑加入</strong>。<br>另外 html 方面就可以有一個 <code>img</code> 標籤 <code>src</code> 動態綁定我們上傳的圖片路徑。<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&quot;tempProduct.imageUrl&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
最後附上完整的事件程式碼：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">uploadFile () &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">   <span class="keyword">const</span> uploadedFile = <span class="built_in">this</span>.$refs.files.files[<span class="number">0</span>]</span><br><span class="line">   <span class="keyword">const</span> vm = <span class="built_in">this</span></span><br><span class="line">   <span class="keyword">const</span> formData = <span class="keyword">new</span> FormData()</span><br><span class="line">   formData.append(<span class="string">&#x27;資料屬性(根據後端決定)&#x27;</span>, uploadedFile)</span><br><span class="line">   <span class="keyword">const</span> url = <span class="string">`上傳的 API 路徑`</span></span><br><span class="line">   <span class="built_in">this</span>.$http.post(url, formData, &#123;</span><br><span class="line">     headers: &#123;</span><br><span class="line">       <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;multipart/form-data&#x27;</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (response.data.success) &#123;</span><br><span class="line">       vm.$set(vm.tempProduct, <span class="string">&#x27;imageUrl&#x27;</span>, response.data.imageUrl)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://www.hexschool.com/vue/">六角學院課程–Vue 出一個電商網站</a></p>
]]></content>
      <categories>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
        <tag>JavaScript</tag>
        <tag>E-commerce</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise - 如何運用 Promise 處理非同步事件</title>
    <url>/2020/12/06/promise/</url>
    <content><![CDATA[<p><img src="https://images.unsplash.com/photo-1591267990439-bc68529677c3?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw=&ixlib=rb-1.2.1&auto=format&fit=crop&w=1036&q=80"></p>
<h2 id="文章目的"><a href="#文章目的" class="headerlink" title="文章目的"></a>文章目的</h2><p>只要是前端工程師一定會碰到需要用 JS 來處理非同步行為，此篇文章用來記錄使用 ES6 的 Promise 來處理非同步事件。</p>
<a id="more"></a>

<h2 id="非同步行為"><a href="#非同步行為" class="headerlink" title="非同步行為"></a>非同步行為</h2><p>這邊我先來簡單的介紹一下何謂非同步行為，我們都知道 JS 是單一執行緒，他會根據程式碼的行數，一行一行的從小到大運作，來舉個例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;第一行&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;第二行&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;第三行&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>如果想要看到印出 <code>第三行</code> 勢必會先看到 <code>第一行</code> 、 <code>第二行</code> 出現在 console 中，因為要印出 <code>第三行</code> 一定得等前兩行運行完才會輪到它。</p>
<p>我們都知道 JS 在 call api 時候都會需要發送請求給伺服器，伺服器再根據請求回傳結果給我們，<strong>發送跟回傳都會需要時間</strong>，而且還會受到很多因素影響需要的時間，例如：網速、伺服器狀況等。</p>
<p>因此我們在 call api 時候就會採取非同步行為，非同步行為可以幫助我們 JS 在執行時，不會因為執行到 call api 時為了等待發送跟回傳，而停在那裡，導致後面程式碼無法執行的情況發生。</p>
<p>當然除了 call api 的 AJAX 是非同步行為外，我們常看到的 <code>setTimeout</code>、<code>addEventListener</code> 其實都算是非同步行為，非同步行為都會被放到事件佇列 (Event Queue) 中，在同步行為完成後或是被觸發後執行。</p>
<h2 id="Promise-優點"><a href="#Promise-優點" class="headerlink" title="Promise 優點"></a>Promise 優點</h2><p>那為什麼會推薦利用 Promise 來處理非同步行為呢？<br>因為非同步行為，會有些無法忽視的常見缺點，透過 Promise 可以幫助我們解決這些缺點，缺點如下：</p>
<ol>
<li>回呼地獄 ( call back hell )</li>
<li>寫法不一致</li>
<li>無法同時執行</li>
</ol>
<p>來看看 Promise 是怎麼解決這些缺點的。</p>
<h3 id="回呼地獄"><a href="#回呼地獄" class="headerlink" title="回呼地獄"></a>回呼地獄</h3><p>相信有接觸 JS 的開發者們對 <code>回呼地獄</code>、<code>call back hell</code>、<code>波動拳</code> 這些名詞不陌生，來看看下面這張圖，你一定更能體會。</p>
<p><img src="https://miro.medium.com/max/2400/1*Co0gr64Uo5kSg89ukFD2dw.jpeg"><br><a href="https://medium.com/ninjadevs/node-7-6-koa-2-asynchronous-flow-control-made-right-b0d41c6ba570">圖片來源</a></p>
<p>基本上會有回呼地獄就是因為當非同步行為一多，我們又希望能有順序性的執行非同步行為，那非 Promise 的寫法就會如同上圖一樣，在一個非同步行為完成後，把下一個非同步行為包覆在前一個的 call back 中，導致結構越來越巢狀，因為輪廓很像波動拳，所以才又有波動拳的說法。</p>
<p>那 Promise 又是如何解決這個問題呢？<br>我們以 Promise 的 api 套件 <a href="https://github.com/axios/axios">axios</a> 做例子，來看一下程式碼：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.get(url)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;first:&#x27;</span>, res)</span><br><span class="line">    <span class="keyword">return</span> axios.get(url2)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;second:&#x27;</span>, res2)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>Promise 利用 return 來執行第二次的行為，並且將結果透過 then 傳入，這樣是不是看起來就比較舒服，解決了回呼地獄的巢狀結構。</p>
<h3 id="寫法不一致"><a href="#寫法不一致" class="headerlink" title="寫法不一致"></a>寫法不一致</h3><p>寫法不一致的行為我們以 jQuery 為例，jQuery 在執行 AJAX 的時候就會有 done、success，來接收我們的執行結果。<br>但 <strong>Promise 都是一律使用 then 來做接收</strong>，且不會因為不同的套件產生不同的寫法，因此解決了寫法不一致的問題。</p>
<h3 id="無法同時執行"><a href="#無法同時執行" class="headerlink" title="無法同時執行"></a>無法同時執行</h3><p><strong>非同步有個特性在於我們無法得知何時開始、何時結束</strong>，若我們需要執行的某個行為是需要多個非同步執行完後才做執行，那非 Promise 的寫法或套件大部分很難做到這點。</p>
<p>Promise 可以透過 <code>Promise.all</code> 來解決這個問題：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([</span><br><span class="line">  axios.get(url),</span><br><span class="line">  axios.get(url2)</span><br><span class="line">]).then(<span class="function">(<span class="params">[res, res2]</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;first:&#x27;</span>, res, <span class="string">&#x27;second:&#x27;</span>, res2)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在 <code>Promise.all</code> 中透過陣列傳入多個非同步行為，再用 then 跟陣列接收多個結果，這樣子就很輕易地解決了需要同時執行的需求。</p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>這篇文章簡單的介紹了一下 Promise 在非同步行為上的處理以及優點。</p>
<p>後續希望有時間能把 Promise 寫成一個小系列文章做個完整介紹。</p>
<p>若有更新系列文章我會再嘗試補上文章連結。</p>
<h2 id="系列連結"><a href="#系列連結" class="headerlink" title="系列連結"></a>系列連結</h2><p><a href="https://hao1229.github.io/2020/12/20/promise2/#more">Promise - Promise 運作概念</a><br><a href="https://hao1229.github.io/2020/12/20/promise3/#more">Promise - Promise Chain</a><br><a href="https://hao1229.github.io/2020/12/20/promise4/#more">Promise - Promise 使用方法</a></p>
<hr>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://www.hexschool.com/courses/js-core.html">六角學院-JavaScript核心篇</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>非同步</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise - Promise 運作概念</title>
    <url>/2020/12/20/promise2/</url>
    <content><![CDATA[<p><img src="https://images.unsplash.com/photo-1550063873-ab792950096b?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw=&ixlib=rb-1.2.1&auto=format&fit=crop&w=1500&q=80"></p>
<h2 id="文章目的"><a href="#文章目的" class="headerlink" title="文章目的"></a>文章目的</h2><p>簡單介紹一下 Promise 的運作，了解運作後，對於使用 Promise 一定會有相當的幫助。</p>
<a id="more"></a>

<h2 id="Promise-狀態"><a href="#Promise-狀態" class="headerlink" title="Promise 狀態"></a>Promise 狀態</h2><p>Promise 在運作過程中會經歷不同的狀態，每個狀態都會有它獨特的地方，我們現在就來看看吧。</p>
<ol>
<li><p>pending（未確認狀態）：Promise 一開始的狀態，尚未得到任何結果。</p>
</li>
<li><p>fulfilled（已實現的狀態）：Promise 完成的狀態，會透過 <code>resolve</code> 作為參數回傳結果，並透過 <code>then</code> 來接收結果。</p>
</li>
<li><p>rejected（已否決的狀態）： Promise 否決的狀態，會透過 <code>reject</code> 作為參數回傳結果（用在串 api 時通常會是 api 的錯誤訊息），可以透過 <code>catch</code> 來接收結果。</p>
</li>
</ol>
<p>fulfilled 跟 rejected 又通稱為 settled（已確認狀態），<strong>當 Promise 運行時，一次只會接收一個 settled</strong>，若想要重新接收 settled 就會先回到 pending 之後重新運行。</p>
<h2 id="Promise-運作範例"><a href="#Promise-運作範例" class="headerlink" title="Promise 運作範例"></a>Promise 運作範例</h2><p>接下來，來看看簡單的範例，藉此更了解上述各狀態的運行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span> (<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (n) &#123;</span><br><span class="line">        resolve(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;fail&#x27;</span>))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn (<span class="number">1</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;successMessage:&#x27;</span>, res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;errorMessage:&#x27;</span>, err)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>這邊宣告了一個 <code>fn</code> 的 Promise 函式，透過 <code>return</code> 的方式回傳一個新的 Promise 物件，並傳入 <code>resolve</code> 和 <code>reject</code> 兩個參數，幫助我們回傳成功與失敗的結果。</p>
<p>至於 <code>setTimeout</code> 就是一個很典型的非同步，所以範例才用 <code>setTimeout</code> 做說明。</p>
<h2 id="自己建立-Promise"><a href="#自己建立-Promise" class="headerlink" title="自己建立 Promise"></a>自己建立 Promise</h2><p>在了解 Promise 的運作概念後，來嘗試看看建立自定義的 Promise。</p>
<p>在建立 Promise 時候我們會透過 <code>new Promise</code> 來建立 Promise 的實體，但這邊要注意的是只寫 <code>const a = new Promise</code> 是不夠的，因為 <strong><code>new Promsie</code> 會需要傳入一個 call back function 才能運作</strong>，所以要這樣寫 <code>const a = new Promise(() =&gt; &#123;&#125;)</code> 才是建立 Promise 的第一步喔！</p>
<p>接下來，來看看範例了解一下各狀態：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果先來看看剛剛宣告的 a，會發現它目前是 pending 的狀態</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接著帶入我們前面提到的參數看看</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, rejcet</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 顯示狀態會變成 fulfilled，因為我們透過 resolve 回傳了結果。</span></span><br><span class="line"></span><br><span class="line">a.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123; <span class="comment">// 透過 then 來接收 resolve 回傳的結果。</span></span><br><span class="line">  <span class="built_in">console</span>.log(res) <span class="comment">// success</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise 改加入參數 reject</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, rejcet</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="string">&#x27;fail&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 顯示狀態會變成 rejected，因為我們透過 reject 回傳了結果。</span></span><br><span class="line"></span><br><span class="line">a.catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="comment">// 透過 catch 來接收 rejcet 回傳的結果。</span></span><br><span class="line">  <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>看到這邊其實已經對 Promise 的建立有了基本的認知，但基本上 Promise 我們都會用函式的方式來建立一個 Promise 函式，而非像上面範例一樣宣告變數。</p>
<p>這邊稍微看一下陳述式與表達式建立 Promise 的起手式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 陳述式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表達式</span></span><br><span class="line"><span class="keyword">const</span> fn2 = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接著 call back function 裡面的內容，我相信剛看完上面的講解，你應該是在熟悉不過了，我這邊就直接填入範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (n) &#123;</span><br><span class="line">        resolve(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="string">&#x27;fail&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn (<span class="number">1</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;success:&#x27;</span>, res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;error:&#x27;</span>, err)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<h2 id="系列連結"><a href="#系列連結" class="headerlink" title="系列連結"></a>系列連結</h2><p><a href="https://hao1229.github.io/2020/12/06/promise/#more">Promise - 如何運用 Promise 處理非同步事件</a><br><a href="https://hao1229.github.io/2020/12/20/promise3/#more">Promise - Promise Chain</a><br><a href="https://hao1229.github.io/2020/12/20/promise4/#more">Promise - Promise 使用方法</a></p>
<hr>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://www.hexschool.com/courses/js-core.html">六角學院-JavaScript核心篇</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>非同步</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise - Promise Chain</title>
    <url>/2020/12/20/promise3/</url>
    <content><![CDATA[<p><img src="https://images.unsplash.com/photo-1550063873-ab792950096b?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw=&ixlib=rb-1.2.1&auto=format&fit=crop&w=1500&q=80"></p>
<h2 id="文章目的"><a href="#文章目的" class="headerlink" title="文章目的"></a>文章目的</h2><p>介紹 Promise Chain 運作邏輯，以及較進階的用法。</p>
<a id="more"></a>

<h2 id="Promise-Chain"><a href="#Promise-Chain" class="headerlink" title="Promise Chain"></a>Promise Chain</h2><p>Promise Chain 就是執行 Promise 的鏈接概念，在 <a href="https://hao1229.github.io/2020/12/06/promise/#more">Promise - 如何運用 Promise 處理非同步事件</a>中有簡單提到 Promise 解決了 call back hell 的困境，那其實用上的就是 Promise 的鏈接方法。</p>
<p>這邊我們來了解一下 Promise Chain 一些的使用邏輯，先來看看範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span> (<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (n) &#123;</span><br><span class="line">        resolve(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="string">&#x27;fail&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn (<span class="number">1</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;success:&#x27;</span>, res)</span><br><span class="line">    <span class="keyword">return</span> fn (<span class="number">2</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;success2:&#x27;</span>, res)</span><br><span class="line">    <span class="keyword">return</span> fn (<span class="number">3</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;success3:&#x27;</span>, res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;error:&#x27;</span>, err)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>上面的範例就是一個簡單的 Promise Chain，<code>fn</code> 透過 <code>then</code> 接收成功的結果，並在得到結果後，透過 <code>return</code> 繼續執行 <code>fn</code>，在上面執行三次 <code>fn</code> 後，我們可以得到完整的三個執行成功結果，但如果我們把程式碼變成下面這樣又會如何呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fn (<span class="number">1</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;success:&#x27;</span>, res)</span><br><span class="line">    <span class="keyword">return</span> fn (<span class="number">0</span>) <span class="comment">// 將 2 改成 0</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;success2:&#x27;</span>, res)</span><br><span class="line">    <span class="keyword">return</span> fn (<span class="number">3</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;success3:&#x27;</span>, res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;error:&#x27;</span>, err)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>執行結果會變成成功結果只有一次，然後出現 <code>error</code> 的結果，原因是我們執行 <code>fn(1)</code> 時沒有問題，但是在執行第二次時我們傳入 0 導致 Promise 回傳錯誤，<strong>當錯誤一回傳 Promise 就會停下後續的執行</strong>。</p>
<p>當出現錯誤後如果想要繼續執行鏈接其實也是可以的，我們只需在 <code>catch</code> 底下 <code>return</code> 新的 Promise 執行即可：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fn (<span class="number">1</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;success:&#x27;</span>, res)</span><br><span class="line">    <span class="keyword">return</span> fn (<span class="number">0</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;success2:&#x27;</span>, res)</span><br><span class="line">    <span class="keyword">return</span> fn (<span class="number">3</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;success3:&#x27;</span>, res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;error:&#x27;</span>, err)</span><br><span class="line">    <span class="keyword">return</span> fn (<span class="number">4</span>) <span class="comment">// 這邊做 return</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;success4:&#x27;</span>, res)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>上面的程式碼，我們一樣可以看到 <code>fn (4)</code> 的執行結果。</p>
<h2 id="then-接收失敗結果"><a href="#then-接收失敗結果" class="headerlink" title="then 接收失敗結果"></a>then 接收失敗結果</h2><p>在前面說過用 <code>then</code> 接收成功的結果，但如果今天想要不管成功與否都繼續執行後續的 Promise 呢？</p>
<p>那就可以使用 <code>then</code> 來接收失敗結果達到需求，來看看範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fn (<span class="number">1</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;success:&#x27;</span>, res)</span><br><span class="line">    <span class="keyword">return</span> fn (<span class="number">2</span>)</span><br><span class="line">  &#125;, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;error:&#x27;</span>, err)</span><br><span class="line">    <span class="keyword">return</span> fn (<span class="number">3</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;message2:&#x27;</span>, res)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>上面的範例可以看到 <code>then</code> 裡面我們傳入了第二個 call back function，第一個 call back function 是接收成功的結果，第二個是接收失敗的結果，透過這樣的寫法無論是成功或是失敗都可以繼續執行後續的 Promise 囉！</p>
<h2 id="相關連結"><a href="#相關連結" class="headerlink" title="相關連結"></a>相關連結</h2><p><a href="https://hao1229.github.io/2020/12/06/promise/#more">Promise - 如何運用 Promise 處理非同步事件</a><br><a href="https://hao1229.github.io/2020/12/20/promise2/#more">Promise - Promise 運作概念</a><br><a href="https://hao1229.github.io/2020/12/20/promise4/#more">Promise - Promise 使用方法</a></p>
<hr>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://www.hexschool.com/courses/js-core.html">六角學院-JavaScript核心篇</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>非同步</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise - Promise 使用方法</title>
    <url>/2020/12/20/promise4/</url>
    <content><![CDATA[<p><img src="https://images.unsplash.com/photo-1550063873-ab792950096b?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw=&ixlib=rb-1.2.1&auto=format&fit=crop&w=1500&q=80"></p>
<h2 id="文章目的"><a href="#文章目的" class="headerlink" title="文章目的"></a>文章目的</h2><p>了解 Promise 常用方法與使用情境。</p>
<a id="more"></a>

<h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h2><p>某些情況下，我們會需要等到多個 Promise 執行完後，才執行其他行為，例如：等待 2 隻 api 的資料回傳後，再整理資料呈現於畫面上。</p>
<p>這種情況下，我們就可以利用 <code>Promise.all</code> 來確保行為是在多個 Promise 執行完後接續執行。</p>
<p>來看看範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params">n, time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span> (<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (n) &#123;</span><br><span class="line">        resolve(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="string">&#x27;fail&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, time)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([</span><br><span class="line">  fn(<span class="number">2</span>, <span class="number">1000</span>),</span><br><span class="line">  fn(<span class="number">3</span>, <span class="number">2000</span>)</span><br><span class="line">])</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;success:&#x27;</span>, res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;error:&#x27;</span>, err)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>上面範例中透過 <code>Promise.all</code> 的陣列傳入兩個 <code>fn</code> 且 time 分別為一秒跟兩秒，在這邊我們會透過 <code>then</code> 得到 <code>[&#39;success&#39;, &#39;success&#39;]</code>，這個陣列是由兩個 <code>fn</code> 執行完後的結果組成的，雖然時間不同，但因為 <code>Promise.all</code> 的關係會等到所有 Promise 執行完後再一次把結果回傳。</p>
<p>**這邊要注意的地方是，放在 <code>Promise.all</code> 中的 Promise 只要有其中一項失敗，就會直接進入 <code>catch</code>**。</p>
<h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h2><p><code>Promise.race</code> 寫法和 <code>Promise.all</code> 一樣，差別在於 <code>Promise.race</code> 只回傳第一個結果，來看一下範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params">n, time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span> (<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (n) &#123;</span><br><span class="line">        resolve(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="string">&#x27;fail&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, time)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([</span><br><span class="line">  fn(<span class="number">2</span>, <span class="number">1000</span>), <span class="comment">// 時間較少，因此會回傳此 Promise 結果</span></span><br><span class="line">  fn(<span class="number">3</span>, <span class="number">2000</span>)</span><br><span class="line">])</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;success:&#x27;</span>, res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;error:&#x27;</span>, err)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>error 也是一樣的道理，若是在發生 error 的 Promise 執行之前就已經得到結果，那 error 並不會被回傳，除非 error 是發生在最早的時候。</p>
<h2 id="系列連結"><a href="#系列連結" class="headerlink" title="系列連結"></a>系列連結</h2><p><a href="https://hao1229.github.io/2020/12/06/promise/#more">Promise - 如何運用 Promise 處理非同步事件</a><br><a href="https://hao1229.github.io/2020/12/20/promise2/#more">Promise - Promise 運作概念</a><br><a href="https://hao1229.github.io/2020/12/20/promise3/#more">Promise - Promise Chain</a></p>
<hr>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://www.hexschool.com/courses/js-core.html">六角學院-JavaScript核心篇</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>非同步</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-刷題筆記</title>
    <url>/2021/01/24/leetcode/</url>
    <content><![CDATA[<p><img src="https://images.unsplash.com/photo-1523634921619-37ce98c1877f?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw=&ixlib=rb-1.2.1&auto=format&fit=crop&w=1952&q=80"></p>
<h2 id="文章目的"><a href="#文章目的" class="headerlink" title="文章目的"></a>文章目的</h2><p>想要利用系列的文章，來記錄一下自己刷 LeetCode 的解題筆記，方便日後複習。</p>
<a id="more"></a>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>筆者在前端領域還是個小菜雞XD，目前刷題方向為 LeetCode 免費試題中難度為 Easy 的題目，刷題語言部分則是 JavaScript。</p>
<h2 id="Single-Number"><a href="#Single-Number" class="headerlink" title="Single Number"></a>Single Number</h2><p><img src="https://i.imgur.com/gVESyKy.png"><br><a href="https://leetcode.com/problems/single-number/">題目連結</a></p>
<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>此題主要目的是丟入一個整數陣列，其中數字都會成對，僅有一個數字非成對，要找出非成對數字為何？</p>
<h3 id="思考方向"><a href="#思考方向" class="headerlink" title="思考方向"></a>思考方向</h3><p>筆者的想法是透過 <code>forEach</code> 與 <code>filter</code> 來幫我達到目的，來看一下程式碼：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> singleNumber = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> target = <span class="literal">null</span></span><br><span class="line">  nums.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> arr = nums.filter(<span class="function"><span class="params">num</span> =&gt;</span> num === item)</span><br><span class="line">    <span class="keyword">if</span> (arr.length === <span class="number">1</span>) &#123;</span><br><span class="line">      target = arr[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> target</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>透過 <code>forEach</code> 查看每個數字，查看的同時利用 <code>filter</code> 將陣列中有相同數字的 item 組成一個新陣列，<strong>若陣列長度為一代表陣列中的數字即為唯一的數字</strong>。</p>
<h3 id="更好方法"><a href="#更好方法" class="headerlink" title="更好方法"></a>更好方法</h3><p>因為上面的方法透過 <code>target</code> 這個變數去儲存新的 array，對於記憶體佔用來說不是非常好，所以可以這樣改寫來加強對記憶體效能的改善：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> singleNumber = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> nums.filter(<span class="function"><span class="params">num</span> =&gt;</span> nums.indexOf(num) === nums.lastIndexOf(num))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這個方法從頭找第一個 index 跟從尾找第一個 index，<strong>如果一樣就代表該數字僅存在一個</strong>。</p>
<h2 id="Running-Sum-of-1d-Array"><a href="#Running-Sum-of-1d-Array" class="headerlink" title="Running Sum of 1d Array"></a>Running Sum of 1d Array</h2><p><img src="https://i.imgur.com/kdw7yxj.png"><br><a href="https://leetcode.com/problems/running-sum-of-1d-array/">題目連結</a></p>
<h3 id="目的-1"><a href="#目的-1" class="headerlink" title="目的"></a>目的</h3><p>此題目的要傳入一個數字陣列到函數中，函數能回傳陣列中的逐漸加總，像是丟入 <code>[1, 2, 3]</code> 就要回傳 <code>[1, 3, 6]</code>，原因為 [1, 1+2, 1+2+3]。</p>
<h3 id="思考方向-1"><a href="#思考方向-1" class="headerlink" title="思考方向"></a>思考方向</h3><p>筆者想法是透過 <code>reduce</code> 將每次加總結果丟入新的陣列，最後回傳該陣列，程式碼如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> runningSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> target = []</span><br><span class="line">  <span class="keyword">const</span> arr = nums.reduce(<span class="function">(<span class="params">prev, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> total = prev + next</span><br><span class="line">    target.push(total)</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> target</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="更好方法-1"><a href="#更好方法-1" class="headerlink" title="更好方法"></a>更好方法</h3><p>但上面的方法，其實並沒有很好，因為這寫法會讓 <code>arr</code> 變得毫無意義。<br>會造成這原因是我對於 <code>reduce</code> 的用法不夠熟悉，後來發現了一個更棒的解法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> runningSum = <span class="function"><span class="params">nums</span> =&gt;</span> &#123;</span><br><span class="line">  nums.reduce(<span class="function">(<span class="params">a, c, i, arr</span>) =&gt;</span> arr[i] += a)</span><br><span class="line">  <span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>reduce</code> 共有四個參數可以做操作，但我只注意到前兩個，恕不知這題可以活用後面的參數來解，<code>i</code> 與 <code>arr</code> 分別代表目前值的索引與我們使用 <code>reduce</code> 的陣列。<br>透過 <code>arr[i] += a</code> 就可以定義當下陣列的索引值等於索引值加上前一個值。</p>
<h2 id="Richest-Customer-Wealth"><a href="#Richest-Customer-Wealth" class="headerlink" title="Richest Customer Wealth"></a>Richest Customer Wealth</h2><p><img src="https://i.imgur.com/SZEMgfR.png"><br><a href="https://leetcode.com/problems/richest-customer-wealth/">題目連結</a></p>
<h3 id="目的-2"><a href="#目的-2" class="headerlink" title="目的"></a>目的</h3><p>這題有點像是情境題，題目要我們把複數個帳號（複數個 array）用一個大 array 包住後丟入函數中，並回傳帳號加總的最大值以找出最有錢的人。</p>
<h3 id="思考方向-2"><a href="#思考方向-2" class="headerlink" title="思考方向"></a>思考方向</h3><p>筆者當下的想法是先透過迴圈將每個 array 裡面的值加總後產生一個擁有每個帳號加總的新 array，再將新 array 透過 <code>sort</code> 降冪排序，最後回傳排序完的第一個值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> maximumWealth = <span class="function"><span class="keyword">function</span>(<span class="params">accounts</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arr = accounts.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item.reduce(<span class="function">(<span class="params">prev, next</span>) =&gt;</span> prev + next)</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> sortArr = arr.sort(<span class="function">(<span class="params">prev, next</span>) =&gt;</span> next - prev)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> sortArr[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="更好方法-2"><a href="#更好方法-2" class="headerlink" title="更好方法"></a>更好方法</h3><p><code>Math.max</code> 可以幫助我們找到 array 中的最大值，改寫的方法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> maximumWealth = <span class="function"><span class="keyword">function</span>(<span class="params">accounts</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max(...accounts.map(<span class="function"><span class="params">account</span> =&gt;</span> </span><br><span class="line">    account.reduce(<span class="function">(<span class="params">accumulator, current</span>) =&gt;</span> accumulator + current, <span class="number">0</span>)</span><br><span class="line">  ))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這個方法省略了上方的 <code>sort</code> 也可以達到效果。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Python - 利用 MoviePy 處理影片</title>
    <url>/2021/03/25/moviepy/</url>
    <content><![CDATA[<p><img src="https://images.unsplash.com/photo-1485846234645-a62644f84728?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw=&ixlib=rb-1.2.1&auto=format&fit=crop&w=1480&q=80"></p>
<h2 id="文章目的"><a href="#文章目的" class="headerlink" title="文章目的"></a>文章目的</h2><p>筆者的公司最近要開發一個簡單的 side-project，在此專案中筆者負責專案後端的開發，雖然我是前端工程師XD。</p>
<p>主要會想來開發後端，想說利用這個機會練習，並且更了解後端的技術。</p>
<p>我預計會寫兩篇相關的文章，分別是 <strong>影片處理</strong> 與 <strong>api 開發</strong>。</p>
<a id="more"></a>

<h2 id="專案目的"><a href="#專案目的" class="headerlink" title="專案目的"></a>專案目的</h2><p>此專案是為了因應過年製作賀卡，將使用者在前台填入的資訊，在後端處理轉換成賀卡影片，並提供 share-link 供使用者分享。</p>
<p>讓你們看看成品示意XD</p>
<p><img src="https://i.imgur.com/tokeURi.gif"></p>
<h2 id="語言選擇"><a href="#語言選擇" class="headerlink" title="語言選擇"></a>語言選擇</h2><p>後端語言百百種，為什麼想要用 Python 開發呢？</p>
<p>主要原因是 Python 相對其他後端語言是較為好上手的，另外有找到相關的 Python 套件可以方便處理影片問題。</p>
<p>最後就是因為公司的後端工程師主要語言也是 Python，方便我問問題XD。</p>
<h2 id="環境建置"><a href="#環境建置" class="headerlink" title="環境建置"></a>環境建置</h2><p>在開發上，建議利用 virtualenv 開發，python3 後面的版本已經有內建的 venv 功能，所以就直接拿它來創建 virtualenv 吧！</p>
<ul>
<li>創建環境： <code>python3 -m venv 環境名稱</code></li>
<li>啟動環境(Windows)： <code>環境名稱\Scripts\activate.bat</code></li>
<li>啟動環境(Unix、MacOS)：<code>source 環境名稱/bin/activate</code></li>
</ul>
<p>啟動成功會看到 shell 前面有環境名稱，像是這樣：</p>
<p><code>(環境名稱) $ python</code></p>
<p>在虛擬環境中我們就可以安裝專案所需套件等，而不用擔心全域環境造成的影響。</p>
<ul>
<li>退出環境： <code>deactivate</code></li>
</ul>
<h2 id="MoviePy"><a href="#MoviePy" class="headerlink" title="MoviePy"></a>MoviePy</h2><p>影片處理在本專案是最主要的需求，主要會需要的影片處理為：</p>
<ol>
<li>影片壓字</li>
<li>影片與聲音合成</li>
<li>影片與圖片合成</li>
</ol>
<p>經過搜尋後發現 <a href="https://zulko.github.io/moviepy/index.html">MoviePy</a> 是個好選擇，它提供了強大的影片後製能力，讓開發上僅需少少的程式碼就能達到專案需求。</p>
<p>接下來的文章將會針對上述三點做紀錄。</p>
<h2 id="MoviePy-壓字處理"><a href="#MoviePy-壓字處理" class="headerlink" title="MoviePy - 壓字處理"></a>MoviePy - 壓字處理</h2><p>在 side-project 中，需要將使用者輸入的祝福語壓在影片上產出。<br>這部分因為 ui 關係所以有所限制，分別是中或英文 4 字，每個文字會漸進出現。</p>
<p>在處理文字需求時，我想到的做法是將從 api 收到的文字內容逐一取出，後製到影片中，並且控制文字出現時間。</p>
<p>首先，要來驗證收到的文字內容是否為英文或是中文：</p>
<p>透過 pip3 安裝 langdetect <code>pip3 install langdetect</code>。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> langdetect <span class="keyword">import</span> detect</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用 language 儲存 detect 驗出的語言， blessing 是 api 傳回的文字內容</span></span><br><span class="line">language = detect(blessing)</span><br><span class="line"></span><br><span class="line"><span class="comment"># word_one 是 blessing 的第一個字</span></span><br><span class="line"><span class="comment"># 產生一個 font-size 是 50px，字體為宋黑的文字，出現時間為 3 秒，從影片第 4 秒出現，位置在影片的 x = 100、y = 113。</span></span><br><span class="line"><span class="keyword">if</span> language == <span class="string">&quot;zh-cn&quot;</span> <span class="keyword">or</span> language == <span class="string">&quot;zh-tw&quot;</span>:</span><br><span class="line">  txt_clip1 = TextClip(word_one, fontsize=<span class="number">50</span>, color=<span class="string">&#x27;white&#x27;</span>, font=<span class="string">&quot;SourceHanSerifTC-Bold.otf&quot;</span>).set_duration(<span class="number">3</span>).set_start(<span class="number">4</span>).set_position((<span class="number">100</span>, <span class="number">113</span>))</span><br></pre></td></tr></table></figure>
<p>MoviePy 透過 <a href="https://zulko.github.io/moviepy/ref/VideoClip/VideoClip.html#textclip">TextClip</a> 改變文字的屬性，並且壓在影片指定位置以及出現時間。</p>
<p><strong>這邊有一點要注意是，MoviePy 利用 <a href="https://imagemagick.org/index.php">ImageMagick</a> 來處理文字效果，因此在使用這功能前請確保環境中已經有裝此套件。</strong></p>
<p>文字的字體若要改變，就要像程式碼中的 font 一樣引用對應的文字 otf 檔案。</p>
<h2 id="MoviePy-聲音合成"><a href="#MoviePy-聲音合成" class="headerlink" title="MoviePy - 聲音合成"></a>MoviePy - 聲音合成</h2><p>製作出來的卡片為了要有天竺鼠的叫聲，因此我們需要把聲音後製上去。</p>
<p>整支影片分了三種聲音，分別為掉落聲、過場聲、跟隨文字出現的提示音。</p>
<p>每一種聲音皆會在影片的不同時間點出現。</p>
<p>來看看程式碼：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 三個 url 代表 三種聲音來源</span></span><br><span class="line">audio_fall = AudioFileClip(fall_url)</span><br><span class="line">audio_walk = AudioFileClip(walk_url).set_start(<span class="number">1</span>)</span><br><span class="line">audio_new_year = AudioFileClip(new_year_url).set_start(<span class="number">4</span>)</span><br><span class="line">new_audio = CompositeAudioClip([audio_fall, audio_walk, audio_new_year])</span><br><span class="line">new_sound_clip = video_clip.set_audio(new_audio)</span><br></pre></td></tr></table></figure>

<p>先透過 <a href="https://zulko.github.io/moviepy/ref/AudioClip.html#audiofileclip">AudioFileClip</a> 設定每種聲音開始的影片對應時間點。</p>
<p>接著，用 <a href="https://zulko.github.io/moviepy/ref/AudioClip.html#compositeaudioclip">CompositeAudioClip</a> 將三種聲音合成一個新的聲音片段。</p>
<p>最後，透過 <code>set_audio</code> 將聲音合進我們的影片中。</p>
<h2 id="MoviePy-圖片合成"><a href="#MoviePy-圖片合成" class="headerlink" title="MoviePy - 圖片合成"></a>MoviePy - 圖片合成</h2><p>在專案中，我們提供使用者自行上傳圖片的功能，所以我們在接收到前台 post 給我們的資料時要先去檢查是否有上傳圖片，如果有上傳圖片，我們就針對上傳的圖片來做處理。</p>
<p>來看看程式碼：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 取得圖片</span></span><br><span class="line">upload_img = request.files.to_dict().get(<span class="string">&quot;upload&quot;</span>)</span><br><span class="line"><span class="comment"># 為了讓收到的圖片統一轉換成統一格式的檔名，ts 為當下的 timestamp</span></span><br><span class="line">filename = secure_filename(<span class="string">&quot;img_&quot;</span> + ts + <span class="string">&quot;.png&quot;</span>)</span><br><span class="line">upload_img.save(filename)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 因為 iphone 上傳的圖片檔，有些副檔名為 &#x27;heic&#x27;，故利用此方法作轉換 </span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;heic&quot;</span> <span class="keyword">in</span> upload_img.headers[<span class="string">&quot;Content-Type&quot;</span>]:</span><br><span class="line">  heif_file = pyheif.read(filename)</span><br><span class="line">  transform_image = Image.frombytes(</span><br><span class="line">    heif_file.mode,</span><br><span class="line">    heif_file.size,</span><br><span class="line">    heif_file.data,</span><br><span class="line">    <span class="string">&quot;raw&quot;</span>,</span><br><span class="line">    heif_file.mode,</span><br><span class="line">    heif_file.stride,</span><br><span class="line">  )</span><br><span class="line">  transform_image.save(<span class="string">&quot;img_&quot;</span> + ts + <span class="string">&quot;.png&quot;</span>, <span class="string">&#x27;PNG&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用 cv2 讀取圖檔，為了針對圖片做裁切處理</span></span><br><span class="line">img = cv2.imread(filename)</span><br><span class="line">cv2.imwrite(filename, img)</span><br><span class="line">im = Image.<span class="built_in">open</span>(filename)</span><br><span class="line">rgb_im = im.convert(<span class="string">&#x27;RGB&#x27;</span>)</span><br><span class="line">thumb_width = <span class="number">200</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此函式用來裁切圖片正中央</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crop_center</span>(<span class="params">pil_img, crop_width, crop_height</span>):</span></span><br><span class="line">  img_width, img_height = pil_img.size</span><br><span class="line">  <span class="keyword">return</span> pil_img.crop(((img_width - crop_width) // <span class="number">2</span>,</span><br><span class="line">                        (img_height - crop_height) // <span class="number">2</span>,</span><br><span class="line">                        (img_width + crop_width) // <span class="number">2</span>,</span><br><span class="line">                        (img_height + crop_height) // <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回傳 crop_center 完成的結果，基本上，第 2、第 3 個參數傳入我們前面的 thumb_width</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crop_max_square</span>(<span class="params">pil_img</span>):</span></span><br><span class="line">  <span class="keyword">return</span> crop_center(pil_img, <span class="built_in">min</span>(pil_img.size), <span class="built_in">min</span>(pil_img.size))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將裁好的正方形圖片轉換成圓形</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mask_circle_transparent</span>(<span class="params">pil_img, blur_radius, offset=<span class="number">0</span></span>):</span></span><br><span class="line">  offset = blur_radius * <span class="number">2</span> + offset</span><br><span class="line">  mask = Image.new(<span class="string">&quot;L&quot;</span>, pil_img.size, <span class="number">0</span>)</span><br><span class="line">  draw = ImageDraw.Draw(mask)</span><br><span class="line">  draw.ellipse((offset, offset, pil_img.size[<span class="number">0</span>] - offset, pil_img.size[<span class="number">1</span>] - offset), fill=<span class="number">255</span>)</span><br><span class="line">  mask = mask.<span class="built_in">filter</span>(ImageFilter.GaussianBlur(blur_radius))</span><br><span class="line"></span><br><span class="line">  result = pil_img.copy()</span><br><span class="line">  result.putalpha(mask)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">im_square = crop_max_square(rgb_im).resize((thumb_width, thumb_width), Image.LANCZOS)</span><br><span class="line">im_thumb = mask_circle_transparent(im_square, <span class="number">1</span>)</span><br><span class="line">im_title = <span class="string">&quot;img_&quot;</span> + ts + <span class="string">&quot;.png&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 將處理好的圖片儲存起來</span></span><br><span class="line">im_thumb.save(im_title)</span><br></pre></td></tr></table></figure>

<p>完成了上述的圖片處理後，接著又要回到我們的 MoviePy，來幫我們把處理好的圖片合成進影片中。</p>
<p>來看看程式碼：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">img_falling = (ImageClip(im_title)).set_duration(video_clip.duration)\</span><br><span class="line">  .set_position(<span class="keyword">lambda</span> t: (<span class="string">&#x27;center&#x27;</span>, -<span class="number">200</span> + <span class="number">640</span> * np.sin(t))).set_duration(<span class="number">2</span>).resize(height=<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">img_scale = (ImageClip(im_title)).set_duration(<span class="number">1.5</span>).resize(height=<span class="number">200</span>).resize(<span class="keyword">lambda</span> t: <span class="number">1</span> + <span class="number">0.8</span> * t)\</span><br><span class="line">  .set_start(<span class="number">2</span>).set_position(<span class="keyword">lambda</span> t: (<span class="string">&#x27;center&#x27;</span>, <span class="number">340</span> - <span class="number">100</span> * np.cos(t + <span class="number">400</span>)))</span><br><span class="line"></span><br><span class="line">img_final = (ImageClip(im_title)).set_duration(<span class="number">2.5</span>).resize(height=<span class="number">415</span>).set_start(<span class="number">3.5</span>)\</span><br><span class="line">  .set_position((<span class="string">&quot;center&quot;</span>, <span class="number">280</span>))</span><br></pre></td></tr></table></figure>
<p>可以看到上面有三個變數，原因是影片中圖片會需要三個特效：</p>
<ol>
<li>掉落</li>
<li>放大</li>
<li>定位</li>
</ol>
<p>三種特效是接力出現，所以我將圖片個別針對每個特效存成三種，並控制出現時間，再做串連。</p>
<h2 id="MoviePy-影片輸出"><a href="#MoviePy-影片輸出" class="headerlink" title="MoviePy - 影片輸出"></a>MoviePy - 影片輸出</h2><p>這邊比較單純，我們直接看程式碼：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果沒有上傳圖片，就不需要 img_falling, img_scale, img_final</span></span><br><span class="line">video_result = CompositeVideoClip(</span><br><span class="line">  [new_sound_clip, txt_clip1, txt_clip2, txt_clip3, txt_clip4, img_falling, img_scale, img_final])</span><br><span class="line">video_name = ts + <span class="string">&quot;.mp4&quot;</span></span><br><span class="line">video_result.write_videofile(video_name, audio_codec=<span class="string">&quot;aac&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>到了這邊，我們就能看到完成的 mp4 影片檔囉！</p>
<h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>在下一篇有關 api 的部分，會提到如何將影片製作功能上到 api 並且作部署，另外我們影片資料會存進 google cloud storage，如何儲存、如何取得資料都會在下篇提到。</p>
<p>這是我第一次處理後端的事情，過程中遇到了很多瓶頸，但我真的學到了很多，對後端也有更深的了解，在此做個紀錄，也希望此篇記錄能幫到更多的人：）</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-刷題筆記2</title>
    <url>/2021/05/01/leetcode2/</url>
    <content><![CDATA[<p><img src="https://images.unsplash.com/photo-1523634921619-37ce98c1877f?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw=&ixlib=rb-1.2.1&auto=format&fit=crop&w=1952&q=80"></p>
<h2 id="文章目的"><a href="#文章目的" class="headerlink" title="文章目的"></a>文章目的</h2><p>想要利用系列的文章，來記錄一下自己刷 LeetCode 的解題筆記，方便日後複習。</p>
<a id="more"></a>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>筆者在前端領域還是個小菜雞XD，目前刷題方向為 LeetCode 免費試題中難度為 Easy 的題目，刷題語言部分則是 JavaScript。</p>
<h2 id="Kids-With-the-Greatest-Number-of-Candies"><a href="#Kids-With-the-Greatest-Number-of-Candies" class="headerlink" title="Kids With the Greatest Number of Candies"></a>Kids With the Greatest Number of Candies</h2><p><img src="https://i.imgur.com/Wt2Wvkw.png"><br><a href="https://leetcode.com/problems/kids-with-the-greatest-number-of-candies/">題目連結</a></p>
<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>此題主要目的，有個陣列裡頭數字代表每個小孩目前擁有的糖果數，並且還有額外的糖果，想要問每個小孩拿到額外糖果後會不會成為最多糖果的人（可以同時存在擁有多個糖果的人），最後回傳含有 boolean 的陣列。</p>
<h3 id="思考方向"><a href="#思考方向" class="headerlink" title="思考方向"></a>思考方向</h3><p>筆者的想法是透過 <code>map</code> 查看每個小孩的糖果，並且為他們加上額外的糖果數，接著再利用 <code>filter</code> 去篩選出是否有糖果數大於已經加入額外糖果的小孩，如果有就回傳 <code>false</code>，沒有就回傳 <code>true</code>，來看一下程式碼：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> kidsWithCandies = <span class="function">(<span class="params">candies, extraCandies</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> candies.map(<span class="function">(<span class="params">candy</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> combineCandy = candy + extraCandies</span><br><span class="line">    <span class="keyword">const</span> arr = candies.filter(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; combineCandy)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> arr.length ? <span class="literal">false</span> : <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若 <code>arr</code> 裡存在數值，代表該小孩的糖果數即使加了額外糖果，還是有其他小孩的糖果比他多，所以我們要回傳的陣列就會給他 <code>false</code>，反之就是 <code>true</code>。</p>
<h3 id="更好方法"><a href="#更好方法" class="headerlink" title="更好方法"></a>更好方法</h3><p>這邊透過 <code>Math.max</code> 可以讓程式碼更為優雅，先利用 <code>Math.max</code> 找出 <code>candies</code> 中最大的糖果數，接著透過 <code>map</code> 為每個糖果加上額外糖果，並檢查是否有大於等於最大糖果數，看一下程式碼：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> kidsWithCandies = <span class="function">(<span class="params">candies, extraCandies</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> max = <span class="built_in">Math</span>.max(...candies)</span><br><span class="line">  <span class="keyword">return</span> candies.map(<span class="function"><span class="params">candy</span> =&gt;</span> candy + extraCandies &gt;= max)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Shuffle-the-Array"><a href="#Shuffle-the-Array" class="headerlink" title="Shuffle the Array"></a>Shuffle the Array</h2><p><img src="https://i.imgur.com/6SOmmS2.png"><br><a href="https://leetcode.com/problems/shuffle-the-array/">題目連結</a></p>
<h3 id="目的-1"><a href="#目的-1" class="headerlink" title="目的"></a>目的</h3><p>這題會傳入一個數字陣列與一個整數到函數中，陣列的長度會是整數的兩倍，也就是 2n，函數需要處理的是將陣列從 2n 變成 n n，並將同索引的數字連在一起產出新陣列，例如：<code>[n1[i], n2[i], n1[i+1], n2[i+1]]</code>。</p>
<h3 id="思考方向-1"><a href="#思考方向-1" class="headerlink" title="思考方向"></a>思考方向</h3><p>筆者透過 <code>filter</code> 將數字分成兩個陣列，再透過對其中一個陣列做迴圈，把兩個陣列的同索引數字塞入新陣列中，並回傳該新陣列，來看一下程式碼：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> shuffle = <span class="function">(<span class="params">nums, n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> arr = nums.filter(<span class="function">(<span class="params">item, index</span>) =&gt;</span> index &lt; n)</span><br><span class="line">  <span class="keyword">const</span> arr2 = nums.filter(<span class="function">(<span class="params">item, index</span>) =&gt;</span> index &gt;= n)</span><br><span class="line">  <span class="keyword">let</span> combineArr = []</span><br><span class="line">  </span><br><span class="line">  arr.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">      combineArr.push(item)</span><br><span class="line">      combineArr.push(arr2[index])</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> combineArr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用 n 把數字拆成兩個陣列，接著用 <code>forEach</code> 把兩陣列同索引的值塞入 <code>combineArr</code> 中。</p>
<h3 id="更好方法-1"><a href="#更好方法-1" class="headerlink" title="更好方法"></a>更好方法</h3><p>筆者找到一個方法，發現其實這題蠻考驗邏輯的XD。<br>陣列中後半段的數字對應的索引其實就是前半段索引加 n，根據這邏輯可以讓程式碼更簡潔，來看一下程式碼：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> shuffle = <span class="function">(<span class="params">nums, n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> res = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    res.push(nums[i], nums[i+n])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>透過新的方法改寫，程式碼是不是變優雅很多，而且更易理解了。</p>
<h2 id="Jewels-and-Stones"><a href="#Jewels-and-Stones" class="headerlink" title="Jewels and Stones"></a>Jewels and Stones</h2><p><img src="https://i.imgur.com/DeTjaW4.png"><br><a href="https://leetcode.com/problems/jewels-and-stones/">題目連結</a></p>
<h3 id="目的-2"><a href="#目的-2" class="headerlink" title="目的"></a>目的</h3><p>這題我覺得蠻有趣的，你會有一堆石頭，並且你知道寶石的種類，然後要你找出石頭裡有幾種寶石。<br>寶石與石頭都是由英文大小寫的字串組成，每一個大寫與每一個小寫皆代表一種石頭。</p>
<h3 id="思考方向-2"><a href="#思考方向-2" class="headerlink" title="思考方向"></a>思考方向</h3><p>大方向來講就是找出石頭堆字串中有多少字是與寶石吻合的。<br>筆者想法是先將兩串文字拆出來組成兩個陣列，再用陣列去比對並算出符合的數量，接著來看看程式碼：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numJewelsInStones = <span class="function"><span class="keyword">function</span>(<span class="params">jewels, stones</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> jewelsTotal = jewels.length;</span><br><span class="line">  <span class="keyword">const</span> stonesTotal = stones.length;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> stonesBox = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; stonesTotal; i++) &#123;</span><br><span class="line">      stone = i === stonesTotal ? stones.substring(i) : stones.substring(i, i+<span class="number">1</span>);</span><br><span class="line">      stonesBox.push(stone);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> jewelsBox = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; jewelsTotal; i++) &#123;</span><br><span class="line">      jewel = i === jewelsTotal ? jewels.substring(i) : jewels.substring(i, i+<span class="number">1</span>);</span><br><span class="line">      jewelsBox.push(jewel);</span><br><span class="line">  &#125;</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  jewelsBox.forEach(<span class="function">(<span class="params">jewel</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> jewelsCount = stonesBox.filter(<span class="function"><span class="params">stone</span> =&gt;</span> stone === jewel).length;</span><br><span class="line">      count += jewelsCount;</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> count</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="更好方法-2"><a href="#更好方法-2" class="headerlink" title="更好方法"></a>更好方法</h3><p>不得不說筆者對於 JS 部分的方法還不是這麼的熟練，看完別人分享的解法，真的讓我眼睛為之一亮，這邊分享一個我覺得很不錯的方法，直接來看看程式碼：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numJewelsInStones = <span class="function">(<span class="params">J, S</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> jewels = <span class="keyword">new</span> <span class="built_in">Set</span>(J)</span><br><span class="line">  <span class="keyword">return</span> S.split(<span class="string">&#x27;&#x27;</span>).reduce(<span class="function">(<span class="params">res, s</span>) =&gt;</span> res + jewels.has(s), <span class="number">0</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>這方法是 <code>Set</code> 與 <code>reduce</code> 結合的應用，先將寶石種類製作成 <code>Set</code>，那為什麼適合這樣做？<br>是因為寶石每個種類皆是唯一，所以適合組成 <code>Set</code> 來幫我們比對。</p>
<p>透過 <code>split</code> 將字串拆成陣列（哎，當初怎麼沒想到有這招），接著透過 <code>reduce</code> 搜尋每一個符合的石頭並加總，這邊利用了 <code>true</code> 在做運算時可當作 1 的特性（<code>false</code> 的話會是0），因此省略了不少步驟。</p>
<p>短短幾行程式碼就解決了這次的問題，真是優雅啊。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
</search>
